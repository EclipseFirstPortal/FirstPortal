local Font_Old = Enum.Font.GothamBold
local Path = game:GetService("RunService"):IsStudio() and game.Players.LocalPlayer.PlayerGui or game.CoreGui
local Tick = tick() 
repeat wait() until game:IsLoaded(); 
local Tick = tick()
do 
	writefile("smallest_pixel.ttf", game:HttpGet("https://github.com/pwrsk/z/blob/main/ProggyTiny.ttf"))
	local smallest_pixel = {
		name = "SmallestPixel7",
		faces = {
			{
				name = "Regular",
				weight = 400,
				style = "normal",
				assetId = getcustomasset("smallest_pixel.ttf")
			}
		}
	}
	writefile("menu_font.font", game:GetService("HttpService"):JSONEncode(smallest_pixel))
	getgenv().menu_font = Font.new(getcustomasset("menu_font.font"), Enum.FontWeight.Regular)
end; 
do 
	Library = {
		Open = true;
		Accent = Color3.fromRGB(115, 100, 215);
		Pages = {};
		Sections = {};
		Flags = {};
		UnNamedFlags = 0;
		ThemeObjects = {};
		Holder = nil;
		Keys = {
			[Enum.KeyCode.LeftShift] = "LShift",
			[Enum.KeyCode.RightShift] = "RShift",
			[Enum.KeyCode.LeftControl] = "LCtrl",
			[Enum.KeyCode.RightControl] = "RCtrl",
			[Enum.KeyCode.LeftAlt] = "LAlt",
			[Enum.KeyCode.RightAlt] = "RAlt",
			[Enum.KeyCode.CapsLock] = "Caps",
			[Enum.KeyCode.One] = "1",
			[Enum.KeyCode.Two] = "2",
			[Enum.KeyCode.Three] = "3",
			[Enum.KeyCode.Four] = "4",
			[Enum.KeyCode.Five] = "5",
			[Enum.KeyCode.Six] = "6",
			[Enum.KeyCode.Seven] = "7",
			[Enum.KeyCode.Eight] = "8",
			[Enum.KeyCode.Nine] = "9",
			[Enum.KeyCode.Zero] = "0",
			[Enum.KeyCode.KeypadOne] = "Num1",
			[Enum.KeyCode.KeypadTwo] = "Num2",
			[Enum.KeyCode.KeypadThree] = "Num3",
			[Enum.KeyCode.KeypadFour] = "Num4",
			[Enum.KeyCode.KeypadFive] = "Num5",
			[Enum.KeyCode.KeypadSix] = "Num6",
			[Enum.KeyCode.KeypadSeven] = "Num7",
			[Enum.KeyCode.KeypadEight] = "Num8",
			[Enum.KeyCode.KeypadNine] = "Num9",
			[Enum.KeyCode.KeypadZero] = "Num0",
			[Enum.KeyCode.Minus] = "-",
			[Enum.KeyCode.Equals] = "=",
			[Enum.KeyCode.Tilde] = "~",
			[Enum.KeyCode.LeftBracket] = "[",
			[Enum.KeyCode.RightBracket] = "]",
			[Enum.KeyCode.RightParenthesis] = ")",
			[Enum.KeyCode.LeftParenthesis] = "(",
			[Enum.KeyCode.Semicolon] = ",",
			[Enum.KeyCode.Quote] = "'",
			[Enum.KeyCode.BackSlash] = "\\",
			[Enum.KeyCode.Comma] = ",",
			[Enum.KeyCode.Period] = ".",
			[Enum.KeyCode.Slash] = "/",
			[Enum.KeyCode.Asterisk] = "*",
			[Enum.KeyCode.Plus] = "+",
			[Enum.KeyCode.Period] = ".",
			[Enum.KeyCode.Backquote] = "`",
			[Enum.UserInputType.MouseButton1] = "MB1",
			[Enum.UserInputType.MouseButton2] = "MB2",
			[Enum.UserInputType.MouseButton3] = "MB3"
		};
		Connections = {};
		UIKey = newkey;
		ScreenGUI = nil;
		FSize = 10;
		UIFont = nil;
		SettingsPage = nil;
		VisValues = {};
		Cooldown = false;
		Friends = {};
		Priorities = {};
		KeyList = nil;
	}
	local Flags = {}; 
	local Dropdowns = {}; 
	local Pickers = {}; 
	local VisValues = {}; 
	Library.__index = Library
	Library.Pages.__index = Library.Pages
	Library.Sections.__index = Library.Sections
	local LocalPlayer = game:GetService('Players').LocalPlayer;
	local Mouse = LocalPlayer:GetMouse();
	local TweenService = game:GetService("TweenService");
	do
		function Library:Connection(Signal, Callback)
			local Con = Signal:Connect(Callback)
			return Con
		end
		
		function Library:Disconnect(Connection)
			Connection:Disconnect()
		end
		
		function Library:Round(Number, Float)
			return Float * math.floor(Number / Float)
		end
		function Library.NextFlag()
			Library.UnNamedFlags = Library.UnNamedFlags + 1
			return string.format("%.14g", Library.UnNamedFlags)
		end
		
        function Library:GetConfig()
            local Config = ""
            local excludedFlags = {
                "SettingsConfigurationName",
                "SettingConfigurationList"
            }
            
            for Index, Value in pairs(self.Flags) do
                local shouldExclude = false
                for _, excludedFlag in ipairs(excludedFlags) do
                    if Index == excludedFlag then
                        shouldExclude = true
                        break
                    end
                end
                
                if not shouldExclude then
                    if
                        Index ~= "ConfigConfig_List"
                        and Index ~= "ConfigConfig_Load"
                        and Index ~= "ConfigConfig_Save"
                    then
                        local Value2 = Value
                        local Final = ""
                        
                        if typeof(Value2) == "Color3" then
                            local hue, sat, val = Value2:ToHSV()
                            
                            Final = ("rgb(%s,%s,%s,%s)"):format(hue, sat, val, 1)
                        elseif typeof(Value2) == "table" and Value2.Color and Value2.Transparency then
                            local hue, sat, val = Value2.Color:ToHSV()
                            
                            Final = ("rgb(%s,%s,%s,%s)"):format(hue, sat, val, Value2.Transparency)
                        elseif typeof(Value2) == "table" and Value.Mode then
                            local Values = Value.current
                            
                            Final = ("key(%s,%s,%s)"):format(Values[1] or "nil", Values[2] or "nil", Value.Mode)
                        elseif Value2 ~= nil then
                            if typeof(Value2) == "boolean" then
                                Value2 = ("bool(%s)"):format(tostring(Value2))
                            elseif typeof(Value2) == "table" then
                                local New = "table("
                                
                                for Index2, Value3 in pairs(Value2) do
                                    New = New .. Value3 .. ","
                                end
                                
                                if New:sub(#New) == "," then
                                    New = New:sub(0, #New - 1)
                                end
                                
                                Value2 = New .. ")"
                            elseif typeof(Value2) == "string" then
                                Value2 = ("string(%s)"):format(Value2)
                            elseif typeof(Value2) == "number" then
                                Value2 = ("number(%s)"):format(Value2)
                            end
                            
                            Final = Value2
                        end
                        
                        Config = Config .. Index .. ": " .. tostring(Final) .. "\n"
                    end
                end
            end
            
            return Config
        end
		
		function Library:LoadConfig(Config)
			local Table = string.split(Config, "\n")
			local Table2 = {}
			for Index, Value in pairs(Table) do
				local Table3 = string.split(Value, ":")
				
				if Table3[1] ~= "ConfigConfig_List" and #Table3 >= 2 then
					local Value = Table3[2]:sub(2, #Table3[2])
					
					if Value:sub(1, 3) == "rgb" then
						local Table4 = string.split(Value:sub(5, #Value - 1), ",")
						
						Value = Table4
					elseif Value:sub(1, 3) == "key" then
						local Table4 = string.split(Value:sub(5, #Value - 1), ",")
						
						if Table4[1] == "nil" and Table4[2] == "nil" then
							Table4[1] = nil
							Table4[2] = nil
						end
						
						Value = Table4
					elseif Value:sub(1, 4) == "bool" then
						local Bool = Value:sub(6, #Value - 1)
						
						Value = Bool == "true"
					elseif Value:sub(1, 5) == "table" then
						local Table4 = string.split(Value:sub(7, #Value - 1), ",")
						
						Value = Table4
					elseif Value:sub(1, 6) == "string" then
						local String = Value:sub(8, #Value - 1)
						
						Value = String
					elseif Value:sub(1, 6) == "number" then
						local Number = tonumber(Value:sub(8, #Value - 1))
						
						Value = Number
					end
					
					Table2[Table3[1]] = Value
				end
			end
			
			for i, v in pairs(Table2) do
				if Flags[i] then
					if typeof(Flags[i]) == "table" then
						Flags[i]:Set(v)
					else
						Flags[i](v)
					end
				end
			end
		end
		
		function Library:SetOpen(bool)
			if typeof(bool) == 'boolean' then
				Library.Open = bool;
				Library.Holder.Visible = bool;
			end
		end;
		
		function Library:IsMouseOverFrame(Frame)
			local AbsPos, AbsSize = Frame.AbsolutePosition, Frame.AbsoluteSize;

			if Mouse.X >= AbsPos.X and Mouse.X <= AbsPos.X + AbsSize.X
				and Mouse.Y >= AbsPos.Y and Mouse.Y <= AbsPos.Y + AbsSize.Y then

				return true;
			end;
		end;
		
		function Library:ChangeAccent(Color)
			Library.Accent = Color

			for obj, theme in next, Library.ThemeObjects do
				if theme:IsA("Frame") or theme:IsA("TextButton") then
					theme.BackgroundColor3 = Color
				elseif theme:IsA("TextLabel") or theme:IsA("TextBox") then
					theme.TextColor3 = Color
				elseif theme:IsA("ImageLabel") or theme:IsA("ImageButton") then
					theme.ImageColor3 = Color
				elseif theme:IsA("ScrollingFrame") then
					theme.ScrollBarImageColor3 = Library.Accent
				end
			end
		end
		
		function Library:Toggle(Bool)
			self.Open = Bool
			Library.Holder.Visible = Bool

		end
	end;


	do
		function Library:NewPicker(name, default, defaultalpha, parent, count, flag, callback)
			local Icon = Instance.new("TextButton", parent)
			local ColorWindow = Instance.new('Frame', Icon)
			local WindowInline = Instance.new('Frame', ColorWindow)
			local Color = Instance.new('TextButton', WindowInline)
			local Sat = Instance.new('ImageLabel', Color)
			local Val = Instance.new('ImageLabel', Color)
			local Container = Instance.new('Frame', Color)
			local Hue = Instance.new('ImageButton', Color)
			local Alpha = Instance.new('ImageButton', Color)
			local HueSlide = Instance.new('Frame', Hue)
			local AlphaSlide = Instance.new('Frame', Alpha)
			
			Icon.Name = "Icon"
			Icon.AnchorPoint = Vector2.new(0, 0.5)
			Icon.BackgroundColor3 = default
			Icon.BorderColor3 = Color3.fromRGB(30, 30, 30)
			Icon.BorderSizePixel = 0
			if count == 1 then
				Icon.Position = UDim2.new(1, - (count * 34),0.5,0)
			else
				Icon.Position = UDim2.new(1, - (count * 34) - (count * 4),0.5,0)
			end
			Icon.Size = UDim2.new(0, 34, 0, 10)
			Icon.Text = ""
			Icon.AutoButtonColor = false

			local UIGradient = Instance.new("UIGradient")
			UIGradient.Name = "UIGradient"
			UIGradient.Color = ColorSequence.new({
				ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(120, 120, 120)),
			})
			UIGradient.Rotation = 90
			UIGradient.Parent = Icon

			local UIStroke = Instance.new("UIStroke")
			UIStroke.Name = "UIStroke"
			UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			UIStroke.Color = Color3.fromRGB(30, 30, 30)
			UIStroke.LineJoinMode = Enum.LineJoinMode.Miter
			UIStroke.Parent = Icon
			
			ColorWindow.Name = "ColorWindow"
			ColorWindow.Parent = Icon
			ColorWindow.Position = UDim2.new(1,-2,1,2)
			ColorWindow.Size = UDim2.new(0,150,0,146)
			ColorWindow.AnchorPoint = Vector2.new(1,0)
			ColorWindow.ZIndex = 100
			ColorWindow.Visible = false
			ColorWindow.BorderSizePixel = 1
			ColorWindow.BackgroundColor3 = Color3.fromRGB(20,20,20)
			ColorWindow.BorderColor3 = Color3.fromRGB(30,30,30)
			
			WindowInline.Name = "WindowInline"
			WindowInline.Position = UDim2.new(0,1,0,1)
			WindowInline.Size = UDim2.new(1,-2,1,-2)
			WindowInline.BackgroundColor3 = Color3.fromRGB(24, 25, 27)
			WindowInline.BorderSizePixel = 0;
			WindowInline.ZIndex = 100
			
			Color.Name = "Color"
			Color.Position = UDim2.new(0,1,0,1)
			Color.Size = UDim2.new(0,120,0,120)
			Color.BackgroundColor3 = default
			Color.BorderColor3 = Color3.new(0,0,0)
			Color.BorderSizePixel = 0
			Color.Text = ""
			Color.TextColor3 = Color3.new(0,0,0)
			Color.AutoButtonColor = false
			Color.Font = Enum.Font.SourceSans
			Color.TextSize = 7
			Color.ZIndex = 100
			
			Sat.Name = "Sat"
			Sat.Size = UDim2.new(1,0,1,0)
			Sat.BackgroundColor3 = Color3.new(1,1,1)
			Sat.BackgroundTransparency = 1
			Sat.BorderSizePixel = 0
			Sat.BorderColor3 = Color3.new(0,0,0)
			Sat.Image = "https://create.roblox.com/store/asset/121353311717943"
			Sat.ZIndex = 100
			
			Val.Name = "Val"
			Val.Size = UDim2.new(1,0,1,0)
			Val.BackgroundColor3 = Color3.new(1,1,1)
			Val.BackgroundTransparency = 1
			Val.BorderSizePixel = 0
			Val.BorderColor3 = Color3.new(0,0,0)
			Val.Image = "http://www.roblox.com/asset/?id=14684563800"
			Val.ZIndex = 100
			
			Container.Name = "Container"
			Container.Position = UDim2.new(0,-2,1,5)
			Container.Size = UDim2.new(0,189,0,55)
			Container.BackgroundColor3 = Color3.new(1,1,1)
			Container.BackgroundTransparency = 1
			Container.BorderColor3 = Color3.new(0,0,0)
			Container.ZIndex = 100
			
			Hue.Name = "Hue"
			Hue.Position = UDim2.new(1,10,0,0)
			Hue.Size = UDim2.new(0,15,1,0)
			Hue.BackgroundColor3 = Color3.new(1,1,1)
			Hue.BorderColor3 = Color3.new(0,0,0)
			Hue.Image = "http://www.roblox.com/asset/?id=14684557999"
			Hue.AutoButtonColor = false
			Hue.ZIndex = 100
			Hue.BorderSizePixel = 0
			
			Alpha.Name = "Alpha"
			Alpha.Position = UDim2.new(0,0,1,7)
			Alpha.Size = UDim2.new(0,146,0,15)
			Alpha.BackgroundColor3 = Color3.new(1,1,1)
			Alpha.BorderColor3 = Color3.new(0,0,0)
			Alpha.Image = "http://www.roblox.com/asset/?id=16841308372"
			Alpha.AutoButtonColor = false
			Alpha.ZIndex = 100
			Alpha.BorderSizePixel = 0
			
			HueSlide.Name = "HueSlide"
			HueSlide.Size = UDim2.new(1,0,0,3)
			HueSlide.BackgroundColor3 = Color3.new(1,1,1)
			HueSlide.BorderColor3 = Color3.new(0,0,0)
			HueSlide.BorderSizePixel = 1
			
			AlphaSlide.Name = "AlphaSlide"
			AlphaSlide.Size = UDim2.new(0,3,1,0)
			AlphaSlide.BackgroundColor3 = Color3.new(0,0,0)
			AlphaSlide.BackgroundTransparency = 0.4
			AlphaSlide.BorderColor3 = Color3.new(0,0,0)
			AlphaSlide.ZIndex = 100
			AlphaSlide.BorderSizePixel = 0

			Library:Connection(Icon.MouseEnter, function()
				Icon.BorderSizePixel = 1
			end)
			
			Library:Connection(Icon.MouseLeave, function()
				Icon.BorderSizePixel = 0
			end)

			
			local mouseover = false
			local hue, sat, val = default:ToHSV()
			local hsv = default:ToHSV()
			local alpha = defaultalpha
			local oldcolor = hsv
			local slidingsaturation = false
			local slidinghue = false
			local slidingalpha = false

			local function update()
				local real_pos         = game:GetService("UserInputService"):GetMouseLocation()
				local mouse_position   = Vector2.new(real_pos.X - 5, real_pos.Y - 30)
				local relative_palette = (mouse_position - Color.AbsolutePosition)
				local relative_hue     = (mouse_position - Hue.AbsolutePosition)
				local relative_opacity = (mouse_position - Alpha.AbsolutePosition)
				
				if slidingsaturation then
					sat = math.clamp(1 - relative_palette.X / Color.AbsoluteSize.X, 0, 1)
					val = math.clamp(1 - relative_palette.Y / Color.AbsoluteSize.Y, 0, 1)
				elseif slidinghue then
					hue = math.clamp(relative_hue.Y / Hue.AbsoluteSize.Y, 0, 1)
				elseif slidingalpha then
					alpha = math.clamp(relative_opacity.X / Alpha.AbsoluteSize.X, 0, 1)
				end

				hsv = Color3.fromHSV(hue, sat, val)
				Color.BackgroundColor3 = Color3.fromHSV(hue, 1, 1)
				Alpha.BackgroundColor3 = Color3.fromHSV(hue, 1, 1)
				HueSlide.BackgroundColor3 = Color3.fromHSV(hue, 1, 1)
				Icon.BackgroundColor3 = hsv

				HueSlide.Position = UDim2.new(0,0,math.clamp(hue, 0.005, 0.995),0)
				AlphaSlide.Position = UDim2.new(math.clamp(alpha, 0.000, 0.982),0,0,0)

				if flag then
					Library.Flags[flag] = {} 
					Library.Flags[flag]["Color"] = Color3.fromRGB(hsv.r * 255, hsv.g * 255, hsv.b * 255)
					Library.Flags[flag]["Transparency"] = alpha
				end

				callback(Color3.fromRGB(hsv.r * 255, hsv.g * 255, hsv.b * 255), alpha)
			end

			local function set(color, a)
				if type(color) == "table" then
					a = color[4]
					color = Color3.fromHSV(color[1], color[2], color[3])
				end
				if type(color) == "string" then
					color = Color3.fromHex(color)
				end

				local oldcolor = hsv
				local oldalpha = alpha

				hue, sat, val = color:ToHSV()
				alpha = a or 1
				hsv = Color3.fromHSV(hue, sat, val)

				if hsv ~= oldcolor then
					Icon.BackgroundColor3 = hsv
					Color.BackgroundColor3 = Color3.fromHSV(hue, 1, 1)
					Alpha.BackgroundColor3 = Color3.fromHSV(hue, 1, 1)
					HueSlide.BackgroundColor3 = Color3.fromHSV(hue, 1, 1)
					HueSlide.Position = UDim2.new(0,0,math.clamp(hue, 0.005, 0.995),0)
					AlphaSlide.Position = UDim2.new(math.clamp(alpha, 0.000, 0.982),0,0,0)

					if flag then
						Library.Flags[flag] = {} 
						Library.Flags[flag]["Color"] = Color3.fromRGB(hsv.r * 255, hsv.g * 255, hsv.b * 255)
						Library.Flags[flag]["Transparency"] = alpha
					end

					callback(Color3.fromRGB(hsv.r * 255, hsv.g * 255, hsv.b * 255), alpha)
				end
			end

			Flags[flag] = set

			set(default, defaultalpha)

			Sat.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					slidingsaturation = true
					update()
				end
			end)

			Sat.InputEnded:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					slidingsaturation = false
					update()
				end
			end)

			Hue.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					slidinghue = true
					update()
				end
			end)

			Hue.InputEnded:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					slidinghue = false
					update()
				end
			end)

			Alpha.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					slidingalpha = true
					update()
				end
			end)

			Alpha.InputEnded:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					slidingalpha = false
					update()
				end
			end)

			Library:Connection(game:GetService("UserInputService").InputChanged, function(input)
				if input.UserInputType == Enum.UserInputType.MouseMovement then
					if slidingalpha then
						update()
					end

					if slidinghue then
						update()
					end

					if slidingsaturation then
						update()
					end
				end
			end)

			local colorpickertypes = {}

			function colorpickertypes:Set(color, newalpha)
				set(color, newalpha)
			end

			Library:Connection(game:GetService("UserInputService").InputBegan, function(Input)
				if ColorWindow.Visible and Input.UserInputType == Enum.UserInputType.MouseButton1 then
					if not Library:IsMouseOverFrame(ColorWindow) and not Library:IsMouseOverFrame(Icon) then
						ColorWindow.Visible = false
						parent.ZIndex = 1
					end
				end
			end)

			Icon.MouseButton1Down:Connect(function()
				ColorWindow.Visible = true
				parent.ZIndex = 5

				if slidinghue then
					slidinghue = false
				end

				if slidingsaturation then
					slidingsaturation = false
				end

				if slidingalpha then
					slidingalpha = false
				end
			end)

			return colorpickertypes, ColorWindow, Icon
		end
	end

	function Library:NewInstance(Inst, Theme)
		local Obj = Instance.new(Inst)
		if Theme then
			table.insert(Library.ThemeObjects, Obj)
			if Obj:IsA("Frame") or Obj:IsA("TextButton") then
				Obj.BackgroundColor3 = Library.Accent;
				if Obj:IsA("ScrollingFrame") then
					Obj.ScrollBarImageColor3 = Library.Accent
				end
			elseif Obj:IsA("TextLabel") or Obj:IsA("TextBox") then
				Obj.TextColor3 = Library.Accent;
			elseif Obj:IsA("ImageLabel") or Obj:IsA("ImageButton") then
				Obj.ImageColor3 = Library.Accent;
			elseif Obj:IsA("UIStroke") then
				Obj.Color = Library.Accent;
			elseif Obj:IsA("ScrollingFrame") then
				Obj.ScrollBarImageColor3 = Library.Accent
			end;
		end;
		return Obj;
	end;

	do
		local Pages = Library.Pages;
		local Sections = Library.Sections;
		
		function Library:Window(Options)
			local Window = {
				Pages = {};
				Sections = {};
				Elements = {};
				Dragging = { false, UDim2.new(0, 0, 0, 0) };
			};
			
			local FentFun = Instance.new("ScreenGui", Path)
			FentFun.Name = "Eclipse"
			FentFun.DisplayOrder = 1000
			FentFun.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

			local ImageLabel = Instance.new("ImageLabel")
			ImageLabel.Name = "ImageLabel"
			ImageLabel.Image = "rbxassetid://121353311717943"
			ImageLabel.ImageColor3 = Color3.fromRGB(0, 0, 0)
			ImageLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			ImageLabel.BackgroundTransparency = 1
			ImageLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
			ImageLabel.BorderSizePixel = 0
			ImageLabel.Position = UDim2.new(0.1, 0, 0.1, 0)
			ImageLabel.Size = UDim2.new(0, 700, 0, 625)

			local MainFrame = Instance.new("TextButton")
			MainFrame.Name = "MainFrame"
			MainFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
			MainFrame.BorderColor3 = Color3.fromRGB(0, 0, 0)
			MainFrame.BorderSizePixel = 0
			MainFrame.Position = UDim2.new(0, 2, 0, 2)
			MainFrame.Size = UDim2.new(1, -4, 1, -4)
			MainFrame.ZIndex = 10
			MainFrame.Text = ""
			MainFrame.AutoButtonColor = false

			Library.Holder = ImageLabel
						
			local TopFrame = Instance.new("Frame")
			TopFrame.Name = "TopFrame"
			TopFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
			TopFrame.BorderColor3 = Color3.fromRGB(0, 0, 0)
			TopFrame.BorderSizePixel = 0
			TopFrame.Size = UDim2.new(1, 0, 0, 25)

			local Logo = Library:NewInstance("ImageLabel", true)
			Logo.Name = "Logo"
			Logo.Image = "rbxassetid://121353311717943"
			Logo.ScaleType = Enum.ScaleType.Fit
			Logo.AnchorPoint = Vector2.new(0, 0.5)
			Logo.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Logo.BackgroundTransparency = 1
			Logo.ImageColor3 = Library.Accent
			Logo.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Logo.BorderSizePixel = 0
			Logo.Position = UDim2.new(0, 5, 0.5, 0)
			Logo.Size = UDim2.new(0, 20, 0, 20)
			Logo.Parent = TopFrame

			TopFrame.Parent = MainFrame

			local Tabs = Instance.new("ScrollingFrame")
			Tabs.Name = "Tabs"
			Tabs.Size = UDim2.new(0, 80,1, -25)
			Tabs.BackgroundColor3 = Color3.new(1,1,1)
			Tabs.BackgroundTransparency = 1
			Tabs.BorderSizePixel = 0
			Tabs.BorderColor3 = Color3.new(0,0,0)
			Tabs.ScrollBarThickness = 2 
			Tabs.ScrollBarImageColor3 = Library.Accent
			Tabs.VerticalScrollBarPosition = Enum.VerticalScrollBarPosition.Left
			Tabs.CanvasSize = UDim2.new(0, 0, 1.15, 0)
			Tabs.Position = UDim2.new(0, 0, 0, 25)
			table.insert(Library.ThemeObjects, Tabs)

			local UIListLayout = Instance.new("UIListLayout")
			UIListLayout.Name = "UIListLayout"
			UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
			UIListLayout.Parent = Tabs

			Tabs.Parent = MainFrame

			MainFrame.Parent = ImageLabel

			local Holder = Instance.new("Frame")
			Holder.Name = "shadowHolder"
			Holder.BackgroundTransparency = 1
			Holder.Position = UDim2.new(0, -3, 0, -3)
			Holder.Size = UDim2.new(1, 6, 1, 6)
			Holder.ZIndex = 0

			local Shadow = Instance.new("ImageLabel")
			Shadow.Name = "umbraShadow"
			Shadow.Image = "rbxassetid://1316045217"
			Shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
			Shadow.ImageTransparency = 0.86
			Shadow.ScaleType = Enum.ScaleType.Slice
			Shadow.SliceCenter = Rect.new(10, 10, 118, 118)
			Shadow.AnchorPoint = Vector2.new(0.5, 0.5)
			Shadow.BackgroundTransparency = 1
			Shadow.Position = UDim2.new(0.5, 0, 0.5, 2)
			Shadow.Size = UDim2.new(1, 4, 1, 4)
			Shadow.ZIndex = 0
			Shadow.Parent = Holder

			local Shadow1 = Instance.new("ImageLabel")
			Shadow1.Name = "penumbraShadow"
			Shadow1.Image = "rbxassetid://1316045217"
			Shadow1.ImageColor3 = Color3.fromRGB(0, 0, 0)
			Shadow1.ImageTransparency = 0.88
			Shadow1.ScaleType = Enum.ScaleType.Slice
			Shadow1.SliceCenter = Rect.new(10, 10, 118, 118)
			Shadow1.AnchorPoint = Vector2.new(0.5, 0.5)
			Shadow1.BackgroundTransparency = 1
			Shadow1.Position = UDim2.new(0.5, 0, 0.5, 2)
			Shadow1.Size = UDim2.new(1, 4, 1, 4)
			Shadow1.ZIndex = 0
			Shadow1.Parent = Holder

			local Shadow2 = Instance.new("ImageLabel")
			Shadow2.Name = "ambientShadow"
			Shadow2.Image = "rbxassetid://1316045217"
			Shadow2.ImageColor3 = Color3.fromRGB(0, 0, 0)
			Shadow2.ImageTransparency = 0.49
			Shadow2.ScaleType = Enum.ScaleType.Slice
			Shadow2.SliceCenter = Rect.new(10, 10, 118, 118)
			Shadow2.AnchorPoint = Vector2.new(0.5, 0.5)
			Shadow2.BackgroundTransparency = 1
			Shadow2.Position = UDim2.new(0.5, 0, 0.5, 2)
			Shadow2.Size = UDim2.new(1, 4, 1, 4)
			Shadow2.ZIndex = 0
			Shadow2.Parent = Holder



			Holder.Parent = ImageLabel

			ImageLabel.Parent = FentFun

			Window.Elements = {
				TabHolder = Tabs,
				Holder = MainFrame,
			}

			Library:Connection(MainFrame.MouseButton1Down, function()
				local Location = game:GetService("UserInputService"):GetMouseLocation()
				Window.Dragging[1] = true
				Window.Dragging[2] = UDim2.new(0, Location.X - ImageLabel.AbsolutePosition.X, 0, Location.Y - ImageLabel.AbsolutePosition.Y)
			end)
			Library:Connection(game:GetService("UserInputService").InputEnded, function(Input)
				if Input.UserInputType == Enum.UserInputType.MouseButton1 and Window.Dragging[1] then
					local Location = game:GetService("UserInputService"):GetMouseLocation()
					Window.Dragging[1] = false
					Window.Dragging[2] = UDim2.new(0, 0, 0, 0)
				end
			end)
			Library:Connection(game:GetService("UserInputService").InputChanged, function(Input)
				local Location = game:GetService("UserInputService"):GetMouseLocation()
				local ActualLocation = nil

				if Window.Dragging[1] then
					
					ImageLabel.Position = UDim2.new(
						0,
						Location.X - Window.Dragging[2].X.Offset + (ImageLabel.Size.X.Offset * ImageLabel.AnchorPoint.X),
						0,
						Location.Y - Window.Dragging[2].Y.Offset + (ImageLabel.Size.Y.Offset * ImageLabel.AnchorPoint.Y)
					)

				end
			end)
            Library:Connection(game:GetService("UserInputService").InputBegan, function(Input)
                if Input.KeyCode == Library.UIKey and not UserInputService:GetFocusedTextBox() then
                    Library:Toggle(not Library.Open)

                end
            end)

			function Window:KeyList() 
				local NKeyList = {Keybinds = {}};
				Library.KeyList = NKeyList;
				
				local Background = Instance.new("Frame")
				local Gradient = Instance.new("Frame")
				local UIGradient = Library:NewInstance("UIGradient", true)
				local Name = Library:NewInstance("TextLabel", true)
				local Element = Instance.new("Frame")
				local Tab = Instance.new("Frame")
				local UIListLayout = Instance.new("UIListLayout")
				local Name_2 = Instance.new("TextLabel")
				
				Background.Name = "Background"
				Background.Parent = Keybinds
				Background.BackgroundColor3 = Color3.fromRGB(11, 11, 11)
				Background.BorderColor3 = Color3.fromRGB(25, 25, 25)
				Background.Position = UDim2.new(0.01, 0, 0.488, 0)
				Background.Size = UDim2.new(0, 180, 0, 24)
				Background.Visible = false
				Background.AutomaticSize = Enum.AutomaticSize.XY
				Background.Parent = FentFun

				Gradient.Name = "Gradient"
				Gradient.Parent = Background
				Gradient.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
				Gradient.BorderColor3 = Color3.fromRGB(0, 0, 0)
				Gradient.BorderSizePixel = 0
				Gradient.Position = UDim2.new(0, 0, 0, 1)
				Gradient.Size = UDim2.new(1,0, 0, 1)

				UIGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(0, 0, 0)), ColorSequenceKeypoint.new(0.50, Library.Accent), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(0, 0, 0))}
				UIGradient.Parent = Gradient

				Name.Name = "Name"
				Name.Parent = Background
				Name.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
				Name.BackgroundTransparency = 1.000
				Name.BorderColor3 = Color3.fromRGB(0, 0, 0)
				Name.BorderSizePixel = 0
				Name.Size = UDim2.new(1,0,0,24)
				Name.FontFace = menu_font
				Name.Text = "Keybinds"
				Name.TextColor3 = Color3.fromRGB(255, 255, 255)
				Name.TextSize = 12.000
				Name.RichText = true

				local KeybindTab = Name

				Element.Name = "Element"
				Element.Parent = Background
				Element.BackgroundColor3 = Color3.fromRGB(31, 31, 31)
				Element.BorderColor3 = Color3.fromRGB(0, 0, 0)
				Element.BorderSizePixel = 0
				Element.Position = UDim2.new(0, 0, 1, 0)
				Element.Size = UDim2.new(0, 140, 0, 1)

				Tab.Name = "Tab"
				Tab.Visible = true 
				Tab.Parent = Background
				Tab.BackgroundColor3 = Color3.fromRGB(11, 11, 11)
				Tab.BackgroundTransparency = 1.000
				Tab.BorderColor3 = Color3.fromRGB(25, 25, 25)
				Tab.Position = UDim2.new(0, 0, 0, 20)
				Tab.Size = UDim2.new(1, 0, 0, -20)
				Tab.AutomaticSize = Enum.AutomaticSize.Y

				UIListLayout.Parent = Tab
				UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
				UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
				UIListLayout.Padding = UDim.new(0,2)

				local dragging
				local dragInput
				local dragStart
				local startPos

				Background.InputBegan:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseButton1 then
						dragging = true
						dragStart = input.Position
						startPos = Background.Position

						input.Changed:Connect(function()
							if input.UserInputState == Enum.UserInputState.End then
								dragging = false
							end
						end)
					end
				end)

				Background.InputChanged:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseMovement then
						dragInput = input
					end
				end)

				game:GetService("UserInputService").InputChanged:Connect(function(input)
					if input == dragInput and dragging then
						local delta = input.Position - dragStart
						Background.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
					end
				end)

				
				function NKeyList:SetVisible(State)
					Background.Visible = State;
				end;
				
				function NKeyList:NewKey(Key, Name, Mode)
					local KeyValue = {}
					
					local KName = Library:NewInstance("TextLabel", true)
					 
					KName.Name = "Name"
					KName.Parent = Tab
					KName.AnchorPoint = Vector2.new(0.5, 0.5)
					KName.BackgroundColor3 = Color3.fromRGB(11, 11, 11)
					KName.BorderColor3 = Color3.fromRGB(25,25,25)
					KName.BorderSizePixel = 0
					KName.Position = UDim2.new(0.5, 0, -1.85000002, 0)
					KName.Size = UDim2.new(0, 0, 0, 0)
					KName.FontFace = menu_font
					KName.Text = "Failed to update text..."
					KName.TextColor3 = Library.Accent
					KName.TextSize = 12.000
					KName.RichText = true
					KName.AutomaticSize = Enum.AutomaticSize.XY
					
					function KeyValue:SetVisible(State)
						KName.Visible = State;
					end;
					
					function KeyValue:Update(NKey, NewName, NewMode)
						KName.Text = string.format('<font color="rgb(200,200,200)">%s: [%s] </font><font color="rgb(145,145,145)">(%s)</font>', NewName, tostring(NKey), tostring(string.lower(NewMode)))
					end;
					return KeyValue
				end;
				return NKeyList
			end
			Window:KeyList()

			
			function Window:UpdateTabs()
				for Index, Page in pairs(Window.Pages) do
					Page:Turn(Page.Open)
				end
			end

			Library.Holder = ImageLabel
			return setmetatable(Window, Library)
		end;
		
		function Library:Page(Properties)
			if not Properties then
				Properties = {}
			end
			
			local Page = {
				Name = Properties.Name or Properties.name or "Page",
				Icon = Properties.Icon or "rbxassetid://121353311717943",
				Window = self,
				Open = false,
				Sections = {},
				Pages = {},
				Elements = {},
			}
			
			local NewTab = Instance.new("TextButton")
			NewTab.Name = "NewTab"
			NewTab.FontFace = menu_font
			NewTab.Text = ""
			NewTab.TextColor3 = Color3.fromRGB(0, 0, 0)
			NewTab.TextSize = 7
			NewTab.AutoButtonColor = false
			NewTab.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			NewTab.BackgroundTransparency = 1
			NewTab.BorderColor3 = Color3.fromRGB(0, 0, 0)
			NewTab.BorderSizePixel = 0
			NewTab.Size = UDim2.new(1, 0, 0, 70)
			NewTab.Parent = Page.Window.Elements.TabHolder

			local AccentLine = Library:NewInstance("Frame", true)
			AccentLine.Name = "AccentLine"
			AccentLine.BackgroundColor3 = Library.Accent
			AccentLine.BorderColor3 = Color3.fromRGB(0, 0, 0)
			AccentLine.BorderSizePixel = 0
			AccentLine.Size = UDim2.new(0, 2, 1, 0)
			AccentLine.Visible = true
			AccentLine.BackgroundTransparency = 1
			AccentLine.Parent = NewTab

			local Name = Instance.new("TextLabel")
			Name.Name = "Name"
			Name.FontFace = menu_font
			Name.Text = Page.Name
			Name.TextColor3 = Color3.fromRGB(200, 200, 200)
			Name.TextSize = Library.FSize
			Name.TextStrokeTransparency = 0
			Name.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Name.BackgroundTransparency = 1
			Name.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Name.BorderSizePixel = 0
			Name.Position = UDim2.new(0, 0, 1, -22)
			Name.Size = UDim2.new(1, 0, 0, 10)
			Name.Parent = NewTab

			local ImageLabel = Instance.new("ImageLabel")
			ImageLabel.Name = "ImageLabel"
			ImageLabel.Image = Page.Icon
			ImageLabel.ScaleType = Enum.ScaleType.Fit
			ImageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
			ImageLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			ImageLabel.BackgroundTransparency = 1
			ImageLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
			ImageLabel.BorderSizePixel = 0
			ImageLabel.ImageColor3 = Color3.fromRGB(200, 200, 200)
			ImageLabel.Position = UDim2.new(0.5, 0, 0.5, -6)
			ImageLabel.Size = UDim2.new(0, 25, 0, 25)
			ImageLabel.Parent = NewTab

			local NewPage = Instance.new("Frame")
			NewPage.Name = "NewPage"
			NewPage.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			NewPage.BackgroundTransparency = 1
			NewPage.BorderColor3 = Color3.fromRGB(0, 0, 0)
			NewPage.BorderSizePixel = 0
			NewPage.Position = UDim2.new(0, 91, 0, 35)
			NewPage.Size = UDim2.new(1, -100, 1, -40)
			NewPage.Visible = false
			NewPage.Parent = Page.Window.Elements.Holder

			local Left = Instance.new("Frame")
			Left.Name = "Left"
			Left.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Left.BackgroundTransparency = 1
			Left.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Left.BorderSizePixel = 0
			Left.Size = UDim2.new(0.5, -5, 1, 0)

			local UIListLayout = Instance.new("UIListLayout")
			UIListLayout.Name = "UIListLayout"
			UIListLayout.Padding = UDim.new(0, 8)
			UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
			UIListLayout.Parent = Left

			Left.Parent = NewPage

			local Right = Instance.new("Frame")
			Right.Name = "Right"
			Right.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Right.BackgroundTransparency = 1
			Right.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Right.BorderSizePixel = 0
			Right.Position = UDim2.new(0.5, 5, 0, 0)
			Right.Size = UDim2.new(0.5, -5, 1, 0)

			local UIListLayout1 = Instance.new("UIListLayout")
			UIListLayout1.Name = "UIListLayout"
			UIListLayout1.Padding = UDim.new(0, 8)
			UIListLayout1.SortOrder = Enum.SortOrder.LayoutOrder
			UIListLayout1.Parent = Right

			Right.Parent = NewPage

			function Page:Turn(bool)
				Page.Open = bool
				NewPage.Visible = Page.Open
				TweenService:Create(AccentLine, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = Page.Open and 0 or 1}):Play()
				TweenService:Create(NewTab, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = Page.Open and 0.95 or 1}):Play()
			end
			
			Library:Connection(NewTab.MouseButton1Down, function()
				if not Page.Open then
					for _, Pages in pairs(Page.Window.Pages) do
						if Pages.Open and Pages ~= Page then
							Pages:Turn(false)
						end
					end
					Page:Turn(true)
				end
			end)

			
			Page.Elements = {
				Left = Left,
				Right = Right,
				Main = NewPage,
			}

			
			if #Page.Window.Pages == 0 then
				Page:Turn(true)
			end
			Page.Window.Pages[#Page.Window.Pages + 1] = Page
			Page.Window:UpdateTabs()
			return setmetatable(Page, Library.Pages)
		end
		
		function Pages:Section(Properties)
			if not Properties then
				Properties = {}
			end
			
			local Section = {
				Name = Properties.Name or "Section",
				Page = self,
				Side = (Properties.side or Properties.Side or "left"):lower(),
				Zindex = (Properties.Zindex or Properties.zindex or 1),
				Elements = {},
				Content = {},
				Sections = {},
			}
			
			local NewSection = Instance.new("Frame")
			NewSection.Name = "NewSection"
			NewSection.AutomaticSize = Enum.AutomaticSize.Y
			NewSection.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
			NewSection.BorderColor3 = Color3.fromRGB(30, 30, 30)
			NewSection.Size = UDim2.new(1, 0, 0, 50)
			NewSection.ZIndex = Section.Zindex
			NewSection.Parent = Section.Side == "left" and Section.Page.Elements.Left or Section.Side == "right" and Section.Page.Elements.Right

			local SectionTop = Instance.new("Frame")
			SectionTop.Name = "SectionTop"
			SectionTop.BackgroundColor3 = Color3.fromRGB(27, 27, 27)
			SectionTop.BorderColor3 = Color3.fromRGB(0, 0, 0)
			SectionTop.BorderSizePixel = 0
			SectionTop.Size = UDim2.new(1, 0, 0, 20)

			local SectionName = Instance.new("TextLabel")
			SectionName.Name = "SectionName"
			SectionName.FontFace = menu_font
			SectionName.Text = Section.Name
			SectionName.TextColor3 = Color3.fromRGB(200, 200, 200)
			SectionName.TextSize = Library.FSize
			SectionName.TextStrokeTransparency = 0
			SectionName.TextXAlignment = Enum.TextXAlignment.Left
			SectionName.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			SectionName.BackgroundTransparency = 1
			SectionName.BorderColor3 = Color3.fromRGB(0, 0, 0)
			SectionName.BorderSizePixel = 0
			SectionName.Position = UDim2.new(0, 5, 0, 0)
			SectionName.Size = UDim2.new(1, 0, 1, 0)
			SectionName.Parent = SectionTop

			SectionTop.Parent = NewSection

			local SectionContent = Instance.new("Frame")
			SectionContent.Name = "SectionContent"
			SectionContent.AutomaticSize = Enum.AutomaticSize.Y
			SectionContent.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			SectionContent.BackgroundTransparency = 1
			SectionContent.BorderColor3 = Color3.fromRGB(0, 0, 0)
			SectionContent.BorderSizePixel = 0
			SectionContent.Position = UDim2.new(0, 10, 0, 25)
			SectionContent.Size = UDim2.new(1, -20, 0, 0)

			local UIListLayout = Instance.new("UIListLayout")
			UIListLayout.Name = "UIListLayout"
			UIListLayout.Padding = UDim.new(0, 10)
			UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
			UIListLayout.Parent = SectionContent

			local UIPadding = Instance.new("UIPadding")
			UIPadding.Name = "UIPadding"
			UIPadding.PaddingBottom = UDim.new(0, 8)
			UIPadding.PaddingTop = UDim.new(0, 5)
			UIPadding.Parent = SectionContent

			SectionContent.Parent = NewSection

			
			Section.Elements = {
				SectionContent = SectionContent;
			}

			
			Section.Page.Sections[#Section.Page.Sections + 1] = Section
			return setmetatable(Section, Library.Sections)
		end
		
		function Pages:MultiSection(Properties)
			if not Properties then
				Properties = {}
			end
			
			local Section = {
				Sections = (Properties.sections or Properties.Sections or {}),
				Page = self,
				Side = (Properties.side or Properties.Side or "left"):lower(),
				Zindex = (Properties.Zindex or Properties.zindex or 1),
				Elements = {},
				Content = {},
				ActualSections = {};
			}
			
			local NewSection = Instance.new("Frame")
			NewSection.Name = "NewSection"
			NewSection.AutomaticSize = Enum.AutomaticSize.Y
			NewSection.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
			NewSection.BorderColor3 = Color3.fromRGB(30, 30, 30)
			NewSection.Size = UDim2.new(1, 0, 0, 50)
			NewSection.ZIndex = Section.Zindex
			NewSection.Parent = Section.Side == "left" and Section.Page.Elements.Left or Section.Side == "right" and Section.Page.Elements.Right

			local SectionTop = Instance.new("Frame")
			SectionTop.Name = "SectionTop"
			SectionTop.BackgroundColor3 = Color3.fromRGB(27, 27, 27)
			SectionTop.BorderColor3 = Color3.fromRGB(0, 0, 0)
			SectionTop.BorderSizePixel = 0
			SectionTop.Size = UDim2.new(1, 0, 0, 20)

			local UIListLayout = Instance.new("UIListLayout")
			UIListLayout.Name = "UIListLayout"
			UIListLayout.FillDirection = Enum.FillDirection.Horizontal
			UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
			UIListLayout.Parent = SectionTop

			SectionTop.Parent = NewSection

			
			Section.Elements = {
				Top = SectionTop;
			}
			local SectionShit = Section.Sections;
			local SectionShit2 = Section;
			local SectionButtons = {};


			for I, V in next, SectionShit do
				local MultiSection = {
					Window = self.Window,
					Page = self.Page,
					Section = self,
					Open = false,
					Content = {},
					NoUpdate = true,
					ContentAxis = 0;
					Elements = {};
				};

				
				local SectionName = Instance.new("TextButton")
				SectionName.Name = "SectionName"
				SectionName.FontFace = menu_font
				SectionName.Text = V
				SectionName.TextColor3 = Color3.fromRGB(200, 200, 200)
				SectionName.TextSize = Library.FSize
				SectionName.TextStrokeTransparency = 0
				SectionName.TextXAlignment = Enum.TextXAlignment.Center
				SectionName.BackgroundColor3 = Color3.fromRGB(20,20,20)
				SectionName.BackgroundTransparency = 0
				SectionName.BorderColor3 = Color3.fromRGB(30, 30, 30)
				SectionName.BorderSizePixel = 1
				SectionName.Position = UDim2.new(0, 5, 0, 0)
				SectionName.Size = UDim2.new(1, 0, 1, -2)
				SectionName.Parent = SectionTop
				SectionName.AutoButtonColor = false

				local SectionContent = Instance.new("Frame")
				SectionContent.Name = "SectionContent"
				SectionContent.AutomaticSize = Enum.AutomaticSize.Y
				SectionContent.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
				SectionContent.BackgroundTransparency = 1
				SectionContent.BorderColor3 = Color3.fromRGB(0, 0, 0)
				SectionContent.BorderSizePixel = 0
				SectionContent.Position = UDim2.new(0, 10, 0, 25)
				SectionContent.Size = UDim2.new(1, -20, 0, 0)
				SectionContent.Visible = false

				local UIListLayout = Instance.new("UIListLayout")
				UIListLayout.Name = "UIListLayout"
				UIListLayout.Padding = UDim.new(0, 10)
				UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
				UIListLayout.Parent = SectionContent

				local UIPadding = Instance.new("UIPadding")
				UIPadding.Name = "UIPadding"
				UIPadding.PaddingBottom = UDim.new(0, 8)
				UIPadding.PaddingTop = UDim.new(0, 5)
				UIPadding.Parent = SectionContent

				SectionContent.Parent = NewSection

				table.insert(SectionButtons, SectionName)

				for Index, RSection in next, SectionButtons do
					RSection.Size = UDim2.new(1 / #SectionButtons, 0, 1, 0)
				end;

				function MultiSection:Turn(bool)
					MultiSection.Open = bool
					TweenService:Create(SectionName, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundColor3 = MultiSection.Open and Color3.fromRGB(27, 27, 27) or Color3.fromRGB(20,20,20)}):Play()
					SectionContent.Visible = MultiSection.Open
				end;

				Library:Connection(SectionName.MouseButton1Click, function()
					if not MultiSection.Open then
						MultiSection:Turn(true)
						for index, other_page in pairs(SectionShit2.ActualSections) do
							if other_page.Open and other_page ~= MultiSection then
								other_page:Turn(false)
							end
						end
					end
				end)

				if #SectionShit == 0 then
					MultiSection:Turn(true);
				end;

				
				MultiSection.Elements = {
					Title = SectionName;
					SectionContent = SectionContent;
				};

				
				SectionShit2.ActualSections[#SectionShit2.ActualSections + 1] = setmetatable(MultiSection, Library.Sections)
			end;

			
			Section.Page.Sections[#Section.Page.Sections + 1] = Section;
			Section.ActualSections[1]:Turn(true)
			return table.unpack(Section.ActualSections)
		end
		
		function Sections:Toggle(Properties)
			if not Properties then
				Properties = {}
			end
			
			local Toggle = {
				Window = self.Window,
				Page = self.Page,
				Section = self,
				Risk = Properties.Risk or false,
				Name = Properties.Name or "Toggle",
				State = (
					Properties.state
						or Properties.State
						or Properties.def
						or Properties.Def
						or Properties.default
						or Properties.Default
						or false
				),
				Callback = (
					Properties.callback
						or Properties.Callback
						or Properties.callBack
						or Properties.CallBack
						or function() end
				),
				Flag = (
					Properties.flag
						or Properties.Flag
						or Properties.pointer
						or Properties.Pointer
						or Library.NextFlag()
				),
				Toggled = false,
				Colorpickers = 0,
			}
			
			local NewToggle = Instance.new("TextButton")
			NewToggle.Name = "NewToggle"
			NewToggle.FontFace = menu_font
			NewToggle.Text = ""
			NewToggle.TextColor3 = Color3.fromRGB(0, 0, 0)
			NewToggle.TextSize = 7
			NewToggle.AutoButtonColor = false
			NewToggle.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			NewToggle.BackgroundTransparency = 1
			NewToggle.BorderColor3 = Color3.fromRGB(0, 0, 0)
			NewToggle.BorderSizePixel = 0
			NewToggle.Size = UDim2.new(1, 0, 0, 10)
			NewToggle.Parent = Toggle.Section.Elements.SectionContent

			local Frame = Instance.new("Frame")
			Frame.Name = "Frame"
			Frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
			Frame.BorderColor3 = Color3.fromRGB(30, 30, 30)
			Frame.BorderSizePixel = 0
			Frame.Size = UDim2.new(0, 10, 0, 10)

			local UIStroke = Instance.new("UIStroke")
			UIStroke.Name = "UIStroke"
			UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			UIStroke.Color = Color3.fromRGB(30, 30, 30)
			UIStroke.LineJoinMode = Enum.LineJoinMode.Miter
			UIStroke.Parent = Frame

			local Accent = Library:NewInstance("Frame", true)
			Accent.Name = "Accent"
			Accent.BackgroundColor3 = Library.Accent
			Accent.BackgroundTransparency = 1
			Accent.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Accent.BorderSizePixel = 0
			Accent.Size = UDim2.new(1, -2, 1, -2)
			Accent.Position = UDim2.new(0,1,0,1)

			local UIGradient = Instance.new("UIGradient")
			UIGradient.Name = "UIGradient"
			UIGradient.Color = ColorSequence.new({
				ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(120, 120, 120)),
			})
			UIGradient.Rotation = 90
			UIGradient.Parent = Accent

			local UIGradient2 = Instance.new("UIGradient")
			UIGradient2.Name = "UIGradient"
			UIGradient2.Color = ColorSequence.new({
				ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(120, 120, 120)),
			})
			UIGradient2.Rotation = 90
			UIGradient2.Parent = Frame

			Accent.Parent = Frame

			Frame.Parent = NewToggle

			local Title = Library:NewInstance("TextLabel", Toggle.Risk)
			Title.Name = "Title"
			Title.FontFace = menu_font
			Title.Text = Toggle.Name
			Title.TextColor3 = Toggle.Risk and Library.Accent or Color3.fromRGB(200, 200, 200)
			Title.TextSize = Library.FSize
			Title.TextStrokeTransparency = 0
			Title.TextXAlignment = Enum.TextXAlignment.Left
			Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Title.BackgroundTransparency = 1
			Title.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Title.BorderSizePixel = 0
			Title.Position = UDim2.new(0, 18, 0, 0)
			Title.Size = UDim2.new(1, 0, 1, 0)
			Title.Parent = NewToggle

			
			local function SetState()
				Toggle.Toggled = not Toggle.Toggled
				TweenService:Create(Accent, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = Toggle.Toggled and 0 or 1}):Play()
				Library.Flags[Toggle.Flag] = Toggle.Toggled
				Toggle.Callback(Toggle.Toggled)
			end
			
			Library:Connection(NewToggle.MouseButton1Down, SetState)

			function Toggle:Keybind(Properties)
				local Properties = Properties or {}
				local Keybind = {
					Section = self,
					Name = Properties.name or Properties.Name or "Keybind",
					State = (
						Properties.state
							or Properties.State
							or Properties.def
							or Properties.Def
							or Properties.default
							or Properties.Default
							or nil
					),
					Mode = (Properties.mode or Properties.Mode or "Toggle"),
					UseKey = (Properties.UseKey or false),
					Ignore = (Properties.ignore or Properties.Ignore or false),
					Callback = (
						Properties.callback
							or Properties.Callback
							or Properties.callBack
							or Properties.CallBack
							or function() end
					),
					Flag = (
						Properties.flag
							or Properties.Flag
							or Properties.pointer
							or Properties.Pointer
							or Library.NextFlag()
					),
					Binding = nil,
				}
				local Key
				local State = false
				

				local ModeBox = Instance.new("Frame")
				local Hold = Instance.new("TextButton")
				local Toggle = Instance.new("TextButton")
				local Always = Instance.new("TextButton")
				local ListValue = Library.KeyList:NewKey(Keybind.State, Keybind.Name, Keybind.Mode)
				
				local Icon = Instance.new("TextButton")
				Icon.Name = "Icon"
				Icon.AnchorPoint = Vector2.new(0, 0.5)
				Icon.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
				Icon.BorderColor3 = Color3.fromRGB(30, 30, 30)
				Icon.BorderSizePixel = 0
				Icon.Position = UDim2.new(1, -30, 0.5, 0)
				Icon.Size = UDim2.new(0, 30, 0, 14)
				Icon.Text = ""
				Icon.AutoButtonColor = false

				local UIGradient3 = Instance.new("UIGradient")
				UIGradient3.Name = "UIGradient"
				UIGradient3.Color = ColorSequence.new({
					ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
					ColorSequenceKeypoint.new(1, Color3.fromRGB(120, 120, 120)),
				})
				UIGradient3.Rotation = 90
				UIGradient3.Parent = Icon

				local UIStroke2 = Instance.new("UIStroke")
				UIStroke2.Name = "UIStroke"
				UIStroke2.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
				UIStroke2.Color = Color3.fromRGB(30, 30, 30)
				UIStroke2.LineJoinMode = Enum.LineJoinMode.Miter
				UIStroke2.Parent = Icon

				local Value = Instance.new("TextLabel")
				Value.Name = "Value"
				Value.FontFace = menu_font
				Value.Text = "MB2"
				Value.TextColor3 = Color3.fromRGB(200, 200, 200)
				Value.TextSize = Library.FSize
				Value.TextStrokeTransparency = 0
				Value.TextWrapped = true
				Value.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
				Value.BackgroundTransparency = 1
				Value.BorderColor3 = Color3.fromRGB(0, 0, 0)
				Value.BorderSizePixel = 0
				Value.Size = UDim2.new(1, 0, 1, 0)
				Value.Parent = Icon

				Icon.Parent = NewToggle

				ModeBox.Name = "ModeBox"
				ModeBox.Parent = Icon
				ModeBox.AnchorPoint = Vector2.new(0,0.5)
				ModeBox.BackgroundColor3 = Color3.fromRGB(20,20,20)
				ModeBox.BorderColor3 = Color3.fromRGB(30,30,30)
				ModeBox.BorderSizePixel = 1
				ModeBox.Size = UDim2.new(0, 65, 0, 60)
				ModeBox.Position = UDim2.new(0,40,0.5,0)
				ModeBox.Visible = false

				Hold.Name = "Hold"
				Hold.Parent = ModeBox
				Hold.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
				Hold.BackgroundTransparency = 1.000
				Hold.BorderColor3 = Color3.fromRGB(0, 0, 0)
				Hold.BorderSizePixel = 0
				Hold.Size = UDim2.new(1, 0, 0.2933000004, 0)
				Hold.ZIndex = 2
				Hold.FontFace = menu_font
				Hold.Text = "Hold"
				Hold.TextColor3 = Keybind.Mode == "Hold" and Color3.fromRGB(200,200,200) or Color3.fromRGB(145,145,145)
				Hold.TextSize = Library.FSize
				Hold.TextStrokeTransparency = 0

				Toggle.Name = "Toggle"
				Toggle.Parent = ModeBox
				Toggle.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
				Toggle.BackgroundTransparency = 1.000
				Toggle.BorderColor3 = Color3.fromRGB(0, 0, 0)
				Toggle.BorderSizePixel = 0
				Toggle.Position = UDim2.new(0, 0, 0.2933000004, 0)
				Toggle.Size = UDim2.new(1, 0, 0.2933000004, 0)
				Toggle.ZIndex = 2
				Toggle.FontFace = menu_font
				Toggle.Text = "Toggle"
				Toggle.TextColor3 = Keybind.Mode == "Toggle" and Color3.fromRGB(200,200,200) or Color3.fromRGB(145,145,145)
				Toggle.TextSize = Library.FSize
				Toggle.TextStrokeTransparency = 0

				Always.Name = "Always"
				Always.Parent = ModeBox
				Always.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
				Always.BackgroundTransparency = 1.000
				Always.BorderColor3 = Color3.fromRGB(0, 0, 0)
				Always.BorderSizePixel = 0
				Always.Position = UDim2.new(0, 0, 0.666999996, 0)
				Always.Size = UDim2.new(1, 0, 0.2933000004, 0)
				Always.ZIndex = 2
				Always.FontFace = menu_font
				Always.Text = "Always"
				Always.TextColor3 = Keybind.Mode == "Always" and Color3.fromRGB(200,200,200) or Color3.fromRGB(145,145,145)
				Always.TextSize = Library.FSize
				Always.TextStrokeTransparency = 0

				
				local function set(newkey)
					if string.find(tostring(newkey), "Enum") then
						if c then
							c:Disconnect()
							if Keybind.Flag then
								Library.Flags[Keybind.Flag] = false
							end
							Keybind.Callback(false)
						end
						if tostring(newkey):find("Enum.KeyCode.") then
							newkey = Enum.KeyCode[tostring(newkey):gsub("Enum.KeyCode.", "")]
						elseif tostring(newkey):find("Enum.UserInputType.") then
							newkey = Enum.UserInputType[tostring(newkey):gsub("Enum.UserInputType.", "")]
						end
						if newkey == Enum.KeyCode.Backspace then
							Key = nil
							if Keybind.UseKey then
								if Keybind.Flag then
									Library.Flags[Keybind.Flag] = Key
								end
								Keybind.Callback(Key)
							end
							local text = "None"

							Value.Text = text
							ListValue:Update(text, Keybind.Name, Keybind.Mode)
						elseif newkey ~= nil then
							Key = newkey
							if Keybind.UseKey then
								if Keybind.Flag then
									Library.Flags[Keybind.Flag] = Key
								end
								Keybind.Callback(Key)
							end
							local text = (Library.Keys[newkey] or tostring(newkey):gsub("Enum.KeyCode.", ""))

							Value.Text = text
							ListValue:Update(text, Keybind.Name, Keybind.Mode)
						end

						Library.Flags[Keybind.Flag .. "_KEY"] = newkey
					elseif table.find({ "Always", "Toggle", "Hold" }, newkey) then
						if not Keybind.UseKey then
							Library.Flags[Keybind.Flag .. "_KEY STATE"] = newkey
							Keybind.Mode = newkey
							ListValue:Update((Library.Keys[Key] or tostring(Key):gsub("Enum.KeyCode.", "")), Keybind.Name, Keybind.Mode)
							if Keybind.Mode == "Always" then
								State = true
								if Keybind.Flag then
									Library.Flags[Keybind.Flag] = State
								end
								Keybind.Callback(true)
								ListValue:SetVisible(true)
							end
						end
					else
						State = newkey
						if Keybind.Flag then
							Library.Flags[Keybind.Flag] = newkey
						end
						Keybind.Callback(newkey)
					end
				end
				
				set(Keybind.State)
				set(Keybind.Mode)
				Icon.MouseButton1Click:Connect(function()
					if not Keybind.Binding then

						Value.Text = "..."

						Keybind.Binding = Library:Connection(
							game:GetService("UserInputService").InputBegan,
							function(input, gpe)
								set(
									input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode
										or input.UserInputType
								)
								Library:Disconnect(Keybind.Binding)
								task.wait()
								Keybind.Binding = nil
							end
						)
					end
				end)
				
				Library:Connection(game:GetService("UserInputService").InputBegan, function(inp)
					if (inp.KeyCode == Key or inp.UserInputType == Key) and not Keybind.Binding and not Keybind.UseKey then
						if Keybind.Mode == "Hold" then
							if Keybind.Flag then
								Library.Flags[Keybind.Flag] = true
							end
							c = Library:Connection(game:GetService("RunService").RenderStepped, function()
								if Keybind.Callback then
									Keybind.Callback(true)
								end
							end)
							ListValue:SetVisible(true)
						elseif Keybind.Mode == "Toggle" then
							State = not State
							if Keybind.Flag then
								Library.Flags[Keybind.Flag] = State
							end
							Keybind.Callback(State)
							ListValue:SetVisible(State)
						end
					end
				end)
				
				Library:Connection(game:GetService("UserInputService").InputEnded, function(inp)
					if Keybind.Mode == "Hold" and not Keybind.UseKey then
						if Key ~= "" or Key ~= nil then
							if inp.KeyCode == Key or inp.UserInputType == Key then
								if c then
									c:Disconnect()
									if Keybind.Flag then
										Library.Flags[Keybind.Flag] = false
									end
									if Keybind.Callback then
										Keybind.Callback(false)
									end
									ListValue:SetVisible(false)
								end
							end
						end
					end
				end)
				
				Library:Connection(Icon.MouseButton2Down, function()
					ModeBox.Visible = true
					NewToggle.ZIndex = 5
				end)
				
				Library:Connection(Hold.MouseButton1Down, function()
					set("Hold")
					Hold.TextColor3 = Color3.fromRGB(200,200,200)
					Toggle.TextColor3 = Color3.fromRGB(145,145,145)
					Always.TextColor3 = Color3.fromRGB(145,145,145)
					ModeBox.Visible = false
					NewToggle.ZIndex = 1
				end)
				
				Library:Connection(Toggle.MouseButton1Down, function()
					set("Toggle")
					Hold.TextColor3 = Color3.fromRGB(145,145,145)
					Toggle.TextColor3 = Color3.fromRGB(200,200,200)
					Always.TextColor3 = Color3.fromRGB(145,145,145)
					ModeBox.Visible = false
					NewToggle.ZIndex = 1
				end)
				
				Library:Connection(Always.MouseButton1Down, function()
					set("Always")
					Hold.TextColor3 = Color3.fromRGB(145,145,145)
					Toggle.TextColor3 = Color3.fromRGB(145,145,145)
					Always.TextColor3 = Color3.fromRGB(200,200,200)
					ModeBox.Visible = false
					NewToggle.ZIndex = 1
				end)
				
				Library:Connection(game:GetService("UserInputService").InputBegan, function(Input)
					if ModeBox.Visible and Input.UserInputType == Enum.UserInputType.MouseButton1 then
						if not Library:IsMouseOverFrame(ModeBox) then
							ModeBox.Visible = false
							NewToggle.ZIndex = 1
						end
					end
				end)
				
				Library.Flags[Keybind.Flag .. "_KEY"] = Keybind.State
				Library.Flags[Keybind.Flag .. "_KEY STATE"] = Keybind.Mode
				Flags[Keybind.Flag] = set
				Flags[Keybind.Flag .. "_KEY"] = set
				Flags[Keybind.Flag .. "_KEY STATE"] = set
				
				function Keybind:Set(key)
					set(key)
				end

				
				return Keybind
			end

			function Toggle:Colorpicker(Properties)
				local Properties = Properties or {}
				local Colorpicker = {
					State = (
						Properties.state
							or Properties.State
							or Properties.def
							or Properties.Def
							or Properties.default
							or Properties.Default
							or Color3.fromRGB(255, 0, 0)
					),
					Alpha = (
						Properties.alpha
							or Properties.Alpha
							or Properties.transparency
							or Properties.Transparency
							or 1
					),
					Callback = (
						Properties.callback
							or Properties.Callback
							or Properties.callBack
							or Properties.CallBack
							or function() end
					),
					Flag = (
						Properties.flag
							or Properties.Flag
							or Properties.pointer
							or Properties.Pointer
							or Library.NextFlag()
					),
				}
				
				Toggle.Colorpickers = Toggle.Colorpickers + 1
				local colorpickertypes, ColorWindow, Icon = Library:NewPicker(
					"",
					Colorpicker.State,
					Colorpicker.Alpha,
					NewToggle,
					Toggle.Colorpickers,
					Colorpicker.Flag,
					Colorpicker.Callback
				)

				function Colorpicker:Set(color)
					colorpickertypes:set(color)
				end

				function Colorpicker:SetVisible(Bool) 
					Icon.Visible = Bool
				end 

				
				return Colorpicker
			end

			function Toggle.Set(bool)
				bool = type(bool) == "boolean" and bool or false
				if Toggle.Toggled ~= bool then
					SetState()
				end
			end
			 
			function Toggle.SetVisible(bool) 
				NewToggle.Visible = bool
			end 

			Toggle.Set(Toggle.State)
			Library.Flags[Toggle.Flag] = Toggle.State
			Flags[Toggle.Flag] = Toggle.Set

			
			return Toggle
		end
		
		function Sections:Slider(Properties)
			if not Properties then
				Properties = {}
			end
			
			local Slider = {
				Window = self.Window,
				Page = self.Page,
				Section = self,
				Name = Properties.Name or nil,
				Min = (Properties.min or Properties.Min or Properties.minimum or Properties.Minimum or 0),
				State = (
					Properties.state
						or Properties.State
						or Properties.def
						or Properties.Def
						or Properties.default
						or Properties.Default
						or 10
				),
				Max = (Properties.max or Properties.Max or Properties.maximum or Properties.Maximum or 100),
				Sub = (
					Properties.suffix
						or Properties.Suffix
						or Properties.ending
						or Properties.Ending
						or Properties.prefix
						or Properties.Prefix
						or Properties.measurement
						or Properties.Measurement
						or ""
				),
				Decimals = (Properties.decimals or Properties.Decimals or 1),
				Callback = (
					Properties.callback
						or Properties.Callback
						or Properties.callBack
						or Properties.CallBack
						or function() end
				),
				Flag = (
					Properties.flag
						or Properties.Flag
						or Properties.pointer
						or Properties.Pointer
						or Library.NextFlag()
				),
				Disabled = (Properties.Disabled or Properties.disable or nil),
			}
			 
			local TextValue = ("[value]" .. Slider.Sub)
			
			local NewSlider = Instance.new("TextButton")
			NewSlider.Name = "NewSlider"
			NewSlider.FontFace = menu_font
			NewSlider.Text = ""
			NewSlider.TextColor3 = Color3.fromRGB(0, 0, 0)
			NewSlider.TextSize = 7
			NewSlider.AutoButtonColor = false
			NewSlider.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			NewSlider.BackgroundTransparency = 1
			NewSlider.BorderColor3 = Color3.fromRGB(0, 0, 0)
			NewSlider.BorderSizePixel = 0
			NewSlider.Size = UDim2.new(1, 0, 0, 28)
			NewSlider.Parent = Slider.Section.Elements.SectionContent

			local Frame = Instance.new("TextButton")
			Frame.Name = "Frame"
			Frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
			Frame.BorderColor3 = Color3.fromRGB(30, 30, 30)
			Frame.BorderSizePixel = 0
			Frame.Position = UDim2.new(0, 0, 1, -10)
			Frame.Size = UDim2.new(1, 0, 0, 10)
			Frame.AutoButtonColor = false
			Frame.Text = ""

			function Slider:SetVisible(Bool)
				NewSlider.Visible = Bool
			end 

			local UIGradient3 = Instance.new("UIGradient")
			UIGradient3.Name = "UIGradient"
			UIGradient3.Color = ColorSequence.new({
				ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(120, 120, 120)),
			})
			UIGradient3.Rotation = 90
			UIGradient3.Parent = Frame

			local UIStroke = Instance.new("UIStroke")
			UIStroke.Name = "UIStroke"
			UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			UIStroke.Color = Color3.fromRGB(30, 30, 30)
			UIStroke.LineJoinMode = Enum.LineJoinMode.Miter
			UIStroke.Parent = Frame

			local Accent = Library:NewInstance("TextButton", true)
			Accent.Name = "Accent"
			Accent.BackgroundColor3 = Library.Accent
			Accent.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Accent.BorderSizePixel = 0
			Accent.Size = UDim2.new(0.5, 0, 1, 0)
			Accent.Text = ""
			Accent.AutoButtonColor = false

			local UIGradient = Instance.new("UIGradient")
			UIGradient.Name = "UIGradient"
			UIGradient.Color = ColorSequence.new({
				ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(120, 120, 120)),
			})
			UIGradient.Rotation = 90
			UIGradient.Parent = Accent

			Accent.Parent = Frame

			Frame.Parent = NewSlider

			local Title = Instance.new("TextLabel")
			Title.Name = "Title"
			Title.FontFace = menu_font
			Title.Text = Slider.Name
			Title.TextColor3 = Color3.fromRGB(200, 200, 200)
			Title.TextSize = Library.FSize
			Title.TextStrokeTransparency = 0
			Title.TextXAlignment = Enum.TextXAlignment.Left
			Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Title.BackgroundTransparency = 1
			Title.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Title.BorderSizePixel = 0
			Title.Size = UDim2.new(1, 0, 0, 12)
			Title.Parent = NewSlider

			local Value = Instance.new("TextLabel")
			Value.Name = "Value"
			Value.FontFace = menu_font
			Value.Text = "100"
			Value.TextColor3 = Color3.fromRGB(200, 200, 200)
			Value.TextSize = Library.FSize
			Value.TextStrokeTransparency = 0
			Value.TextXAlignment = Enum.TextXAlignment.Right
			Value.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Value.BackgroundTransparency = 1
			Value.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Value.BorderSizePixel = 0
			Value.Size = UDim2.new(1, 0, 0, 12)
			Value.Parent = NewSlider

			
			local Sliding = false
			local Val = Slider.State
			local function Set(value)
				value = math.clamp(Library:Round(value, Slider.Decimals), Slider.Min, Slider.Max)

				local sizeX = ((value - Slider.Min) / (Slider.Max - Slider.Min))
				Accent.Size = UDim2.new(sizeX, 0, 1, 0)
				if Slider.Disabled and value == Slider.Min then
					Value.Text = Slider.Disabled
				else
					Value.Text = TextValue:gsub("%[value%]", string.format("%.14g", value))
				end
				Val = value

				Library.Flags[Slider.Flag] = value
				Slider.Callback(value)
			end				
			
			local function ISlide(input)
				local sizeX = (input.Position.X - Frame.AbsolutePosition.X) / Frame.AbsoluteSize.X
				local value = ((Slider.Max - Slider.Min) * sizeX) + Slider.Min
				Set(value)
			end
			
			Library:Connection(Frame.InputBegan, function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					Sliding = true
					ISlide(input)
				end
			end)
			Library:Connection(Frame.InputEnded, function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					Sliding = false
				end
			end)
			Library:Connection(Accent.InputBegan, function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					Sliding = true
					ISlide(input)
				end
			end)
			Library:Connection(Accent.InputEnded, function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					Sliding = false
				end
			end)
			Library:Connection(game:GetService("UserInputService").InputChanged, function(input)
				if input.UserInputType == Enum.UserInputType.MouseMovement then
					if Sliding then
						ISlide(input)
					end
				end
			end)
			
			function Slider:Set(Value)
				Set(Value)
			end
			
			Flags[Slider.Flag] = Set
			Library.Flags[Slider.Flag] = Slider.State
			Set(Slider.State)

			
			return Slider
		end
		
		function Sections:List(Properties)
			local Properties = Properties or {};
			local Dropdown = {
				Window = self.Window,
				Page = self.Page,
				Section = self,
				Open = false,
				Name = Properties.Name or Properties.name or nil,
				Options = (Properties.options or Properties.Options or Properties.values or Properties.Values or {
					"1",
					"2",
					"3",
				}),
				Max = (Properties.Max or Properties.max or nil),
				ScrollMax = (Properties.ScrollingMax or Properties.scrollingmax or nil),
				State = (
					Properties.state
						or Properties.State
						or Properties.def
						or Properties.Def
						or Properties.default
						or Properties.Default
						or nil
				),
				Callback = (
					Properties.callback
						or Properties.Callback
						or Properties.callBack
						or Properties.CallBack
						or function() end
				),
				Flag = (
					Properties.flag
						or Properties.Flag
						or Properties.pointer
						or Properties.Pointer
						or Library.NextFlag()
				),
				OptionInsts = {},
			}
			
			local NewList = Instance.new("TextButton")
			NewList.Name = "NewList"
			NewList.FontFace = menu_font
			NewList.Text = ""
			NewList.TextColor3 = Color3.fromRGB(0, 0, 0)
			NewList.TextSize = 7
			NewList.AutoButtonColor = false
			NewList.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			NewList.BackgroundTransparency = 1
			NewList.BorderColor3 = Color3.fromRGB(0, 0, 0)
			NewList.BorderSizePixel = 0
			NewList.Size = UDim2.new(1, 0, 0, 34)
			NewList.Parent = Dropdown.Section.Elements.SectionContent

			function Dropdown:SetVisible(Bool) 
				NewList.Visible = Bool
			end 

			local Frame = Instance.new("TextButton")
			Frame.Name = "Frame"
			Frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
			Frame.BorderColor3 = Color3.fromRGB(30, 30, 30)
			Frame.BorderSizePixel = 0
			Frame.Position = UDim2.new(0, 0, 1, -16)
			Frame.Size = UDim2.new(1, 0, 0, 16)
			Frame.Text = ""
			Frame.AutoButtonColor = false

			local UIGradient3 = Instance.new("UIGradient")
			UIGradient3.Name = "UIGradient"
			UIGradient3.Color = ColorSequence.new({
				ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(120, 120, 120)),
			})
			UIGradient3.Rotation = 90
			UIGradient3.Parent = Frame

			local UIStroke = Instance.new("UIStroke")
			UIStroke.Name = "UIStroke"
			UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			UIStroke.Color = Color3.fromRGB(30, 30, 30)
			UIStroke.LineJoinMode = Enum.LineJoinMode.Miter
			UIStroke.Parent = Frame

			local Value = Instance.new("TextLabel")
			Value.Name = "Value"
			Value.FontFace = menu_font
			Value.Text = ""
			Value.TextColor3 = Color3.fromRGB(200, 200, 200)
			Value.TextSize = Library.FSize
			Value.TextStrokeTransparency = 0
			Value.TextWrapped = true
			Value.TextXAlignment = Enum.TextXAlignment.Left
			Value.AnchorPoint = Vector2.new(0, 0.5)
			Value.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Value.BackgroundTransparency = 1
			Value.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Value.BorderSizePixel = 0
			Value.Position = UDim2.new(0, 5, 0.5, 0)
			Value.Size = UDim2.new(1, -40, 0, 12)
			Value.Parent = Frame

			local Accent = Library:NewInstance("Frame", true)
			Accent.Name = "Accent"
			Accent.AnchorPoint = Vector2.new(0, 0.5)
			Accent.BackgroundColor3 = Library.Accent
			Accent.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Accent.BorderSizePixel = 0
			Accent.Position = UDim2.new(1, -14, 0.5, 0)
			Accent.Size = UDim2.new(0, 8, 0, 8)

			local UICorner = Instance.new("UICorner")
			UICorner.Name = "UICorner"
			UICorner.CornerRadius = UDim.new(1, 0)
			UICorner.Parent = Accent

			Accent.Parent = Frame

			local Content = Library:NewInstance("ScrollingFrame", true)
			Content.Name = "Content"
			Content.AutomaticCanvasSize = Enum.AutomaticSize.Y
			Content.BottomImage = "rbxassetid://7783554086"
			Content.CanvasSize = UDim2.new()
			Content.MidImage = "rbxassetid://7783554086"
			Content.ScrollBarImageColor3 = Library.Accent
			Content.ScrollBarThickness = 4
			Content.TopImage = "rbxassetid://7783554086"
			Content.Active = true
			Content.AutomaticSize = Enum.AutomaticSize.Y
			Content.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
			Content.BorderColor3 = Color3.fromRGB(30, 30, 30)
			Content.Position = UDim2.new(0, 0, 1, 0)
			Content.Size = UDim2.new(1, 0, 0, 0)
			Content.Visible = false
			Content.ZIndex = 50

			local UIListLayout = Instance.new("UIListLayout")
			UIListLayout.Name = "UIListLayout"
			UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
			UIListLayout.Parent = Content

			Content.Parent = Frame

			Frame.Parent = NewList

			local Title = Instance.new("TextLabel")
			Title.Name = "Title"
			Title.FontFace = menu_font
			Title.Text = Dropdown.Name
			Title.TextColor3 = Color3.fromRGB(200, 200, 200)
			Title.TextSize = Library.FSize
			Title.TextStrokeTransparency = 0
			Title.TextXAlignment = Enum.TextXAlignment.Left
			Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Title.BackgroundTransparency = 1
			Title.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Title.BorderSizePixel = 0
			Title.Size = UDim2.new(1, 0, 0, 12)
			Title.Parent = NewList

			
			Library:Connection(Frame.MouseButton1Down, function()
				Content.Visible = not Content.Visible
				if Content.Visible then
					NewList.ZIndex = 5
				else
					NewList.ZIndex = 1
				end
			end)
			Library:Connection(game:GetService("UserInputService").InputBegan, function(Input)
				if Content.Visible and Input.UserInputType == Enum.UserInputType.MouseButton1 then
					if not Library:IsMouseOverFrame(Content) and not Library:IsMouseOverFrame(Frame) then
						Content.Visible = false
						NewList.ZIndex = 1
					end
				end
			end)
			
			local chosen = Dropdown.Max and {} or nil
			local Count = 0
			
			local function handleoptionclick(option, button, text, accent)
				button.MouseButton1Down:Connect(function()
					if Dropdown.Max then
						if table.find(chosen, option) then
							table.remove(chosen, table.find(chosen, option))

							local textchosen = {}
							local cutobject = false

							for _, opt in next, chosen do
								table.insert(textchosen, opt)
							end

							Value.Text = #chosen == 0 and "" or table.concat(textchosen, ",") .. (cutobject and ", ..." or "")
							text.Position = UDim2.new(0, 6, 0.5, 0)
							accent.Visible = false

							Library.Flags[Dropdown.Flag] = chosen
							Dropdown.Callback(chosen)
						else
							if #chosen == Dropdown.Max then
								Dropdown.OptionInsts[chosen[1]].accent.Visible = false
								Dropdown.OptionInsts[chosen[1]].text.Position = UDim2.new(0, 6, 0.5, 0)
								table.remove(chosen, 1)
							end

							table.insert(chosen, option)

							local textchosen = {}
							local cutobject = false

							for _, opt in next, chosen do
								table.insert(textchosen, opt)
							end

							Value.Text = #chosen == 0 and "" or table.concat(textchosen, ",") .. (cutobject and ", ..." or "")
							text.Position = UDim2.new(0, 8, 0.5, 0)
							accent.Visible = true

							Library.Flags[Dropdown.Flag] = chosen
							Dropdown.Callback(chosen)
						end
					else
						for opt, tbl in next, Dropdown.OptionInsts do
							if opt ~= option then
								tbl.text.Position = UDim2.new(0, 6, 0.5, 0)
								tbl.accent.Visible = false
							end
						end
						chosen = option
						Value.Text = option
						text.Position = UDim2.new(0, 8, 0.5, 0)
						accent.Visible = true
						Content.Visible = false
						NewList.ZIndex = 1
						Library.Flags[Dropdown.Flag] = option
						Dropdown.Callback(option)
					end
				end)
			end
			
			local function createoptions(tbl)
				for _, option in next, tbl do
					Dropdown.OptionInsts[option] = {}
					
					local NewOption = Instance.new("TextButton")
					NewOption.Name = "NewOption"
					NewOption.FontFace = menu_font
					NewOption.Text = ""
					NewOption.TextColor3 = Color3.fromRGB(0, 0, 0)
					NewOption.TextSize = 7
					NewOption.AutoButtonColor = false
					NewOption.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
					NewOption.BorderColor3 = Color3.fromRGB(30, 30, 30)
					NewOption.Size = UDim2.new(1, 0, 0, 15)

					local Value1 = Instance.new("TextLabel")
					Value1.Name = "Value"
					Value1.FontFace = menu_font
					Value1.Text = option
					Value1.TextColor3 = Color3.fromRGB(200, 200, 200)
					Value1.TextSize = Library.FSize
					Value1.TextStrokeTransparency = 0
					Value1.TextWrapped = true
					Value1.TextXAlignment = Enum.TextXAlignment.Left
					Value1.AnchorPoint = Vector2.new(0, 0.5)
					Value1.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
					Value1.BackgroundTransparency = 1
					Value1.BorderColor3 = Color3.fromRGB(0, 0, 0)
					Value1.BorderSizePixel = 0
					Value1.Position = UDim2.new(0, 6, 0.5, 0)
					Value1.Size = UDim2.new(1, -40, 0, 12)
					Value1.Parent = NewOption

					local AccentLine = Library:NewInstance("Frame", true)
					AccentLine.Name = "AccentLine"
					AccentLine.BackgroundColor3 = Library.Accent
					AccentLine.BorderColor3 = Color3.fromRGB(0, 0, 0)
					AccentLine.BorderSizePixel = 0
					AccentLine.Size = UDim2.new(0, 2, 1, 0)
					AccentLine.Parent = NewOption
					AccentLine.Visible = false

					NewOption.Parent = Content

					Dropdown.OptionInsts[option].text = Value1
					Dropdown.OptionInsts[option].accent = AccentLine

					Count = Count + 1

					if Dropdown.ScrollMax then
						Content.AutomaticSize = Enum.AutomaticSize.None
						if Count < Dropdown.ScrollMax then
						else
							Content.Size = UDim2.new(1,0, 0, 15*Dropdown.ScrollMax)
						end
					else
						Content.AutomaticSize = Enum.AutomaticSize.Y
					end

					handleoptionclick(option, NewOption, Value1, AccentLine)
				end
			end
			createoptions(Dropdown.Options)
			
			local set
			set = function(option)
				if Dropdown.Max then
					table.clear(chosen)
					option = type(option) == "table" and option or {}

					for opt, tbl in next, Dropdown.OptionInsts do
						if not table.find(option, opt) then
							tbl.text.Position = UDim2.new(0, 6, 0.5, 0)
							tbl.accent.Visible = false
						end
					end

					for i, opt in next, option do
						if table.find(Dropdown.Options, opt) and #chosen < Dropdown.Max then
							table.insert(chosen, opt)
						end
					end

					local textchosen = {}
					local cutobject = false

					for _, opt in next, chosen do
						table.insert(textchosen, opt)
					end

					Value.Text = #chosen == 0 and "" or table.concat(textchosen, ",") .. (cutobject and ", ..." or "")

					Library.Flags[Dropdown.Flag] = chosen
					Dropdown.Callback(chosen)
				end
			end
			
			function Dropdown:Set(option)
				if Dropdown.Max then
					set(option)
				else
					for opt, tbl in next, Dropdown.OptionInsts do
						if opt ~= option then
							tbl.text.Position = UDim2.new(0, 6, 0.5, 0)
							tbl.accent.Visible = false
						end
					end
					if table.find(Dropdown.Options, option) then
						chosen = option
						Dropdown.OptionInsts[option].text.Position = UDim2.new(0, 8, 0.5, 0)
						Dropdown.OptionInsts[option].accent.Visible = true
						Value.Text = option
						Library.Flags[Dropdown.Flag] = chosen
						Dropdown.Callback(chosen)
					else
						chosen = nil
						Value.Text = "None"
						Library.Flags[Dropdown.Flag] = chosen
						Dropdown.Callback(chosen)
					end
				end
			end
			
			function Dropdown:Refresh(tbl)
				for _, opt in next, Dropdown.OptionInsts do
					coroutine.wrap(function()
						opt.button:Destroy()
					end)()
				end
				table.clear(Dropdown.OptionInsts)

				createoptions(tbl)

				if Dropdown.Max then
					table.clear(chosen)
				else
					chosen = nil
				end

				Library.Flags[Dropdown.Flag] = chosen
				Dropdown.Callback(chosen)
			end

			
			if Dropdown.Max then
				Flags[Dropdown.Flag] = set
			else
				Flags[Dropdown.Flag] = Dropdown
			end
			Dropdown:Set(Dropdown.State)
			return Dropdown
		end
		
		function Sections:Colorpicker(Properties)
			local Properties = Properties or {}
			local Colorpicker = {
				Window = self.Window,
				Page = self.Page,
				Section = self,
				Name = (Properties.Name or "Colorpicker"),
				State = (
					Properties.state
						or Properties.State
						or Properties.def
						or Properties.Def
						or Properties.default
						or Properties.Default
						or Color3.fromRGB(255, 0, 0)
				),
				Alpha = (
					Properties.alpha
						or Properties.Alpha
						or Properties.transparency
						or Properties.Transparency
						or 1
				),
				Callback = (
					Properties.callback
						or Properties.Callback
						or Properties.callBack
						or Properties.CallBack
						or function() end
				),
				Flag = (
					Properties.flag
						or Properties.Flag
						or Properties.pointer
						or Properties.Pointer
						or Library.NextFlag()
				),
				Colorpickers = 0,
			}
			
			local NewColor = Instance.new("TextButton")
			NewColor.Name = "NewColor"
			NewColor.FontFace = menu_font
			NewColor.Text = ""
			NewColor.TextColor3 = Color3.fromRGB(0, 0, 0)
			NewColor.TextSize = 7
			NewColor.AutoButtonColor = false
			NewColor.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			NewColor.BackgroundTransparency = 1
			NewColor.BorderColor3 = Color3.fromRGB(0, 0, 0)
			NewColor.BorderSizePixel = 0
			NewColor.Size = UDim2.new(1, 0, 0, 12)
			NewColor.Parent = Colorpicker.Section.Elements.SectionContent

			local Title = Instance.new("TextLabel")
			Title.Name = "Title"
			Title.FontFace = menu_font
			Title.Text = Colorpicker.Name
			Title.TextColor3 = Color3.fromRGB(200, 200, 200)
			Title.TextSize = Library.FSize
			Title.TextStrokeTransparency = 0
			Title.TextXAlignment = Enum.TextXAlignment.Left
			Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Title.BackgroundTransparency = 1
			Title.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Title.BorderSizePixel = 0
			Title.Size = UDim2.new(1, 0, 1, 0)
			Title.Parent = NewColor

			
			Colorpicker.Colorpickers = Colorpicker.Colorpickers + 1
			local colorpickertypes = Library:NewPicker(
				Colorpicker.Name,
				Colorpicker.State,
				Colorpicker.Alpha,
				NewColor,
				Colorpicker.Colorpickers,
				Colorpicker.Flag,
				Colorpicker.Callback
			)

			function Colorpicker:Set(color)
				colorpickertypes:set(color, false, true)
			end

			function Colorpicker:Colorpicker(Properties)
				local Properties = Properties or {}
				local NewColorpicker = {
					State = (
						Properties.state
							or Properties.State
							or Properties.def
							or Properties.Def
							or Properties.default
							or Properties.Default
							or Color3.fromRGB(255, 0, 0)
					),
					Alpha = (
						Properties.alpha
							or Properties.Alpha
							or Properties.transparency
							or Properties.Transparency
							or 1
					),
					Callback = (
						Properties.callback
							or Properties.Callback
							or Properties.callBack
							or Properties.CallBack
							or function() end
					),
					Flag = (
						Properties.flag
							or Properties.Flag
							or Properties.pointer
							or Properties.Pointer
							or Library.NextFlag()
					),
				}
				
				Colorpicker.Colorpickers = Colorpicker.Colorpickers + 1
				local Newcolorpickertypes = Library:NewPicker(
					"",
					NewColorpicker.State,
					NewColorpicker.Alpha,
					NewColor,
					Colorpicker.Colorpickers,
					NewColorpicker.Flag,
					NewColorpicker.Callback
				)

				function NewColorpicker:Set(color)
					Newcolorpickertypes:Set(color)
				end

				
				return NewColorpicker
			end

			
			return Colorpicker
		end
		
		function Sections:Keybind(Properties)
			local Properties = Properties or {}
			local Keybind = {
				Section = self,
				Name = Properties.name or Properties.Name or "Keybind",
				State = (
					Properties.state
						or Properties.State
						or Properties.def
						or Properties.Def
						or Properties.default
						or Properties.Default
						or nil
				),
				Mode = (Properties.mode or Properties.Mode or "Toggle"),
				UseKey = (Properties.UseKey or false),
				Ignore = (Properties.ignore or Properties.Ignore or false),
				Callback = (
					Properties.callback
						or Properties.Callback
						or Properties.callBack
						or Properties.CallBack
						or function() end
				),
				Flag = (
					Properties.flag
						or Properties.Flag
						or Properties.pointer
						or Properties.Pointer
						or Library.NextFlag()
				),
				Binding = nil,
			}
			local Key
			local State = false
			

			local ModeBox = Instance.new("Frame")
			local Hold = Instance.new("TextButton")
			local Toggle = Instance.new("TextButton")
			local Always = Instance.new("TextButton")
			local ListValue
			if not Keybind.Ignore then
				ListValue = Library.KeyList:NewKey(Keybind.State, Keybind.Name, Keybind.Mode)
			end
			
			local NewBind = Instance.new("TextButton")
			NewBind.Name = "NewBind"
			NewBind.FontFace = menu_font
			NewBind.Text = ""
			NewBind.TextColor3 = Color3.fromRGB(0, 0, 0)
			NewBind.TextSize = 7
			NewBind.AutoButtonColor = false
			NewBind.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			NewBind.BackgroundTransparency = 1
			NewBind.BorderColor3 = Color3.fromRGB(0, 0, 0)
			NewBind.BorderSizePixel = 0
			NewBind.Size = UDim2.new(1, 0, 0, 12)
			NewBind.Parent = Keybind.Section.Elements.SectionContent

			local Icon = Instance.new("TextButton")
			Icon.Name = "Icon"
			Icon.AnchorPoint = Vector2.new(0, 0.5)
			Icon.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
			Icon.BorderColor3 = Color3.fromRGB(30, 30, 30)
			Icon.BorderSizePixel = 0
			Icon.Position = UDim2.new(1, -30, 0.5, 0)
			Icon.Size = UDim2.new(0, 30, 0, 14)
			Icon.Text = ""
			Icon.AutoButtonColor = false

			local UIGradient3 = Instance.new("UIGradient")
			UIGradient3.Name = "UIGradient"
			UIGradient3.Color = ColorSequence.new({
				ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(120, 120, 120)),
			})
			UIGradient3.Rotation = 90
			UIGradient3.Parent = Icon

			local UIStroke = Instance.new("UIStroke")
			UIStroke.Name = "UIStroke"
			UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			UIStroke.Color = Color3.fromRGB(30, 30, 30)
			UIStroke.LineJoinMode = Enum.LineJoinMode.Miter
			UIStroke.Parent = Icon

			local Value = Instance.new("TextLabel")
			Value.Name = "Value"
			Value.FontFace = menu_font
			Value.Text = "MB2"
			Value.TextColor3 = Color3.fromRGB(200, 200, 200)
			Value.TextSize = Library.FSize
			Value.TextStrokeTransparency = 0
			Value.TextWrapped = true
			Value.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Value.BackgroundTransparency = 1
			Value.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Value.BorderSizePixel = 0
			Value.Size = UDim2.new(1, 0, 1, 0)
			Value.Parent = Icon

			Icon.Parent = NewBind

			local Title = Instance.new("TextLabel")
			Title.Name = "Title"
			Title.FontFace = menu_font
			Title.Text = Keybind.Name
			Title.TextColor3 = Color3.fromRGB(200, 200, 200)
			Title.TextSize = Library.FSize
			Title.TextStrokeTransparency = 0
			Title.TextXAlignment = Enum.TextXAlignment.Left
			Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Title.BackgroundTransparency = 1
			Title.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Title.BorderSizePixel = 0
			Title.Size = UDim2.new(1, 0, 1, 0)
			Title.Parent = NewBind

			ModeBox.Name = "ModeBox"
			ModeBox.Parent = Icon
			ModeBox.AnchorPoint = Vector2.new(0,0.5)
			ModeBox.BackgroundColor3 = Color3.fromRGB(20,20,20)
			ModeBox.BorderColor3 = Color3.fromRGB(30,30,30)
			ModeBox.BorderSizePixel = 1
			ModeBox.Size = UDim2.new(0, 65, 0, 60)
			ModeBox.Position = UDim2.new(0,40,0.5,0)
			ModeBox.Visible = false

			Hold.Name = "Hold"
			Hold.Parent = ModeBox
			Hold.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Hold.BackgroundTransparency = 1.000
			Hold.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Hold.BorderSizePixel = 0
			Hold.Size = UDim2.new(1, 0, 0.2933000004, 0)
			Hold.ZIndex = 2
			Hold.FontFace = menu_font
			Hold.Text = "Hold"
			Hold.TextColor3 = Keybind.Mode == "Hold" and Color3.fromRGB(200,200,200) or Color3.fromRGB(145,145,145)
			Hold.TextSize = Library.FSize
			Hold.TextStrokeTransparency = 0

			Toggle.Name = "Toggle"
			Toggle.Parent = ModeBox
			Toggle.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Toggle.BackgroundTransparency = 1.000
			Toggle.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Toggle.BorderSizePixel = 0
			Toggle.Position = UDim2.new(0, 0, 0.2933000004, 0)
			Toggle.Size = UDim2.new(1, 0, 0.2933000004, 0)
			Toggle.ZIndex = 2
			Toggle.FontFace = menu_font
			Toggle.Text = "Toggle"
			Toggle.TextColor3 = Keybind.Mode == "Toggle" and Color3.fromRGB(200,200,200) or Color3.fromRGB(145,145,145)
			Toggle.TextSize = Library.FSize
			Toggle.TextStrokeTransparency = 0

			Always.Name = "Always"
			Always.Parent = ModeBox
			Always.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Always.BackgroundTransparency = 1.000
			Always.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Always.BorderSizePixel = 0
			Always.Position = UDim2.new(0, 0, 0.666999996, 0)
			Always.Size = UDim2.new(1, 0, 0.2933000004, 0)
			Always.ZIndex = 2
			Always.FontFace = menu_font
			Always.Text = "Always"
			Always.TextColor3 = Keybind.Mode == "Always" and Color3.fromRGB(200,200,200) or Color3.fromRGB(145,145,145)
			Always.TextSize = Library.FSize
			Always.TextStrokeTransparency = 0

			
			local function set(newkey)
				if string.find(tostring(newkey), "Enum") then
					if c then
						c:Disconnect()
						if Keybind.Flag then
							Library.Flags[Keybind.Flag] = false
						end
						Keybind.Callback(false)
					end
					if tostring(newkey):find("Enum.KeyCode.") then
						newkey = Enum.KeyCode[tostring(newkey):gsub("Enum.KeyCode.", "")]
					elseif tostring(newkey):find("Enum.UserInputType.") then
						newkey = Enum.UserInputType[tostring(newkey):gsub("Enum.UserInputType.", "")]
					end
					if newkey == Enum.KeyCode.Backspace then
						Key = nil
						if Keybind.UseKey then
							if Keybind.Flag then
								Library.Flags[Keybind.Flag] = Key
							end
							Keybind.Callback(Key)
						end
						local text = "None"

						Value.Text = text
						if not Keybind.Ignore then
							ListValue:Update(text, Keybind.Name, Keybind.Mode)
						end
					elseif newkey ~= nil then
						Key = newkey
						if Keybind.UseKey then
							if Keybind.Flag then
								Library.Flags[Keybind.Flag] = Key
							end
							Keybind.Callback(Key)
						end
						local text = (Library.Keys[newkey] or tostring(newkey):gsub("Enum.KeyCode.", ""))

						Value.Text = text
						if not Keybind.Ignore then
							ListValue:Update(text, Keybind.Name, Keybind.Mode)
						end
					end

					Library.Flags[Keybind.Flag .. "_KEY"] = newkey
				elseif table.find({ "Always", "Toggle", "Hold" }, newkey) then
					if not Keybind.UseKey then
						Library.Flags[Keybind.Flag .. "_KEY STATE"] = newkey
						Keybind.Mode = newkey
						if not Keybind.Ignore then
							ListValue:Update((Library.Keys[Key] or tostring(Key):gsub("Enum.KeyCode.", "")), Keybind.Name, Keybind.Mode)
						end
						if Keybind.Mode == "Always" then
							State = true
							if Keybind.Flag then
								Library.Flags[Keybind.Flag] = State
							end
							Keybind.Callback(true)
							ListValue:SetVisible(true)
						end
					end
				else
					State = newkey
					if Keybind.Flag then
						Library.Flags[Keybind.Flag] = newkey
					end
					Keybind.Callback(newkey)
				end
			end
			
			set(Keybind.State)
			set(Keybind.Mode)
			Icon.MouseButton1Click:Connect(function()
				if not Keybind.Binding then

					Value.Text = "..."

					Keybind.Binding = Library:Connection(
						game:GetService("UserInputService").InputBegan,
						function(input, gpe)
							set(
								input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode
									or input.UserInputType
							)
							Library:Disconnect(Keybind.Binding)
							task.wait()
							Keybind.Binding = nil
						end
					)
				end
			end)
			
			Library:Connection(game:GetService("UserInputService").InputBegan, function(inp)
				if (inp.KeyCode == Key or inp.UserInputType == Key) and not Keybind.Binding and not Keybind.UseKey then
					if Keybind.Mode == "Hold" then
						if Keybind.Flag then
							Library.Flags[Keybind.Flag] = true
						end
						c = Library:Connection(game:GetService("RunService").RenderStepped, function()
							if Keybind.Callback then
								Keybind.Callback(true)
							end
						end)
						if not Keybind.Ignore then
							ListValue:SetVisible(true)
						end
					elseif Keybind.Mode == "Toggle" then
						State = not State
						if Keybind.Flag then
							Library.Flags[Keybind.Flag] = State
						end
						Keybind.Callback(State)
						if not Keybind.Ignore then
							ListValue:SetVisible(State)
						end
					end
				end
			end)
			
			Library:Connection(game:GetService("UserInputService").InputEnded, function(inp)
				if Keybind.Mode == "Hold" and not Keybind.UseKey then
					if Key ~= "" or Key ~= nil then
						if inp.KeyCode == Key or inp.UserInputType == Key then
							if c then
								c:Disconnect()
								if Keybind.Flag then
									Library.Flags[Keybind.Flag] = false
								end
								if Keybind.Callback then
									Keybind.Callback(false)
								end
								if not Keybind.Ignore then
									ListValue:SetVisible(false)
								end
							end
						end
					end
				end
			end)
			
			Library:Connection(Icon.MouseButton2Down, function()
				ModeBox.Visible = true
				NewBind.ZIndex = 5
			end)
			
			Library:Connection(Hold.MouseButton1Down, function()
				set("Hold")
				Hold.TextColor3 = Color3.fromRGB(200,200,200)
				Toggle.TextColor3 = Color3.fromRGB(145,145,145)
				Always.TextColor3 = Color3.fromRGB(145,145,145)
				ModeBox.Visible = false
				NewBind.ZIndex = 1
			end)
			
			Library:Connection(Toggle.MouseButton1Down, function()
				set("Toggle")
				Hold.TextColor3 = Color3.fromRGB(145,145,145)
				Toggle.TextColor3 = Color3.fromRGB(200,200,200)
				Always.TextColor3 = Color3.fromRGB(145,145,145)
				ModeBox.Visible = false
				NewBind.ZIndex = 1
			end)
			
			Library:Connection(Always.MouseButton1Down, function()
				set("Always")
				Hold.TextColor3 = Color3.fromRGB(145,145,145)
				Toggle.TextColor3 = Color3.fromRGB(145,145,145)
				Always.TextColor3 = Color3.fromRGB(200,200,200)
				ModeBox.Visible = false
				NewBind.ZIndex = 1
			end)
			
			Library:Connection(game:GetService("UserInputService").InputBegan, function(Input)
				if ModeBox.Visible and Input.UserInputType == Enum.UserInputType.MouseButton1 then
					if not Library:IsMouseOverFrame(ModeBox) then
						ModeBox.Visible = false
						NewBind.ZIndex = 1
					end
				end
			end)
			
			Library.Flags[Keybind.Flag .. "_KEY"] = Keybind.State
			Library.Flags[Keybind.Flag .. "_KEY STATE"] = Keybind.Mode
			Flags[Keybind.Flag] = set
			Flags[Keybind.Flag .. "_KEY"] = set
			Flags[Keybind.Flag .. "_KEY STATE"] = set
			
			function Keybind:Set(key)
				set(key)
			end

			
			return Keybind
		end
		
		function Sections:Textbox(Properties)
			local Properties = Properties or {}
			local Textbox = {
				Window = self.Window,
				Page = self.Page,
				Section = self,
				Name = (Properties.Name or Properties.name or "textbox"),
				Placeholder = (
					Properties.placeholder
						or Properties.Placeholder
						or Properties.holder
						or Properties.Holder
						or ""
				),
				State = (
					Properties.state
						or Properties.State
						or Properties.def
						or Properties.Def
						or Properties.default
						or Properties.Default
						or ""
				),
				Callback = (
					Properties.callback
						or Properties.Callback
						or Properties.callBack
						or Properties.CallBack
						or function() end
				),
				Flag = (
					Properties.flag
						or Properties.Flag
						or Properties.pointer
						or Properties.Pointer
						or Library.NextFlag()
				),
			}
			
			local NewBox = Instance.new("TextButton")
			NewBox.Name = "NewBox"
			NewBox.FontFace = menu_font
			NewBox.Text = ""
			NewBox.TextColor3 = Color3.fromRGB(0, 0, 0)
			NewBox.TextSize = 7
			NewBox.AutoButtonColor = false
			NewBox.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			NewBox.BackgroundTransparency = 1
			NewBox.BorderColor3 = Color3.fromRGB(0, 0, 0)
			NewBox.BorderSizePixel = 0
			NewBox.Size = UDim2.new(1, 0, 0, 34)
			NewBox.Parent = Textbox.Section.Elements.SectionContent

			function Textbox:SetVisible(Bool)
				NewBox.Visible = Bool
			end 	

			local Frame = Instance.new("Frame")
			Frame.Name = "Frame"
			Frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
			Frame.BorderColor3 = Color3.fromRGB(30, 30, 30)
			Frame.Position = UDim2.new(0, 0, 1, -16)
			Frame.Size = UDim2.new(1, 0, 0, 16)
			Frame.BorderSizePixel = 0

			local UIGradient3 = Instance.new("UIGradient")
			UIGradient3.Name = "UIGradient"
			UIGradient3.Color = ColorSequence.new({
				ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(120, 120, 120)),
			})
			UIGradient3.Rotation = 90
			UIGradient3.Parent = Frame

			local UIStroke = Instance.new("UIStroke")
			UIStroke.Name = "UIStroke"
			UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			UIStroke.Color = Color3.fromRGB(30, 30, 30)
			UIStroke.LineJoinMode = Enum.LineJoinMode.Miter
			UIStroke.Parent = Frame

			local Value = Instance.new("TextBox")
			Value.Name = "Value"
			Value.FontFace = menu_font
			Value.Text = Textbox.State
			Value.PlaceholderText = Textbox.Placeholder
			Value.TextColor3 = Color3.fromRGB(200, 200, 200)
			Value.TextSize = Library.FSize
			Value.TextStrokeTransparency = 0
			Value.TextWrapped = true
			Value.TextXAlignment = Enum.TextXAlignment.Left
			Value.AnchorPoint = Vector2.new(0, 0.5)
			Value.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Value.BackgroundTransparency = 1
			Value.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Value.BorderSizePixel = 0
			Value.Position = UDim2.new(0, 5, 0.5, 0)
			Value.Size = UDim2.new(1, -10, 0, 16)
			Value.Parent = Frame
			Value.ClearTextOnFocus = false

			Frame.Parent = NewBox

			local Title = Instance.new("TextLabel")
			Title.Name = "Title"
			Title.FontFace = menu_font
			Title.Text = Textbox.Name
			Title.TextColor3 = Color3.fromRGB(200, 200, 200)
			Title.TextSize = Library.FSize
			Title.TextStrokeTransparency = 0
			Title.TextXAlignment = Enum.TextXAlignment.Left
			Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Title.BackgroundTransparency = 1
			Title.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Title.BorderSizePixel = 0
			Title.Size = UDim2.new(1, 0, 0, 12)
			Title.Parent = NewBox

			
			Value.FocusLost:Connect(function()
				Textbox.Callback(Value.Text)
				Library.Flags[Textbox.Flag] = Value.Text
			end)
			
			local function set(str)
				Value.Text = str
				Library.Flags[Textbox.Flag] = str
				Textbox.Callback(str)
			end

			
			Flags[Textbox.Flag] = set
			return Textbox
		end
		
		function Sections:Button(Properties)
			local Properties = Properties or {}
			local Button = {
				Window = self.Window,
				Page = self.Page,
				Section = self,
				Name = Properties.Name or "button",
				Callback = (
					Properties.callback
						or Properties.Callback
						or Properties.callBack
						or Properties.CallBack
						or function() end
				),
			}
			
			local NewButton = Instance.new("TextButton")
			NewButton.Name = "NewButton"
			NewButton.FontFace = menu_font
			NewButton.Text = ""
			NewButton.TextColor3 = Color3.fromRGB(0, 0, 0)
			NewButton.TextSize = 7
			NewButton.AutoButtonColor = false
			NewButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			NewButton.BackgroundTransparency = 1
			NewButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
			NewButton.BorderSizePixel = 0
			NewButton.Size = UDim2.new(1, 0, 0, 16)
			NewButton.Parent = Button.Section.Elements.SectionContent

			local Frame = Instance.new("Frame")
			Frame.Name = "Frame"
			Frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
			Frame.BorderColor3 = Color3.fromRGB(30, 30, 30)
			Frame.Position = UDim2.new(0, 0, 1, -16)
			Frame.Size = UDim2.new(1, 0, 0, 16)
			Frame.BorderSizePixel = 0

			local UIGradient3 = Instance.new("UIGradient")
			UIGradient3.Name = "UIGradient"
			UIGradient3.Color = ColorSequence.new({
				ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(120, 120, 120)),
			})
			UIGradient3.Rotation = 90
			UIGradient3.Parent = Frame

			local UIStroke = Instance.new("UIStroke")
			UIStroke.Name = "UIStroke"
			UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			UIStroke.Color = Color3.fromRGB(30, 30, 30)
			UIStroke.LineJoinMode = Enum.LineJoinMode.Miter
			UIStroke.Parent = Frame

			local Value = Instance.new("TextLabel")
			Value.Name = "Value"
			Value.FontFace = menu_font
			Value.Text = Button.Name
			Value.TextColor3 = Color3.fromRGB(200, 200, 200)
			Value.TextSize = Library.FSize
			Value.TextStrokeTransparency = 0
			Value.TextWrapped = true
			Value.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Value.BackgroundTransparency = 1
			Value.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Value.BorderSizePixel = 0
			Value.Size = UDim2.new(1, 0, 1, 0)
			Value.Parent = Frame

			Frame.Parent = NewButton
			
			Library:Connection(NewButton.MouseButton1Down, function()
				Button.Callback()
				TweenService:Create(Value, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {TextColor3 = Library.Accent}):Play()
				task.spawn(function()
					task.wait(0.25)
					TweenService:Create(Value, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {TextColor3 = Color3.fromRGB(200,200,200)}):Play()
				end)
			end)

			return Button
		end
		
		function Pages:PlayerList(Properties)
			if not Properties then
				Properties = {}
			end
			
			local Playerlist = {
				Page = self,
				Players = {},
				CurrentPlayer = nil;
				LastPlayer = nil;
				Flag = (
					Properties.flag
						or Properties.Flag
						or Properties.pointer
						or Properties.Pointer
						or Library.NextFlag()
				),
			}
			
			local NewPlayer = Instance.new("Frame")
			NewPlayer.Name = "NewPlayer"
			NewPlayer.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
			NewPlayer.BorderColor3 = Color3.fromRGB(30, 30, 30)
			NewPlayer.Size = UDim2.new(1, 0, 0.5, 80)
			NewPlayer.Parent = Playerlist.Page.Elements.Main

			local SectionTop = Instance.new("Frame")
			SectionTop.Name = "SectionTop"
			SectionTop.BackgroundColor3 = Color3.fromRGB(27, 27, 27)
			SectionTop.BorderColor3 = Color3.fromRGB(0, 0, 0)
			SectionTop.BorderSizePixel = 0
			SectionTop.Size = UDim2.new(1, 0, 0, 20)

			local SectionName = Instance.new("TextLabel")
			SectionName.Name = "SectionName"
			SectionName.FontFace = menu_font
			SectionName.Text = "Player List"
			SectionName.TextColor3 = Color3.fromRGB(200, 200, 200)
			SectionName.TextSize = Library.FSize
			SectionName.TextStrokeTransparency = 0
			SectionName.TextXAlignment = Enum.TextXAlignment.Left
			SectionName.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			SectionName.BackgroundTransparency = 1
			SectionName.BorderColor3 = Color3.fromRGB(0, 0, 0)
			SectionName.BorderSizePixel = 0
			SectionName.Position = UDim2.new(0, 5, 0, 0)
			SectionName.Size = UDim2.new(1, 0, 1, 0)
			SectionName.Parent = SectionTop

			SectionTop.Parent = NewPlayer

			local List = Library:NewInstance("ScrollingFrame", true)
			List.Name = "List"
			List.AutomaticCanvasSize = Enum.AutomaticSize.Y
			List.BottomImage = "rbxassetid://7783554086"
			List.CanvasSize = UDim2.new()
			List.MidImage = "rbxassetid://7783554086"
			List.ScrollBarImageColor3 = Library.Accent
			List.ScrollBarThickness = 8
			List.TopImage = "rbxassetid://7783554086"
			List.Active = true
			List.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
			List.BorderColor3 = Color3.fromRGB(30, 30, 30)
			List.Position = UDim2.new(0, 5, 0, 25)
			List.Size = UDim2.new(1, -10, 0, 225)

			local UIListLayout = Instance.new("UIListLayout")
			UIListLayout.Name = "UIListLayout"
			UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
			UIListLayout.Parent = List

			List.Parent = NewPlayer

			local ImageLabel = Instance.new("ImageLabel")
			ImageLabel.Name = "ImageLabel"
			ImageLabel.Image = ""
			ImageLabel.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
			ImageLabel.BorderColor3 = Color3.fromRGB(30, 30, 30)
			ImageLabel.Position = UDim2.new(0, 5, 1, -75)
			ImageLabel.Size = UDim2.new(0, 70, 0, 70)
			ImageLabel.Parent = NewPlayer

			local PlayerName1 = Instance.new("TextLabel")
			PlayerName1.Name = "PlayerName"
			PlayerName1.FontFace = menu_font
			PlayerName1.Text = "Select a Player."
			PlayerName1.TextColor3 = Color3.fromRGB(200, 200, 200)
			PlayerName1.TextSize = Library.FSize
			PlayerName1.TextStrokeTransparency = 0
			PlayerName1.TextXAlignment = Enum.TextXAlignment.Left
			PlayerName1.TextYAlignment = Enum.TextYAlignment.Top
			PlayerName1.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			PlayerName1.BackgroundTransparency = 1
			PlayerName1.BorderColor3 = Color3.fromRGB(0, 0, 0)
			PlayerName1.BorderSizePixel = 0
			PlayerName1.Position = UDim2.new(0, 80, 1, -75)
			PlayerName1.Size = UDim2.new(1, -459, 0, 70)
			PlayerName1.Parent = NewPlayer

			local Priority = Instance.new("TextButton")
			Priority.Name = "Priority"
			Priority.FontFace = menu_font
			Priority.Text = ""
			Priority.TextColor3 = Color3.fromRGB(0, 0, 0)
			Priority.TextSize = 7
			Priority.AutoButtonColor = false
			Priority.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
			Priority.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Priority.BorderSizePixel = 0
			Priority.Position = UDim2.new(1, -105, 1, -70)
			Priority.Size = UDim2.new(0, 100, 0, 25)

			local UIStroke = Instance.new("UIStroke")
			UIStroke.Name = "UIStroke"
			UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			UIStroke.Color = Color3.fromRGB(30, 30, 30)
			UIStroke.LineJoinMode = Enum.LineJoinMode.Miter
			UIStroke.Parent = Priority

			local UIGradient = Instance.new("UIGradient")
			UIGradient.Name = "UIGradient"
			UIGradient.Color = ColorSequence.new({
				ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(120, 120, 120)),
			})
			UIGradient.Rotation = 90
			UIGradient.Parent = Priority

			local PriorityLabel = Instance.new("TextLabel")
			PriorityLabel.Name = "PriorityLabel"
			PriorityLabel.FontFace = menu_font
			PriorityLabel.Text = "Prioritize"
			PriorityLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
			PriorityLabel.TextSize = Library.FSize
			PriorityLabel.TextStrokeTransparency = 0
			PriorityLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			PriorityLabel.BackgroundTransparency = 1
			PriorityLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
			PriorityLabel.BorderSizePixel = 0
			PriorityLabel.Size = UDim2.new(1, 0, 1, 0)
			PriorityLabel.Parent = Priority

			Priority.Parent = NewPlayer

			local Friend = Instance.new("TextButton")
			Friend.Name = "Friend"
			Friend.FontFace = menu_font
			Friend.Text = ""
			Friend.TextColor3 = Color3.fromRGB(0, 0, 0)
			Friend.TextSize = 7
			Friend.AutoButtonColor = false
			Friend.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
			Friend.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Friend.BorderSizePixel = 0
			Friend.Position = UDim2.new(1, -105, 1, -35)
			Friend.Size = UDim2.new(0, 100, 0, 25)

			local UIStroke1 = Instance.new("UIStroke")
			UIStroke1.Name = "UIStroke"
			UIStroke1.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			UIStroke1.Color = Color3.fromRGB(30, 30, 30)
			UIStroke1.LineJoinMode = Enum.LineJoinMode.Miter
			UIStroke1.Parent = Friend

			local UIGradient1 = Instance.new("UIGradient")
			UIGradient1.Name = "UIGradient"
			UIGradient1.Color = ColorSequence.new({
				ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(120, 120, 120)),
			})
			UIGradient1.Rotation = 90
			UIGradient1.Parent = Friend

			local FriendLabel = Instance.new("TextLabel")
			FriendLabel.Name = "FriendLabel"
			FriendLabel.FontFace = menu_font
			FriendLabel.Text = "Friendly"
			FriendLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
			FriendLabel.TextSize = Library.FSize
			FriendLabel.TextStrokeTransparency = 0
			FriendLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			FriendLabel.BackgroundTransparency = 1
			FriendLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
			FriendLabel.BorderSizePixel = 0
			FriendLabel.Size = UDim2.new(1, 0, 1, 0)
			FriendLabel.Parent = Friend

			Friend.Parent = NewPlayer

			
			local chosen = nil
			local optioninstances = {}
			local function handleoptionclick(option, button, accent)
				button.MouseButton1Click:Connect(function()
					chosen = option
					Library.Flags[Playerlist.Flag] = option
					Playerlist.CurrentPlayer = option
					
					for opt, tbl in next, optioninstances do
						if opt ~= option then
							tbl.accent.Visible = false
						end
					end
					accent.Visible = true
					
					if Playerlist.CurrentPlayer ~= Playerlist.LastPlayer then
						Playerlist.LastPlayer = Playerlist.CurrentPlayer;
						PlayerName1.Text = ("Id : %s\nDisplay Name : %s\nName : %s\nAccount Age : %s"):format(Playerlist.CurrentPlayer.UserId, Playerlist.CurrentPlayer.DisplayName ~= "" and Playerlist.CurrentPlayer.DisplayName or Playerlist.CurrentPlayer.Name, Playerlist.CurrentPlayer.Name, Playerlist.CurrentPlayer.AccountAge)
						
						local imagedata = game:GetService("Players"):GetUserThumbnailAsync(Playerlist.CurrentPlayer.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size420x420)

						ImageLabel.Image = imagedata
					end;
				end)
			end
			
			local function createoptions(tbl)
				for i, option in next, tbl do
					optioninstances[option] = {}

					local NewPlayer1 = Instance.new("TextButton")
					NewPlayer1.Name = "NewPlayer"
					NewPlayer1.FontFace = menu_font
					NewPlayer1.Text = ""
					NewPlayer1.TextColor3 = Color3.fromRGB(0, 0, 0)
					NewPlayer1.TextSize = 7
					NewPlayer1.AutoButtonColor = false
					NewPlayer1.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
					NewPlayer1.BorderColor3 = Color3.fromRGB(30, 30, 30)
					NewPlayer1.Size = UDim2.new(1, 0, 0, 15)

					local PlayerName = Instance.new("TextLabel")
					PlayerName.Name = "PlayerName"
					PlayerName.FontFace = menu_font
					PlayerName.Text = option.Name
					PlayerName.TextColor3 = Color3.fromRGB(200, 200, 200)
					PlayerName.TextSize = Library.FSize
					PlayerName.TextStrokeTransparency = 0
					PlayerName.TextXAlignment = Enum.TextXAlignment.Left
					PlayerName.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
					PlayerName.BackgroundTransparency = 1
					PlayerName.BorderColor3 = Color3.fromRGB(0, 0, 0)
					PlayerName.BorderSizePixel = 0
					PlayerName.Position = UDim2.new(0, 6, 0, 0)
					PlayerName.Size = UDim2.new(1, 0, 1, 0)
					PlayerName.Parent = NewPlayer1

					local PlayerStatus = Instance.new("TextLabel")
					PlayerStatus.Name = "PlayerStatus"
					PlayerStatus.FontFace = menu_font
					PlayerStatus.Text = option == LocalPlayer and "Local Player" or table.find(Library.Friends, option) and "Friendly" or table.find(Library.Priorities, option) and "Priority" or "None"
					PlayerStatus.TextColor3 = option == LocalPlayer and Color3.fromRGB(0, 170, 255) or table.find(Library.Friends, option) and Color3.fromRGB(0,255,0) or table.find(Library.Priorities, option) and Color3.fromRGB(255,0,0) or Color3.fromRGB(200,200,200)
					PlayerStatus.TextSize = Library.FSize
					PlayerStatus.TextStrokeTransparency = 0
					PlayerStatus.TextXAlignment = Enum.TextXAlignment.Right
					PlayerStatus.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
					PlayerStatus.BackgroundTransparency = 1
					PlayerStatus.BorderColor3 = Color3.fromRGB(0, 0, 0)
					PlayerStatus.BorderSizePixel = 0
					PlayerStatus.Position = UDim2.new(0, -25, 0, 0)
					PlayerStatus.Size = UDim2.new(1, 0, 1, 0)
					PlayerStatus.Parent = NewPlayer1

					local AccentLine = Library:NewInstance("Frame", true)
					AccentLine.Name = "AccentLine"
					AccentLine.BackgroundColor3 = Library.Accent
					AccentLine.BorderColor3 = Color3.fromRGB(0, 0, 0)
					AccentLine.BorderSizePixel = 0
					AccentLine.Size = UDim2.new(0, 2, 1, 0)
					AccentLine.Visible = false
					AccentLine.Parent = NewPlayer1

					NewPlayer1.Parent = List

					optioninstances[option].button = NewPlayer1
					optioninstances[option].text = PlayerName
					optioninstances[option].status = PlayerStatus
					optioninstances[option].accent = AccentLine

					if option ~= LocalPlayer then
						handleoptionclick(option, NewPlayer1, AccentLine)
					end
				end
			end
			
			function Playerlist:Refresh(tbl, dontchange)
				content = table.clone(tbl)

				for _, opt in next, optioninstances do
					coroutine.wrap(function()
						opt.button:Remove()
					end)()
				end

				table.clear(optioninstances)

				createoptions(content)

				if dontchange then
					chosen = Playerlist.CurrentPlayer
				else
					chosen = nil
				end
				Library.Flags[Playerlist.Flag] = chosen
				Playerlist.CurrentPlayer = nil
			end
			
			Priority.MouseButton1Click:Connect(function()
				if Playerlist.CurrentPlayer ~= nil and table.find(Library.Friends, Playerlist.CurrentPlayer) then
					table.remove(Library.Friends, table.find(Library.Friends, Playerlist.CurrentPlayer))
				end
				if Playerlist.CurrentPlayer ~= nil and not table.find(Library.Priorities, Playerlist.CurrentPlayer) then
					table.insert(Library.Priorities, Playerlist.CurrentPlayer)
					optioninstances[Playerlist.CurrentPlayer].status.Text = "Priority"
					optioninstances[Playerlist.CurrentPlayer].status.TextColor3 = Color3.fromRGB(255, 0, 0)
				elseif Playerlist.CurrentPlayer ~= nil and table.find(Library.Priorities, Playerlist.CurrentPlayer) then
					table.remove(Library.Priorities, table.find(Library.Priorities, Playerlist.CurrentPlayer))
					optioninstances[Playerlist.CurrentPlayer].status.Text = "None"
					optioninstances[Playerlist.CurrentPlayer].status.TextColor3 = Color3.fromRGB(200,200,200)
				end
			end)
			
			Friend.MouseButton1Click:Connect(function()
				if Playerlist.CurrentPlayer ~= nil and table.find(Library.Priorities, Playerlist.CurrentPlayer) then
					table.remove(Library.Priorities, table.find(Library.Priorities, Playerlist.CurrentPlayer))
				end
				if Playerlist.CurrentPlayer ~= nil and not table.find(Library.Friends, Playerlist.CurrentPlayer) then
					table.insert(Library.Friends, Playerlist.CurrentPlayer)
					optioninstances[Playerlist.CurrentPlayer].status.Text = "Friendly"
					optioninstances[Playerlist.CurrentPlayer].status.TextColor3 = Color3.fromRGB(0, 255, 0)
				elseif Playerlist.CurrentPlayer ~= nil and table.find(Library.Friends, Playerlist.CurrentPlayer) then
					table.remove(Library.Friends, table.find(Library.Friends, Playerlist.CurrentPlayer))
					optioninstances[Playerlist.CurrentPlayer].status.Text = "None"
					optioninstances[Playerlist.CurrentPlayer].status.TextColor3 = Color3.fromRGB(200,200,200)
				end
			end)
			
			createoptions(game.Players:GetPlayers())
			
			game.Players.PlayerAdded:Connect(function()
				Playerlist:Refresh(game.Players:GetPlayers(), true)
			end)
			
			game.Players.PlayerRemoving:Connect(function()
				Playerlist:Refresh(game.Players:GetPlayers(), true)
			end)

			Playerlist.Page.Elements.Left.Size = UDim2.new(0.5, -5,0.5, -80)
			Playerlist.Page.Elements.Right.Size = UDim2.new(0.5, -5,0.5, -80)
			Playerlist.Page.Elements.Left.Position = UDim2.new(0, 0,0.5, 85)
			Playerlist.Page.Elements.Right.Position = UDim2.new(0.5, 5,0.5, 85)
		end
		
		function Sections:Label(Properties)
			local Properties = Properties or {}
			local Label = {
				Window = self.Window,
				Page = self.Page,
				Section = self,
				Name = Properties.Name or "button",
			}
			
			local NewButton = Instance.new("TextButton")
			NewButton.Name = "NewButton"
			NewButton.FontFace = menu_font
			NewButton.Text = ""
			NewButton.TextColor3 = Color3.fromRGB(0, 0, 0)
			NewButton.TextSize = 7
			NewButton.AutoButtonColor = false
			NewButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			NewButton.BackgroundTransparency = 1
			NewButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
			NewButton.BorderSizePixel = 0
			NewButton.Size = UDim2.new(1, 0, 0, 10)
			NewButton.Parent = Label.Section.Elements.SectionContent

			local Value = Instance.new("TextLabel")
			Value.Name = "Value"
			Value.FontFace = menu_font
			Value.Text = Label.Name
			Value.TextColor3 = Color3.fromRGB(200, 200, 200)
			Value.TextSize = Library.FSize
			Value.TextStrokeTransparency = 0
			Value.TextWrapped = true
			Value.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Value.BackgroundTransparency = 1
			Value.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Value.BorderSizePixel = 0
			Value.Size = UDim2.new(1, 0, 1, 0)
			Value.Parent = NewButton

			return Label
		end
		
		function Library:Indicator(Properties)
			local Indicator = {
				Title = Properties.Name or Properties.name or "New Indicator";
				Elements = {};
				Dragging = { false, UDim2.new(0, 0, 0, 0) };
			};
			
			local Outline = Instance.new("TextButton")
			Outline.Name = "Outline"
			Outline.AutomaticSize = Enum.AutomaticSize.Y
			Outline.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
			Outline.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Outline.Position = UDim2.new(0,200,0.5,0)
			Outline.Size = UDim2.new(0, 200, 0, 15)
			Outline.AnchorPoint = Vector2.new(0.5,0.5)
			Outline.Parent = Library.ScreenGUI
			Outline.Visible = false
			Outline.Text = ""
			Outline.AutoButtonColor = false

			local Inline = Instance.new("Frame")
			Inline.Name = "Inline"
			Inline.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
			Inline.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Inline.BorderSizePixel = 0
			Inline.Position = UDim2.new(0, 1, 0, 1)
			Inline.Size = UDim2.new(1, -2, 1, -2)

			local Value = Instance.new("TextLabel")
			Value.Name = "Value"
			Value.Font = Enum.Font.GothamBold
			Value.Text = Indicator.Title
			Value.TextColor3 = Color3.fromRGB(255, 255, 255)
			Value.TextSize = 12
			Value.TextStrokeTransparency = 0
			Value.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
			Value.BackgroundTransparency = 1
			Value.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Value.BorderSizePixel = 0
			Value.Position = UDim2.new(0, 0, 0, 2)
			Value.Size = UDim2.new(1, 0, 0, 15)
			Value.Parent = Inline

			local HolderOutline = Instance.new("Frame")
			HolderOutline.Name = "HolderOutline"
			HolderOutline.AutomaticSize = Enum.AutomaticSize.Y
			HolderOutline.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
			HolderOutline.BorderColor3 = Color3.fromRGB(0, 0, 0)
			HolderOutline.Position = UDim2.new(0, 6, 0, 22)
			HolderOutline.Size = UDim2.new(1, -12, 0, 0)

			local HolderInline = Instance.new("Frame")
			HolderInline.Name = "HolderInline"
			HolderInline.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
			HolderInline.BorderColor3 = Color3.fromRGB(0, 0, 0)
			HolderInline.BorderSizePixel = 0
			HolderInline.Position = UDim2.new(0, 1, 0, 1)
			HolderInline.Size = UDim2.new(1, -2, 1, -2)

			local UIListLayout = Instance.new("UIListLayout")
			UIListLayout.Name = "UIListLayout"
			UIListLayout.Padding = UDim.new(0, 2)
			UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
			UIListLayout.Parent = HolderInline

			local UIPadding = Instance.new("UIPadding")
			UIPadding.Name = "UIPadding"
			UIPadding.PaddingBottom = UDim.new(0, 6)
			UIPadding.PaddingTop = UDim.new(0, 6)
			UIPadding.Parent = HolderInline

			HolderInline.Parent = HolderOutline

			HolderOutline.Parent = Inline

			local UIPadding1 = Instance.new("UIPadding")
			UIPadding1.Name = "UIPadding"
			UIPadding1.PaddingBottom = UDim.new(0, 6)
			UIPadding1.Parent = Inline

			Inline.Parent = Outline

			local Accent = Library:NewInstance("Frame", true)
			Accent.Name = "Accent"
			Accent.BackgroundColor3 = Library.Accent
			Accent.BorderColor3 = Color3.fromRGB(0, 0, 0)
			Accent.BorderSizePixel = 0
			Accent.Size = UDim2.new(1, 0, 0, 1)
			Accent.Parent = Outline

			Library:Connection(Outline.MouseButton1Down, function()
				local Location = game:GetService("UserInputService"):GetMouseLocation()
				Indicator.Dragging[1] = true
				Indicator.Dragging[2] = UDim2.new(0, Location.X - Outline.AbsolutePosition.X, 0, Location.Y - Outline.AbsolutePosition.Y)
			end)
			Library:Connection(game:GetService("UserInputService").InputEnded, function(Input)
				if Input.UserInputType == Enum.UserInputType.MouseButton1 and Indicator.Dragging[1] then
					local Location = game:GetService("UserInputService"):GetMouseLocation()
					Indicator.Dragging[1] = false
					Indicator.Dragging[2] = UDim2.new(0, 0, 0, 0)
				end
			end)
			Library:Connection(game:GetService("UserInputService").InputChanged, function(Input)
				local Location = game:GetService("UserInputService"):GetMouseLocation()
				local ActualLocation = nil

				if Indicator.Dragging[1] then
					Outline.Position = UDim2.new(
						0,
						Location.X - Indicator.Dragging[2].X.Offset + (Outline.Size.X.Offset * Outline.AnchorPoint.X),
						0,
						Location.Y - Indicator.Dragging[2].Y.Offset + (Outline.Size.Y.Offset * Outline.AnchorPoint.Y)
					)
				end
			end)

			
			function Indicator:NewValue(Properties)
				local NewIndicator = {
					Name = Properties.Name or Properties.name or "New Value";
					Value = Properties.Value or Properties.value or "false";
				};
				
				local NewInd = Instance.new("Frame")
				NewInd.Name = "NewInd"
				NewInd.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
				NewInd.BackgroundTransparency = 1
				NewInd.BorderColor3 = Color3.fromRGB(0, 0, 0)
				NewInd.BorderSizePixel = 0
				NewInd.Size = UDim2.new(1, 0, 0, 15)

				local Title = Instance.new("TextLabel")
				Title.Name = "Title"
				Title.Font = Enum.Font.GothamBold
				Title.Text = NewIndicator.Name
				Title.TextColor3 = Color3.fromRGB(255, 255, 255)
				Title.TextSize = 12
				Title.TextStrokeTransparency = 0
				Title.TextXAlignment = Enum.TextXAlignment.Left
				Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
				Title.BackgroundTransparency = 1
				Title.BorderColor3 = Color3.fromRGB(0, 0, 0)
				Title.BorderSizePixel = 0
				Title.Position = UDim2.new(0, 4, 0, 0)
				Title.Size = UDim2.new(1, 0, 1, 0)
				Title.Parent = NewInd

				local IndValue = Instance.new("TextLabel")
				IndValue.Name = "IndValue"
				IndValue.Font = Enum.Font.GothamBold
				IndValue.Text = NewIndicator.Value
				IndValue.TextColor3 = Color3.fromRGB(255, 255, 255)
				IndValue.TextSize = 12
				IndValue.TextStrokeTransparency = 0
				IndValue.TextXAlignment = Enum.TextXAlignment.Right
				IndValue.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
				IndValue.BackgroundTransparency = 1
				IndValue.BorderColor3 = Color3.fromRGB(0, 0, 0)
				IndValue.BorderSizePixel = 0
				IndValue.Position = UDim2.new(0, -4, 0, 0)
				IndValue.Size = UDim2.new(1, 0, 1, 0)
				IndValue.Parent = NewInd

				NewInd.Parent = HolderInline

				
				function NewIndicator:UpdateValue(NewValue)
					IndValue.Text = tostring(NewValue)
				end

				return NewIndicator
			end
			
			function Indicator:NewBar(Properties)
				local NewBarInd = {
					Name = Properties.Name or Properties.name or "New Value";
					Min = (Properties.min or Properties.Min or Properties.minimum or Properties.Minimum or 0);
					Max = (Properties.max or Properties.Max or Properties.maximum or Properties.Maximum or 100);
					State = (Properties.state or Properties.State or Properties.def or Properties.Def or Properties.default or Properties.Default or 0);
				};
				local TextValue = ("[value]")
				
				local NewBar = Instance.new("Frame")
				NewBar.Name = "NewBar"
				NewBar.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
				NewBar.BackgroundTransparency = 1
				NewBar.BorderColor3 = Color3.fromRGB(0, 0, 0)
				NewBar.BorderSizePixel = 0
				NewBar.Size = UDim2.new(1, 0, 0, 25)

				local Title1 = Instance.new("TextLabel")
				Title1.Name = "Title"
				Title1.Font = Enum.Font.GothamBold
				Title1.Text = NewBarInd.Name
				Title1.TextColor3 = Color3.fromRGB(255, 255, 255)
				Title1.TextSize = 12
				Title1.TextStrokeTransparency = 0
				Title1.TextXAlignment = Enum.TextXAlignment.Left
				Title1.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
				Title1.BackgroundTransparency = 1
				Title1.BorderColor3 = Color3.fromRGB(0, 0, 0)
				Title1.BorderSizePixel = 0
				Title1.Position = UDim2.new(0, 4, 0, 0)
				Title1.Size = UDim2.new(1, 0, 0, 15)
				Title1.Parent = NewBar

				local IndValue1 = Instance.new("TextLabel")
				IndValue1.Name = "IndValue"
				IndValue1.Font = Enum.Font.GothamBold
				IndValue1.Text = "0"
				IndValue1.TextColor3 = Color3.fromRGB(255, 255, 255)
				IndValue1.TextSize = 12
				IndValue1.TextStrokeTransparency = 0
				IndValue1.TextXAlignment = Enum.TextXAlignment.Right
				IndValue1.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
				IndValue1.BackgroundTransparency = 1
				IndValue1.BorderColor3 = Color3.fromRGB(0, 0, 0)
				IndValue1.BorderSizePixel = 0
				IndValue1.Position = UDim2.new(0, -4, 0, 0)
				IndValue1.Size = UDim2.new(1, 0, 0, 15)
				IndValue1.Parent = NewBar

				local BarOutline = Instance.new("Frame")
				BarOutline.Name = "BarOutline"
				BarOutline.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
				BarOutline.BorderColor3 = Color3.fromRGB(0, 0, 0)
				BarOutline.Position = UDim2.new(0, 4, 1, -6)
				BarOutline.Size = UDim2.new(1, -8, 0, 6)

				local Bar = Library:NewInstance("Frame", true)
				Bar.Name = "Bar"
				Bar.BackgroundColor3 = Library.Accent
				Bar.BorderColor3 = Color3.fromRGB(0, 0, 0)
				Bar.BorderSizePixel = 0
				Bar.Size = UDim2.new(0.5, 0, 1, 0)
				Bar.Parent = BarOutline

				BarOutline.Parent = NewBar

				NewBar.Parent = HolderInline

				
				function NewBarInd:UpdateValue(NewValue)
					NewValue = math.clamp(Library:Round(NewValue, 1), NewBarInd.Min, NewBarInd.Max)
					local sizeX = ((NewValue - NewBarInd.Min) / (NewBarInd.Max - NewBarInd.Min))
					Bar.Size = UDim2.new(sizeX, 0, 1, 0)
					IndValue1.Text = TextValue:gsub("%[value%]", string.format("%.14g", NewValue))
				end

				NewBarInd:UpdateValue(NewBarInd.State)

				return NewBarInd
			end
			
			function Indicator:SetVisible(State)
				Outline.Visible = State
			end

			return Indicator
		end
	end
end;

local Notifications = {Notifs = {}};
do 
    local NotificationGui = Instance.new("ScreenGui", Path)
    NotificationGui.Name = "ScreenGui"
    NotificationGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
	function Notifications:updateNotifsPositions(position)
		for i, v in pairs(Notifications.Notifs) do 
			local Position = Vector2.new(20, 20)
			game:GetService("TweenService"):Create(v.Container, TweenInfo.new(1, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {Position = UDim2.new(0,Position.X,0,Position.Y + (i * 25))}):Play()
		end 
	end

	function Notifications:Notification(message, duration, color, flash)
		local notification = {Container = nil, Objects = {}}
		
		local Position = Vector2.new(20, 20)
		
		local NewInd = Instance.new("Frame")
		NewInd.Name = "NewInd"
		NewInd.AutomaticSize = Enum.AutomaticSize.X
		NewInd.Position = UDim2.new(0,20,0,20)
		NewInd.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
		NewInd.BackgroundTransparency = 1
		NewInd.BorderColor3 = Color3.fromRGB(0, 0, 0)
		NewInd.Size = UDim2.fromOffset(0, 20)
		NewInd.Parent = NotificationGui
		notification.Container = NewInd

		local ActualInd = Instance.new("Frame")
		ActualInd.Name = "ActualInd"
		ActualInd.AutomaticSize = Enum.AutomaticSize.X
		ActualInd.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
		ActualInd.BorderColor3 = Color3.fromRGB(0, 0, 0)
		ActualInd.Size = UDim2.fromScale(1, 1)
		ActualInd.BackgroundTransparency = 1

		local Accent = Instance.new("Frame")
		Accent.Name = "Accent"
		Accent.BackgroundColor3 = color or Color3.fromRGB(255,255,255)
		Accent.BorderColor3 = Color3.fromRGB(0, 0, 0)
		Accent.Size = UDim2.new(0, 2, 1, 0)
		Accent.ZIndex = 2
		Accent.BackgroundTransparency = 1

		local UIGradient = Instance.new("UIGradient")
		UIGradient.Name = "UIGradient"
		UIGradient.Color = ColorSequence.new({
			ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(55, 55, 55)),
		})
		UIGradient.Parent = Accent

		Accent.Parent = ActualInd

		local IndInline = Instance.new("Frame")
		IndInline.Name = "IndInline"
		IndInline.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
		IndInline.BorderColor3 = Color3.fromRGB(0, 0, 0)
		IndInline.BorderSizePixel = 0
		IndInline.Position = UDim2.fromOffset(1, 1)
		IndInline.Size = UDim2.new(1, -2, 1, -2)
		IndInline.BackgroundTransparency = 1

		local UIGradient1 = Instance.new("UIGradient")
		UIGradient1.Name = "UIGradient"
		UIGradient1.Color = ColorSequence.new({
			ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(170, 170, 170)),
		})
		UIGradient1.Rotation = 90
		UIGradient1.Parent = IndInline

		local TextLabel = Instance.new("TextLabel")
		TextLabel.Name = "TextLabel"
		TextLabel.Font = Enum.Font.GothamBold
		TextLabel.Text = message
		TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		TextLabel.TextSize = 13
		TextLabel.TextStrokeTransparency = 0
		TextLabel.AutomaticSize = Enum.AutomaticSize.X
		TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		TextLabel.BackgroundTransparency = 1
		TextLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
		TextLabel.BorderSizePixel = 0
		TextLabel.Position = UDim2.fromOffset(6, 0)
		TextLabel.Size = UDim2.fromScale(0, 1)
		TextLabel.Parent = IndInline
		TextLabel.TextTransparency = 1

		local UIPadding = Instance.new("UIPadding")
		UIPadding.Name = "UIPadding"
		UIPadding.PaddingRight = UDim.new(0, 6)
		UIPadding.Parent = IndInline

		IndInline.Parent = ActualInd

		ActualInd.Parent = NewInd


		function notification:remove()
			table.remove(Notifications.Notifs, table.find(Notifications.Notifs, notification))
			Notifications:updateNotifsPositions(Position)
			task.wait(0.5)
			NewInd:Destroy()
		end

		function notification:updatetext(new)
			TextLabel.Text = new
		end

		task.spawn(function()
			ActualInd.AnchorPoint = Vector2.new(1,0)
			for i,v in next, NewInd:GetDescendants() do
				if v:IsA("Frame") then
					game:GetService("TweenService"):Create(v, TweenInfo.new(1, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {BackgroundTransparency = 0}):Play()
				elseif v:IsA("UIStroke") then
					game:GetService("TweenService"):Create(v, TweenInfo.new(1, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {Transparency = 0.8}):Play()
				end
			end
			local Tween1 = game:GetService("TweenService"):Create(ActualInd, TweenInfo.new(1, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {AnchorPoint = Vector2.new(0,0)}):Play()
			game:GetService("TweenService"):Create(TextLabel, TweenInfo.new(1, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {TextTransparency = 0}):Play()
			task.wait(duration)
			for i,v in next, NewInd:GetDescendants() do
				if v:IsA("Frame") then
					game:GetService("TweenService"):Create(v, TweenInfo.new(1, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {BackgroundTransparency = 1}):Play()
				elseif v:IsA("UIStroke") then
					game:GetService("TweenService"):Create(v, TweenInfo.new(1, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {Transparency = 1}):Play()
				end
			end
			game:GetService("TweenService"):Create(TextLabel, TweenInfo.new(1, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {TextTransparency = 1}):Play()
		end)

		task.delay(duration + 0.1, function()
			notification:remove()
		end)

		
		if flash then
			local time = 0 
			task.spawn(function()
				while task.wait() do
					local progress = (math.sin(2 * math.pi * 2 * time) + 1) / 2;
					local value = color:Lerp(Color3.fromRGB(0, 0, 0), progress)

					Accent.BackgroundColor3 = value

					time = time + 0.01;
				end
			end)
		end

		table.insert(Notifications.Notifs, notification)
		Notifications:updateNotifsPositions(Position)
		NewInd.Position = UDim2.new(0,Position.X,0,Position.Y + (table.find(Notifications.Notifs, notification) * 25))
		return notification
	end
end

local Window = Library:Window({})
Notifications:Notification("Cheat Succsesfully Loaded!",5, Library.Accent, false)
do 
	local Pages = {
		["Aiming"] = Window:Page({Name = "Combat", Icon = "rbxassetid://6034509987"});
		["Antiaim"] = Window:Page({Name = "Anti-Aim", Icon = "rbxassetid://17134553802"});
		["Renders"] = Window:Page({Name = "Esps", Icon = "rbxassetid://6034281935"});
		["Misc"] = Window:Page({Name = "Misc", Icon = "rbxassetid://6031079158"});
		["Movement"] = Window:Page({Name = "Movement", Icon = "rbxassetid://7999345313"});

		["Settings"] = Window:Page({Name = "Settings", Icon = "rbxassetid://6031280882"});
	} 
	 
	do 
		do
			do 

Enabled = Pages["Aiming"]:Section({Name = "Main", Side = "Left", Zindex = 5})

soundEnabled = false
notificationEnabled = false
playerTrackingEnabled = false
soundVolume = 0.5
function playToggleSound(isEnabled)
    if not soundEnabled then return end
    local sound = Instance.new("Sound")
    sound.SoundId = "rbxassetid://15675059323"
    sound.Parent = game:GetService("SoundService")
    sound.PlaybackSpeed = isEnabled and 1 or 0.9
    sound.Volume = soundVolume 
    sound:Play()
    sound.Ended:Connect(function()
        sound:Destroy()
    end)
end


function showToggleNotification(toggleName, isEnabled)
    if not notificationEnabled then return end
    Notifications:Notification(
        toggleName .. ": " .. (isEnabled and "Enabled" or "Disabled"),
        5,
        Library.Accent,
        false
    )
end
G2L = {}

G2L.a = Instance.new("ScreenGui", game.Players.LocalPlayer:WaitForChild("PlayerGui"))
G2L.a.Name = "TargetInfo"
G2L.a.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
G2L.a.ResetOnSpawn = false
G2L.a.Enabled = false

G2L.b = Instance.new("Frame", G2L.a)
G2L.b.BorderSizePixel = 0
G2L.b.BackgroundColor3 = Color3.fromRGB(23, 23, 23)
G2L.b.Size = UDim2.new(0, 212, 0, 272)
G2L.b.Position = UDim2.new(0.09416, 0, 0.31178, -1)
G2L.b.BorderColor3 = Color3.new()
G2L.b.Name = "MainFrame"
G2L.b.BackgroundTransparency = 1

G2L.c = Instance.new("UIStroke", G2L.b)
G2L.c.Color = Color3.fromRGB(51, 51, 51)
G2L.c.Transparency = 1

G2L["15"] = Instance.new("UIDragDetector", G2L.b)

G2L.d = Instance.new("Frame", G2L.b)
G2L.d.BorderSizePixel = 0
G2L.d.BackgroundColor3 = Color3.fromRGB(116, 101, 216)
G2L.d.Size = UDim2.new(0.04245, 203, 0.01, 0)
G2L.d.BorderColor3 = Color3.new()
G2L.d.Name = "DecorativeFrame"
G2L.d.BackgroundTransparency = 1

G2L.e = Instance.new("Frame", G2L.b)
G2L.e.BorderSizePixel = 0
G2L.e.BackgroundColor3 = Color3.fromRGB(16, 16, 16)
G2L.e.Size = UDim2.new(0, 202, 0, -258)
G2L.e.Position = UDim2.new(0.02358, 0, 0.97426, 0)
G2L.e.BorderColor3 = Color3.new()
G2L.e.Name = "HolderName"
G2L.e.BackgroundTransparency = 1

G2L.f = Instance.new("UIStroke", G2L.e)
G2L.f.Color = Color3.fromRGB(51, 51, 51)
G2L.f.Transparency = 1

G2L.g = Instance.new("TextLabel", G2L.e)
G2L.g.BorderSizePixel = 0
G2L.g.TextSize = 14
G2L.g.BackgroundColor3 = Color3.new(1, 1, 1)
G2L.g.FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json")
G2L.g.TextColor3 = Color3.fromRGB(223, 223, 223)
G2L.g.BackgroundTransparency = 1
G2L.g.Size = UDim2.new(0, 49, 0, 23)
G2L.g.BorderColor3 = Color3.new()
G2L.g.Text = "Name:"
G2L.g.Position = UDim2.new(0.02, 0, 0.02713, 0)
G2L.g.TextTransparency = 1

G2L.h = Instance.new("TextLabel", G2L.e)
G2L.h.AnchorPoint = Vector2.new(1, 0)
G2L.h.BorderSizePixel = 0
G2L.h.TextSize = 14
G2L.h.BackgroundColor3 = Color3.new(1, 1, 1)
G2L.h.TextDirection = Enum.TextDirection.RightToLeft
G2L.h.FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json")
G2L.h.TextColor3 = Color3.fromRGB(223, 223, 223)
G2L.h.BackgroundTransparency = 1
G2L.h.Size = UDim2.new(0, 140, 0, 23)
G2L.h.BorderColor3 = Color3.new()
G2L.h.Text = "TargetName"
G2L.h.Name = "TargetName"
G2L.h.Position = UDim2.new(0.99, -5, 0.03876, 0)
G2L.h.TextXAlignment = Enum.TextXAlignment.Right
G2L.h.TextTransparency = 1

G2L.i = Instance.new("TextLabel", G2L.e)
G2L.i.SizeConstraint = Enum.SizeConstraint.RelativeXX
G2L.i.BorderSizePixel = 0
G2L.i.AutoLocalize = false
G2L.i.TextSize = 14
G2L.i.BackgroundColor3 = Color3.new(1, 1, 1)
G2L.i.FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json")
G2L.i.TextColor3 = Color3.fromRGB(223, 223, 223)
G2L.i.BackgroundTransparency = 1
G2L.i.Size = UDim2.new(0, 40, 0, 27)
G2L.i.BorderColor3 = Color3.new()
G2L.i.Text = "HP:"
G2L.i.Position = UDim2.new(0.02, 0, 0.08, 0)
G2L.i.TextTransparency = 1

G2L.j = Instance.new("TextLabel", G2L.e)
G2L.j.AnchorPoint = Vector2.new(1, 0)
G2L.j.SizeConstraint = Enum.SizeConstraint.RelativeXX
G2L.j.BorderSizePixel = 0
G2L.j.AutoLocalize = false
G2L.j.TextSize = 14
G2L.j.BackgroundColor3 = Color3.new(1, 1, 1)
G2L.j.TextDirection = Enum.TextDirection.RightToLeft
G2L.j.FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json")
G2L.j.TextColor3 = Color3.fromRGB(223, 223, 223)
G2L.j.BackgroundTransparency = 1
G2L.j.Size = UDim2.new(0, 50, 0, 27)
G2L.j.BorderColor3 = Color3.new()
G2L.j.Text = "0"
G2L.j.Name = "TargetHealthText"
G2L.j.Position = UDim2.new(0.99, -5, 0.08, 0)
G2L.j.TextXAlignment = Enum.TextXAlignment.Right
G2L.j.TextTransparency = 1

G2L.k = Instance.new("Frame", G2L.e)
G2L.k.BorderSizePixel = 0
G2L.k.BackgroundColor3 = Color3.fromRGB(11, 11, 11)
G2L.k.Size = UDim2.new(0, 190, 0, 11)
G2L.k.Position = UDim2.new(0.04, 0, 0.175, 0)
G2L.k.BorderColor3 = Color3.new()
G2L.k.Name = "Healthbarempty"
G2L.k.BackgroundTransparency = 1

G2L.l = Instance.new("UICorner", G2L.k)
G2L.l.CornerRadius = UDim.new(0, 2)

G2L.m = Instance.new("UIStroke", G2L.k)
G2L.m.Color = Color3.fromRGB(32, 32, 32)
G2L.m.Transparency = 1

G2L.n = Instance.new("TextLabel", G2L.e)
G2L.n.SizeConstraint = Enum.SizeConstraint.RelativeXX
G2L.n.BorderSizePixel = 0
G2L.n.AutoLocalize = false
G2L.n.TextSize = 14
G2L.n.BackgroundColor3 = Color3.new(1, 1, 1)
G2L.n.FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json")
G2L.n.TextColor3 = Color3.fromRGB(223, 223, 223)
G2L.n.BackgroundTransparency = 1
G2L.n.Size = UDim2.new(0, 40, 0, 27)
G2L.n.BorderColor3 = Color3.new()
G2L.n.Text = "KDR:"
G2L.n.Position = UDim2.new(0.02, 0, 0.20682, 0)
G2L.n.TextTransparency = 1

G2L.o = Instance.new("TextLabel", G2L.e)
G2L.o.AnchorPoint = Vector2.new(1, 0)
G2L.o.SizeConstraint = Enum.SizeConstraint.RelativeXX
G2L.o.BorderSizePixel = 0
G2L.o.AutoLocalize = false
G2L.o.TextSize = 14
G2L.o.BackgroundColor3 = Color3.new(1, 1, 1)
G2L.o.TextDirection = Enum.TextDirection.RightToLeft
G2L.o.FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json")
G2L.o.TextColor3 = Color3.fromRGB(223, 223, 223)
G2L.o.BackgroundTransparency = 1
G2L.o.Size = UDim2.new(0, 50, 0, 27)
G2L.o.BorderColor3 = Color3.new()
G2L.o.Text = "0"
G2L.o.Name = "TargetKDR"
G2L.o.Position = UDim2.new(0.99, -5, 0.2071, 0)
G2L.o.TextXAlignment = Enum.TextXAlignment.Right
G2L.o.TextTransparency = 1

G2L.p = Instance.new("Frame", G2L.e)
G2L.p.ZIndex = 2
G2L.p.BorderSizePixel = 0
G2L.p.BackgroundColor3 = Color3.fromRGB(116, 101, 216)
G2L.p.Size = UDim2.new(0, 190, 0, 11)
G2L.p.Position = UDim2.new(0.04, 0, 0.175, 0)
G2L.p.BorderColor3 = Color3.new()
G2L.p.Name = "HealthBar"
G2L.p.BackgroundTransparency = 1

G2L.q = Instance.new("UICorner", G2L.p)
G2L.q.CornerRadius = UDim.new(0, 2)

G2L.r = Instance.new("UIStroke", G2L.p)
G2L.r.Color = Color3.fromRGB(32, 32, 32)
G2L.r.Transparency = 1

G2L.s = Instance.new("ScrollingFrame", G2L.e)
G2L.s.BorderSizePixel = 0
G2L.s.BackgroundColor3 = Color3.fromRGB(16, 16, 16)
G2L.s.Size = UDim2.new(0, 190, 0, 167)
G2L.s.Position = UDim2.new(0.0297, 0, 0.32171, 0)
G2L.s.BorderColor3 = Color3.new()
G2L.s.Name = "InventoryHolder"
G2L.s.ScrollBarThickness = 1
G2L.s.CanvasPosition = Vector2.new()
G2L.s.BackgroundTransparency = 1

G2L.t = Instance.new("UIStroke", G2L.s)
G2L.t.Color = Color3.fromRGB(32, 32, 32)
G2L.t.Transparency = 1

G2L.u = Instance.new("UIListLayout", G2L.s)
G2L.u.Padding = UDim.new(0, 0)
G2L.u.SortOrder = Enum.SortOrder.LayoutOrder
G2L.u.FillDirection = Enum.FillDirection.Vertical
G2L.u.HorizontalAlignment = Enum.HorizontalAlignment.Right

G2L = {}


local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local Workspace = workspace
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local Bullet = require(ReplicatedStorage.Modules.FPS.Bullet)


G2L.a = Instance.new("ScreenGui", LocalPlayer:WaitForChild("PlayerGui"))
G2L.a.Name = "TargetInfo"
G2L.a.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
G2L.a.ResetOnSpawn = false
G2L.a.Enabled = false

G2L.b = Instance.new("Frame", G2L.a)
G2L.b.BorderSizePixel = 0
G2L.b.BackgroundColor3 = Color3.fromRGB(23, 23, 23)
G2L.b.Size = UDim2.new(0, 212, 0, 272)
G2L.b.Position = UDim2.new(0.09416, 0, 0.31178, -1)
G2L.b.Name = "MainFrame"
G2L.b.BackgroundTransparency = 1

G2L.c = Instance.new("UIStroke", G2L.b)
G2L.c.Color = Color3.fromRGB(51, 51, 51)
G2L.c.Transparency = 1

G2L["15"] = Instance.new("UIDragDetector", G2L.b)

G2L.d = Instance.new("Frame", G2L.b)
G2L.d.BorderSizePixel = 0
G2L.d.BackgroundColor3 = Color3.fromRGB(116, 101, 216)
G2L.d.Size = UDim2.new(0.04245, 203, 0.01, 0)
G2L.d.Name = "DecorativeFrame"
G2L.d.BackgroundTransparency = 1

G2L.e = Instance.new("Frame", G2L.b)
G2L.e.BorderSizePixel = 0
G2L.e.BackgroundColor3 = Color3.fromRGB(16, 16, 16)
G2L.e.Size = UDim2.new(0, 202, 0, -258)
G2L.e.Position = UDim2.new(0.02358, 0, 0.97426, 0)
G2L.e.Name = "HolderName"
G2L.e.BackgroundTransparency = 1

G2L.f = Instance.new("UIStroke", G2L.e)
G2L.f.Color = Color3.fromRGB(51, 51, 51)
G2L.f.Transparency = 1

local SourceSansPro = Font.new("rbxasset://fonts/families/SourceSansPro.json")
G2L.g = Instance.new("TextLabel", G2L.e)
G2L.g.BorderSizePixel = 0
G2L.g.TextSize = 14
G2L.g.BackgroundColor3 = Color3.new(1, 1, 1)
G2L.g.FontFace = SourceSansPro
G2L.g.TextColor3 = Color3.fromRGB(223, 223, 223)
G2L.g.BackgroundTransparency = 1
G2L.g.Size = UDim2.new(0, 49, 0, 23)
G2L.g.Text = "Name:"
G2L.g.Position = UDim2.new(0.02, 0, 0.02713, 0)
G2L.g.TextTransparency = 1

G2L.h = Instance.new("TextLabel", G2L.e)
G2L.h.AnchorPoint = Vector2.new(1, 0)
G2L.h.BorderSizePixel = 0
G2L.h.TextSize = 14
G2L.h.BackgroundColor3 = Color3.new(1, 1, 1)
G2L.h.TextDirection = Enum.TextDirection.RightToLeft
G2L.h.FontFace = SourceSansPro
G2L.h.TextColor3 = Color3.fromRGB(223, 223, 223)
G2L.h.BackgroundTransparency = 1
G2L.h.Size = UDim2.new(0, 140, 0, 23)
G2L.h.Text = "TargetName"
G2L.h.Name = "TargetName"
G2L.h.Position = UDim2.new(0.99, -5, 0.03876, 0)
G2L.h.TextXAlignment = Enum.TextXAlignment.Right
G2L.h.TextTransparency = 1

G2L.i = Instance.new("TextLabel", G2L.e)
G2L.i.SizeConstraint = Enum.SizeConstraint.RelativeXX
G2L.i.BorderSizePixel = 0
G2L.i.AutoLocalize = false
G2L.i.TextSize = 14
G2L.i.BackgroundColor3 = Color3.new(1, 1, 1)
G2L.i.FontFace = SourceSansPro
G2L.i.TextColor3 = Color3.fromRGB(223, 223, 223)
G2L.i.BackgroundTransparency = 1
G2L.i.Size = UDim2.new(0, 40, 0, 27)
G2L.i.Text = "HP:"
G2L.i.Position = UDim2.new(0.02, 0, 0.08, 0)
G2L.i.TextTransparency = 1

G2L.j = Instance.new("TextLabel", G2L.e)
G2L.j.AnchorPoint = Vector2.new(1, 0)
G2L.j.SizeConstraint = Enum.SizeConstraint.RelativeXX
G2L.j.BorderSizePixel = 0
G2L.j.AutoLocalize = false
G2L.j.TextSize = 14
G2L.j.BackgroundColor3 = Color3.new(1, 1, 1)
G2L.j.TextDirection = Enum.TextDirection.RightToLeft
G2L.j.FontFace = SourceSansPro
G2L.j.TextColor3 = Color3.fromRGB(223, 223, 223)
G2L.j.BackgroundTransparency = 1
G2L.j.Size = UDim2.new(0, 50, 0, 27)
G2L.j.Text = "0"
G2L.j.Name = "TargetHealthText"
G2L.j.Position = UDim2.new(0.99, -5, 0.08, 0)
G2L.j.TextXAlignment = Enum.TextXAlignment.Right
G2L.j.TextTransparency = 1

G2L.k = Instance.new("Frame", G2L.e)
G2L.k.BorderSizePixel = 0
G2L.k.BackgroundColor3 = Color3.fromRGB(11, 11, 11)
G2L.k.Size = UDim2.new(0, 190, 0, 11)
G2L.k.Position = UDim2.new(0.04, 0, 0.175, 0)
G2L.k.Name = "Healthbarempty"
G2L.k.BackgroundTransparency = 1

G2L.l = Instance.new("UICorner", G2L.k)
G2L.l.CornerRadius = UDim.new(0, 2)

G2L.m = Instance.new("UIStroke", G2L.k)
G2L.m.Color = Color3.fromRGB(32, 32, 32)
G2L.m.Transparency = 1

G2L.n = Instance.new("TextLabel", G2L.e)
G2L.n.SizeConstraint = Enum.SizeConstraint.RelativeXX
G2L.n.BorderSizePixel = 0
G2L.n.AutoLocalize = false
G2L.n.TextSize = 14
G2L.n.BackgroundColor3 = Color3.new(1, 1, 1)
G2L.n.FontFace = SourceSansPro
G2L.n.TextColor3 = Color3.fromRGB(223, 223, 223)
G2L.n.BackgroundTransparency = 1
G2L.n.Size = UDim2.new(0, 40, 0, 27)
G2L.n.Text = "KDR:"
G2L.n.Position = UDim2.new(0.02, 0, 0.20682, 0)
G2L.n.TextTransparency = 1

G2L.o = Instance.new("TextLabel", G2L.e)
G2L.o.AnchorPoint = Vector2.new(1, 0)
G2L.o.SizeConstraint = Enum.SizeConstraint.RelativeXX
G2L.o.BorderSizePixel = 0
G2L.o.AutoLocalize = false
G2L.o.TextSize = 14
G2L.o.BackgroundColor3 = Color3.new(1, 1, 1)
G2L.o.TextDirection = Enum.TextDirection.RightToLeft
G2L.o.FontFace = SourceSansPro
G2L.o.TextColor3 = Color3.fromRGB(223, 223, 223)
G2L.o.BackgroundTransparency = 1
G2L.o.Size = UDim2.new(0, 50, 0, 27)
G2L.o.Text = "0"
G2L.o.Name = "TargetKDR"
G2L.o.Position = UDim2.new(0.99, -5, 0.2071, 0)
G2L.o.TextXAlignment = Enum.TextXAlignment.Right
G2L.o.TextTransparency = 1

G2L.p = Instance.new("Frame", G2L.e)
G2L.p.ZIndex = 2
G2L.p.BorderSizePixel = 0
G2L.p.BackgroundColor3 = Color3.fromRGB(116, 101, 216)
G2L.p.Size = UDim2.new(0, 190, 0, 11)
G2L.p.Position = UDim2.new(0.04, 0, 0.175, 0)
G2L.p.Name = "HealthBar"
G2L.p.BackgroundTransparency = 1

G2L.q = Instance.new("UICorner", G2L.p)
G2L.q.CornerRadius = UDim.new(0, 2)

G2L.r = Instance.new("UIStroke", G2L.p)
G2L.r.Color = Color3.fromRGB(32, 32, 32)
G2L.r.Transparency = 1

G2L.s = Instance.new("ScrollingFrame", G2L.e)
G2L.s.BorderSizePixel = 0
G2L.s.BackgroundColor3 = Color3.fromRGB(16, 16, 16)
G2L.s.Size = UDim2.new(0, 190, 0, 167)
G2L.s.Position = UDim2.new(0.0297, 0, 0.32171, 0)
G2L.s.Name = "InventoryHolder"
G2L.s.ScrollBarThickness = 1
G2L.s.CanvasPosition = Vector2.new()
G2L.s.BackgroundTransparency = 1

G2L.t = Instance.new("UIStroke", G2L.s)
G2L.t.Color = Color3.fromRGB(32, 32, 32)
G2L.t.Transparency = 1

G2L.u = Instance.new("UIListLayout", G2L.s)
G2L.u.Padding = UDim.new(0, 0)
G2L.u.SortOrder = Enum.SortOrder.LayoutOrder
G2L.u.FillDirection = Enum.FillDirection.Vertical
G2L.u.HorizontalAlignment = Enum.HorizontalAlignment.Right

aimbool = false
aimselftrack = true
aimbots = false
aimvischeck = false
aimmousefov = false
aimfakewait = true
aimpart = "Head"
aimfov = 150
aimchance = 100
aimtarget = nil
aimtargetpart = nil
aimfovcircle = Drawing.new("Circle")
aimfovcircle_outer = Drawing.new("Circle")
aimfovcircle_inner = Drawing.new("Circle")
aimfovcircle_fill = Drawing.new("Circle")
aimogfunc = Bullet.CreateBullet
aimignoreparts = {}
aimfriendcheck = false
hitsoundvolume = 0.5
a1table = nil
aimfovfill_enabled = false
aimfovfill_transparency = 0.3
targetui_enabled = false
last_target_update = 0
target_update_cooldown = 0.1
last_health = 0
last_target = nil
last_ui_pos = G2L.b.Position
last_aimtarget = nil
is_ui_visible = false
tweening = false
replicatedPlayers = ReplicatedStorage:WaitForChild("Players")
showTweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
hideTweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
multibullet = false
multibullet_count = 1
aimfovcircle_numsides = 32
selftrack_data = {}
selftrack_update = 0
hitmarkbool = false
hitsoundbool = false
hitsoundhead = "Gamesense"
hitsoundlib = {
    Gamesense = "rbxassetid://4817809188",
    Rust = "rbxassetid://1255040462",
    Neverlose = "rbxassetid://8726881116",
    Bubble = "rbxassetid://198598793",
    Fatality = "rbxassetid://6534947869"
}
tracbool = true
tracwait = 2
traccolor = Color3.new(1, 1, 1)
tractexture = nil
tractextures = {
    Glow = "http://www.roblox.com/asset/?id=78260707920108",
    Lighting = "http://www.roblox.com/asset/?id=131326755401058"
}
globalcurrentgun = nil
globalammo = nil
hitmarkcolor_new = Color3.new(1, 1, 1)
fovcircle_enabled = false

aimfovcircle.Visible = false
aimfovcircle.Radius = aimfov
aimfovcircle.Thickness = 2
aimfovcircle.Filled = false
aimfovcircle.Transparency = 0.5
aimfovcircle.Color = Color3.new(1, 1, 1)
aimfovcircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
aimfovcircle.NumSides = aimfovcircle_numsides

aimfovcircle_outer.Visible = false
aimfovcircle_outer.Radius = aimfov + 1
aimfovcircle_outer.Thickness = 1
aimfovcircle_outer.Filled = false
aimfovcircle_outer.Transparency = 1
aimfovcircle_outer.Color = Color3.new()
aimfovcircle_outer.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
aimfovcircle_outer.NumSides = aimfovcircle_numsides

aimfovcircle_inner.Visible = false
aimfovcircle_inner.Radius = aimfov - 1
aimfovcircle_inner.Thickness = 1
aimfovcircle_inner.Filled = false
aimfovcircle_inner.Transparency = 1
aimfovcircle_inner.Color = Color3.new()
aimfovcircle_inner.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
aimfovcircle_inner.NumSides = aimfovcircle_numsides

aimfovcircle_fill.Visible = false
aimfovcircle_fill.Radius = aimfov
aimfovcircle_fill.Filled = true
aimfovcircle_fill.Transparency = aimfovfill_transparency
aimfovcircle_fill.Color = aimfovcircle.Color
aimfovcircle_fill.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
aimfovcircle_fill.NumSides = aimfovcircle_numsides

uiFrames = {G2L.b, G2L.d, G2L.e, G2L.k, G2L.p, G2L.s}
uiStrokes = {G2L.c, G2L.f, G2L.m, G2L.r, G2L.t}
uiTextLabels = {G2L.g, G2L.h, G2L.i, G2L.j, G2L.n, G2L.o}

for _, v in ipairs(Workspace:GetDescendants()) do
    if v:GetAttribute("PassThrough") then
        table.insert(aimignoreparts, v)
    end
end

for i = 10, 1000, 10 do
    selftrack_data[i] = LocalPlayer.Character and LocalPlayer.Character.HumanoidRootPart and LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, 1.3, 0) or Vector3.zero
end

function showUI()
    if tweening or is_ui_visible then return end
    tweening = true
    G2L.a.Enabled = true
    G2L.b.Position = last_ui_pos
    for _, frame in ipairs(uiFrames) do
        frame.BackgroundTransparency = 1
    end
    for _, stroke in ipairs(uiStrokes) do
        stroke.Transparency = 1
    end
    for _, label in ipairs(uiTextLabels) do
        label.TextTransparency = 1
    end
    for _, v in ipairs(G2L.s:GetChildren()) do
        if v:IsA("TextLabel") then
            v.TextTransparency = 1
        end
    end
    local tweensList = {}
    for _, frame in ipairs(uiFrames) do
        table.insert(tweensList, TweenService:Create(frame, showTweenInfo, {BackgroundTransparency = 0}))
    end
    for _, stroke in ipairs(uiStrokes) do
        table.insert(tweensList, TweenService:Create(stroke, showTweenInfo, {Transparency = 0}))
    end
    for _, label in ipairs(uiTextLabels) do
        table.insert(tweensList, TweenService:Create(label, showTweenInfo, {TextTransparency = 0}))
    end
    for _, v in ipairs(G2L.s:GetChildren()) do
        if v:IsA("TextLabel") then
            table.insert(tweensList, TweenService:Create(v, showTweenInfo, {TextTransparency = 0}))
        end
    end
    for _, tween in ipairs(tweensList) do
        tween:Play()
    end
    task.delay(0.2, function()
        tweening = false
        is_ui_visible = true
    end)
end

function hideUI()
    if tweening or not is_ui_visible then return end
    tweening = true
    G2L.b.Position = last_ui_pos
    local tweensList = {}
    for _, frame in ipairs(uiFrames) do
        table.insert(tweensList, TweenService:Create(frame, hideTweenInfo, {BackgroundTransparency = 1}))
    end
    for _, stroke in ipairs(uiStrokes) do
        table.insert(tweensList, TweenService:Create(stroke, hideTweenInfo, {Transparency = 1}))
    end
    for _, label in ipairs(uiTextLabels) do
        table.insert(tweensList, TweenService:Create(label, hideTweenInfo, {TextTransparency = 1}))
    end
    for _, v in ipairs(G2L.s:GetChildren()) do
        if v:IsA("TextLabel") then
            table.insert(tweensList, TweenService:Create(v, hideTweenInfo, {TextTransparency = 1}))
        end
    end
    for _, tween in ipairs(tweensList) do
        tween:Play()
    end
    task.delay(0.2, function()
        G2L.a.Enabled = false
        tweening = false
        is_ui_visible = false
    end)
end

function getcurrentgun(plr)
    local char = plr.Character
    if not char then return nil, nil, nil end
    local invchar = replicatedPlayers:FindFirstChild(LocalPlayer.Name).Inventory
    if not invchar then return nil, nil, nil end
    for _, desc in ipairs(char:GetDescendants()) do
        if desc:IsA("Model") and desc:FindFirstChild("ItemRoot") and desc:FindFirstChild("Attachments") then
            return desc.Name, desc, invchar:FindFirstChild(desc.Name)
        end
    end
    return nil, nil, nil
end

function getcurrentammo(gun)
    if not gun then return nil end
    local loadedfold = gun:FindFirstChild("LoadedAmmo", true)
    if not loadedfold then return nil end
    local firstammo = loadedfold:FindFirstChild("1")
    if not firstammo then return nil end
    return ReplicatedStorage.AmmoTypes:FindFirstChild(firstammo:GetAttribute("AmmoType"))
end

function get_ammo_in_magazine()
    local Player = replicatedPlayers:FindFirstChild(LocalPlayer.Name)
    if not Player then return 0 end
    local weapon = Player.Status and Player.Status.GameplayVariables and Player.Status.GameplayVariables.EquippedTool and Player.Status.GameplayVariables.EquippedTool.Value
    if not weapon or weapon == "None" then return 0 end
    local inv_weapon = Player.Inventory and Player.Inventory:FindFirstChild(weapon.Name)
    local magazine = inv_weapon and inv_weapon.Attachments and inv_weapon.Attachments.Magazine and inv_weapon.Attachments.Magazine:FindFirstChildOfClass("StringValue")
    local loadedammo = magazine and magazine.ItemProperties and magazine.ItemProperties.LoadedAmmo and magazine.ItemProperties.LoadedAmmo:FindFirstChildOfClass("Folder")
    return loadedammo and loadedammo:GetAttribute("Amount") or 0
end

function runtracer(start, endp)
    if start == Vector3.zero or endp == Vector3.zero then return end
    local beam = Instance.new("Beam", Workspace)
    beam.Name = "LineBeam"
    local startpart = Instance.new("Part", Workspace)
    startpart.CanCollide = false
    startpart.CanQuery = false
    startpart.Transparency = 1
    startpart.Position = start
    startpart.Anchored = true
    startpart.Size = Vector3.new(0.01, 0.01, 0.01)
    local endpart = Instance.new("Part", Workspace)
    endpart.CanCollide = false
    endpart.CanQuery = false
    endpart.Transparency = 1
    endpart.Position = endp
    endpart.Anchored = true
    endpart.Size = Vector3.new(0.01, 0.01, 0.01)
    beam.Attachment0 = Instance.new("Attachment", startpart)
    beam.Attachment1 = Instance.new("Attachment", endpart)
    beam.Color = ColorSequence.new(traccolor)
    beam.Width0 = 0.15
    beam.Width1 = 0.15
    beam.FaceCamera = true
    beam.Transparency = NumberSequence.new(0)
    beam.LightEmission = 1
    if tractexture then
        beam.Texture = tractexture
        if tractexture == tractextures.Lighting then
            beam.TextureSpeed = 3
            beam.TextureLength = (endp - start).Magnitude
            beam.Width0 = 0.3
            beam.Width1 = 0.3
        end
    end
    task.delay(tracwait, function()
        beam:Destroy()
        startpart:Destroy()
        endpart:Destroy()
    end)
end

function isonscreen(object)
    local _, onScreen = Camera:WorldToScreenPoint(object.Position)
    return onScreen
end

UniversalTables = require(ReplicatedStorage.Modules:WaitForChild("UniversalTables"))
globalist11 = UniversalTables.ReturnTable("GlobalIgnoreListProjectile")
function isvisible(char, object)
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or not aimvischeck then
        return true
    end
    local origin = LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, 1.3, 0)
    if aimselftrack then
        local plrping = LocalPlayer:GetNetworkPing() * 1000 + 5
        local key = math.floor(plrping / 10) * 10
        local onv = selftrack_data[key]
        if onv then origin = onv end
    end
    if not origin then return false end
    local params = RaycastParams.new()
    params.IgnoreWater = true
    params.CollisionGroup = "WeaponRay"
    params.FilterDescendantsInstances = {LocalPlayer.Character, Camera, globalist11, unpack(aimignoreparts)}
    local dir = (object.Position - origin).Unit
    local dist = (object.Position - origin).Magnitude + 5
    local ray = Workspace:Raycast(origin, dir * dist, params)
    if ray and ray.Instance:IsDescendantOf(char) then
        return true
    elseif ray and ray.Instance.Name ~= "Terrain" and not ray.Instance:GetAttribute("NoPen") then
        local armorpen4 = globalammo and globalammo:GetAttribute("ArmorPen") or 10
        local FunctionLibraryExtension = require(ReplicatedStorage.Modules.FunctionLibraryExtension)
        local armorpen1, newpos2 = FunctionLibraryExtension.Penetration(FunctionLibraryExtension, ray.Instance, ray.Position, dir, armorpen4)
        if not armorpen1 or not newpos2 then return false end
        local neworigin = ray.Position + dir * 0.01
        local newray = Workspace:Raycast(neworigin, dir * (dist - (neworigin - origin).Magnitude), params)
        return newray and newray.Instance:IsDescendantOf(char)
    end
    return false
end

function IsFriend(player)
    return LocalPlayer:IsFriendsWith(player.UserId)
end

function choosetarget()
    if tick() - last_target_update < target_update_cooldown then return end
    last_target_update = tick()
    local cent = aimmousefov and UserInputService:GetMouseLocation() or Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local cdist = math.huge
    local ctar, cpart
    local function chooseTpart(charact)
        return charact:FindFirstChild(aimpart == "Head" and "Head" or aimpart == "HeadTop" and "HeadTopHitBox" or aimpart == "Face" and "FaceHitBox" or aimpart == "Torso" and "UpperTorso" or "HumanoidRootPart")
    end
    if aimbots then
        for _, botfold in ipairs(Workspace.AiZones:GetChildren()) do
            for _, bot in ipairs(botfold:GetChildren()) do
                if bot:IsA("Model") and bot:FindFirstChild("Humanoid") and bot.Humanoid.Health > 0 then
                    local potroot = chooseTpart(bot)
                    if potroot and LocalPlayer.Character then
                        local spoint = Camera:WorldToViewportPoint(potroot.Position)
                        local dist = (Vector2.new(spoint.X, spoint.Y) - cent).Magnitude
                        if dist <= aimfovcircle.Radius and dist < cdist and isvisible(bot, potroot) and isonscreen(potroot) then
                            cdist = dist
                            ctar = bot
                            cpart = potroot
                        end
                    end
                end
            end
        end
    end
    for _, pottar in ipairs(Players:GetPlayers()) do
        if pottar ~= LocalPlayer and pottar.Character and LocalPlayer.Character.PrimaryPart and (not aimfriendcheck or not IsFriend(pottar)) then
            local potroot = chooseTpart(pottar.Character)
            if potroot then
                local spoint = Camera:WorldToViewportPoint(potroot.Position)
                local dist = (Vector2.new(spoint.X, spoint.Y) - cent).Magnitude
                if dist <= aimfovcircle.Radius and dist < cdist and isvisible(pottar.Character, potroot) and isonscreen(potroot) then
                    cdist = dist
                    ctar = pottar
                    cpart = potroot
                end
            end
        end
    end
    aimtarget = ctar
    aimtargetpart = cpart
end

function updateInventoryText(targetPlayer)
    for _, v in ipairs(G2L.s:GetChildren()) do
        if v:IsA("TextLabel") then
            v:Destroy()
        end
    end
    if targetPlayer then
        local profile = replicatedPlayers:FindFirstChild(targetPlayer.Name)
        if profile then
            local items, weapons = {}, {}
            for _, item in pairs(profile.Inventory:GetChildren()) do
                if item:FindFirstChild("Attachments") then
                    table.insert(weapons, item.Name)
                end
            end
            table.sort(weapons)
            for _, weapon in ipairs(weapons) do
                table.insert(items, weapon)
            end
            local cloth = profile.Clothing
            local non_inventory_items, inventory_items = {}, {}
            local excluded = {balaclava = true, kneepads = true, combatgloves = true, gp5 = true, handwraps = true, ghiliehood = true}
            for _, item in pairs(cloth:GetChildren()) do
                local itemName = item.Name:lower()
                if not excluded[itemName] then
                    local inventory = item:FindFirstChild("Inventory")
                    if inventory and #inventory:GetChildren() > 0 then
                        table.insert(inventory_items, item)
                    else
                        table.insert(non_inventory_items, item)
                    end
                end
            end
            table.sort(non_inventory_items, function(a, b)
                local aName, bName = a.Name:lower(), b.Name:lower()
                if aName:find("helmet") and not bName:find("helmet") then return true end
                if bName:find("helmet") and not aName:find("helmet") then return false end
                return aName < bName
            end)
            for _, item in ipairs(non_inventory_items) do
                table.insert(items, item.Name)
            end
            for _, item in ipairs(inventory_items) do
                table.insert(items, item.Name .. ">")
                local inventory = item:FindFirstChild("Inventory")
                if inventory then
                    for _, invItem in pairs(inventory:GetChildren()) do
                        local props = invItem:FindFirstChild("ItemProperties")
                        local invcount = props and props:GetAttribute("Amount") or 1
                        table.insert(items, "    " .. invItem.Name .. " > " .. invcount)
                    end
                end
            end
            for i, itemText in ipairs(items) do
                local itemLabel = Instance.new("TextLabel", G2L.s)
                itemLabel.Name = "ItemLabel_" .. i
                itemLabel.Text = itemText
                itemLabel.TextColor3 = Color3.fromRGB(223, 223, 223)
                itemLabel.BackgroundTransparency = 1
                itemLabel.TextSize = 14
                itemLabel.FontFace = SourceSansPro
                itemLabel.TextXAlignment = Enum.TextXAlignment.Right
                itemLabel.TextYAlignment = Enum.TextYAlignment.Top
                itemLabel.BorderSizePixel = 0
                itemLabel.LayoutOrder = i
                itemLabel.TextTransparency = is_ui_visible and 0 or 1
                itemLabel.Size = UDim2.new(0, itemText:match(">$") and 170 or 180, 0, 16)
                itemLabel.Position = UDim2.new(0, itemText:match(">$") and 20 or 0, 0, 0)
            end
            G2L.s.CanvasSize = UDim2.new(0, 0, 0, G2L.u.AbsoluteContentSize.Y + 10)
        end
    else
        G2L.s.CanvasSize = UDim2.new()
    end
end

hitmarkfade = 2
function runhitmark(v140)
    if not hitmarkbool then return end
    local hitpart = Instance.new("Part", Workspace)
    hitpart.Transparency = 1
    hitpart.CanCollide = false
    hitpart.CanQuery = false
    hitpart.Size = Vector3.new(0.01, 0.01, 0.01)
    hitpart.Anchored = true
    hitpart.Position = v140
    local hit = Instance.new("BillboardGui", hitpart)
    hit.Name = "hit"
    hit.AlwaysOnTop = true
    local hit_img = Instance.new("ImageLabel", hit)
    hit_img.Name = "hit_img"
    hit_img.Image = "http://www.roblox.com/asset/?id=13298929624"
    hit_img.BackgroundTransparency = 1
    hit_img.Size = UDim2.new(0, 50, 0, 50)
    hit_img.Visible = true
    hit_img.ImageColor3 = Color3.new(1, 1, 1)
    hit_img.Rotation = 45
    hit_img.AnchorPoint = Vector2.new(0.5, 0.5)
    task.spawn(function()
        TweenService:Create(hit_img, TweenInfo.new(hitmarkfade, Enum.EasingStyle.Sine), {ImageTransparency = 1}):Play()
        TweenService:Create(hit_img, TweenInfo.new(hitmarkfade, Enum.EasingStyle.Linear), {Rotation = 180}):Play()
        task.wait(hitmarkfade)
        hit_img:Destroy()
        hit:Destroy()
    end)
end

function aimmodfunc(prikol, p49, p50, p_u_51, aimpart, _, p52, p53, p54)
    local VisualProjectile = ReplicatedStorage.Remotes.VisualProjectile
    local FireProjectile = ReplicatedStorage.Remotes.FireProjectile
    local FunctionLibraryExtension = require(ReplicatedStorage.Modules:WaitForChild("FunctionLibraryExtension"))
    local vfx = require(ReplicatedStorage.Modules:WaitForChild("VFX"))
    local UniversalTables = require(ReplicatedStorage.Modules:WaitForChild("UniversalTables"))
    local ProjectileInflict = ReplicatedStorage.Remotes.ProjectileInflict
    local RangedWeapons = ReplicatedStorage:WaitForChild("RangedWeapons")
    local Temp = ReplicatedStorage:WaitForChild("Temp")
    local char = LocalPlayer.Character
    local cameraPos = FunctionLibraryExtension:GetEstimatedCameraPosition(LocalPlayer)
    local playerData = replicatedPlayers:FindFirstChild(LocalPlayer.Name)
    local ed = playerData.Status.GameplayVariables:GetAttribute("ed")
    local ignoreList = UniversalTables.ReturnTable("GlobalIgnoreListProjectile")
    local ammo = ReplicatedStorage.AmmoTypes:FindFirstChild(p52)
    local pellets = ammo:GetAttribute("Pellets")
    local itemRoot = p50.ItemRoot
    local itemProps = p49.ItemProperties
    local weaponData = RangedWeapons:FindFirstChild(p49.Name)
    local specialProps = itemProps:FindFirstChild("SpecialProperties")
    local tracerColor = specialProps and specialProps:GetAttribute("TracerColor") or weaponData:GetAttribute("ProjectileColor")
    local bulletspeed = ammo:GetAttribute("MuzzleVelocity")
    local armorpen = ammo:GetAttribute("ArmorPen")
    local tracerendpos = Vector3.zero
    local recoil = {x = {Value = 0}, y = {Value = 0}}
    if char:FindFirstChild(p49.Name) then
        local fireSound, soundLength
        local muzzleDevice = itemProps.Tool:GetAttribute("MuzzleDevice") or "Default"
        if muzzleDevice == "Suppressor" then
            fireSound = itemRoot.Sounds.FireSoundSupressed
            soundLength = fireSound.TimeLength
        else
            fireSound = itemRoot.Sounds.FireSound
            soundLength = fireSound.TimeLength
        end
        if tick() - p53 < 0.8 then
            FunctionLibraryExtension:PlaySoundV2(fireSound, soundLength, Temp)
        else
            FunctionLibraryExtension:PlaySoundV2(fireSound, soundLength, Temp)
        end
        local barrel = p_u_51.Item.Attachments:FindFirstChild("Front") and p_u_51.Item.Attachments.Front:GetChildren()[1].Barrel or p_u_51.Item.Barrel
        local lookVector
        if aimtarget and aimtargetpart then
            lookVector = CFrame.new(cameraPos, aimtargetpart.Position).LookVector
        else
            lookVector = CFrame.new(cameraPos, LocalPlayer:GetMouse().Hit.Position).LookVector
        end
        local function fireBullet(bullet_id)
            local rayParams = RaycastParams.new()
            rayParams.FilterType = Enum.RaycastFilterType.Exclude
            rayParams.FilterDescendantsInstances = {char, p_u_51, ignoreList, unpack(aimignoreparts)}
            rayParams.CollisionGroup = "WeaponRay"
            rayParams.IgnoreWater = true
            task.spawn(function()
                if not FireProjectile:InvokeServer(lookVector, bullet_id, tick()) then
                    ReplicatedStorage.Modules.FPS.Binds.AdjustBullets:Fire(ed, 1)
                end
            end)
            local conn
            local penetrated = false
            if aimfakewait and aimtarget then
                local tpart = aimtarget:IsA("Model") and aimtarget.HumanoidRootPart or aimtarget.Character.HumanoidRootPart
                local distance = (Camera.CFrame.Position - tpart.CFrame.Position).Magnitude
                task.wait(distance / bulletspeed + 0.01)
                lookVector = aimtarget and aimtargetpart and CFrame.new(cameraPos, aimtargetpart.Position).LookVector or CFrame.new(cameraPos, LocalPlayer:GetMouse().Hit.Position).LookVector
            end
            VisualProjectile:FireServer(lookVector, bullet_id)
            local function updateRay(p134)
                local ray = Workspace:Raycast(cameraPos, lookVector * 500000, rayParams)
                local instance, position, normal, material
                if ray then
                    instance, position, normal, material = ray.Instance, ray.Position, ray.Normal, ray.Material
                else
                    position = cameraPos + lookVector * 500000
                end
                if not instance then
                    conn:Disconnect()
                    return
                end
                tracerendpos = position
                local model = FunctionLibraryExtension:FindDeepAncestor(instance, "Model")
                if model and model:FindFirstChild("Humanoid") then
                    local ran = math.random(1, 100)
                    local hitTarget = ran <= aimchance and aimtargetpart and not penetrated
                    local hitPart = hitTarget and aimtargetpart or aimpart
                    local hitCFrame = instance.CFrame:ToObjectSpace(CFrame.new(position))
                    ProjectileInflict:FireServer(hitPart, hitCFrame, bullet_id, tick())
                    vfx.Impact(instance, position, normal, material, lookVector, "Ranged", true)
                    task.spawn(function()
                        runhitmark(position)
                        if hitsoundbool and (instance.Name == "Head" or instance.Name == "UpperTorso") then
                            local sound = Instance.new("Sound", Workspace)
                            sound.SoundId = hitsoundlib[hitsoundhead]
                            sound.Volume = hitsoundvolume
                            sound:Play()
                            task.wait(1)
                            sound:Destroy()
                        end
                    end)
                elseif instance.Name == "Terrain" then
                    local hitCFrame = instance.CFrame:ToObjectSpace(CFrame.new(position))
                    ProjectileInflict:FireServer(instance, hitCFrame, bullet_id, tick())
                    vfx.Impact(instance, position, normal, material, lookVector, "Ranged", true)
                    task.spawn(function() runhitmark(position) end)
                else
                    vfx.Impact(instance, position, normal, material, lookVector, "Ranged", true)
                    task.spawn(function() runhitmark(position) end)
                    local newArmorPen, newPos, impactData = FunctionLibraryExtension.Penetration(FunctionLibraryExtension, instance, position, lookVector, armorpen)
                    if not newArmorPen or not newPos then
                        local hitCFrame = instance.CFrame:ToObjectSpace(CFrame.new(position))
                        ProjectileInflict:FireServer(instance, hitCFrame, bullet_id, tick())
                        conn:Disconnect()
                        return
                    end
                    armorpen = newArmorPen
                    if armorpen > 0 then
                        cameraPos = newPos
                        vfx.Impact(unpack(impactData))
                        penetrated = true
                        return
                    end
                    conn:Disconnect()
                    return
                end
                conn:Disconnect()
            end
            conn = RunService.RenderStepped:Connect(updateRay)
        end
        local bullet_id = math.random(-100000, 100000)
        if not pellets then
            task.spawn(function() fireBullet(bullet_id) end)
            if multibullet then
                for i = 1, multibullet_count - 1 do
                    task.spawn(function() fireBullet(math.random(-100000, 100000)) end)
                end
            end
        else
            for _ = 1, pellets do
                task.spawn(function() fireBullet(bullet_id) end)
                if multibullet then
                    for i = 1, multibullet_count - 1 do
                        task.spawn(function() fireBullet(math.random(-100000, 100000)) end)
                    end
                end
            end
        end
        if tracbool then
            task.spawn(function()
                task.wait(0.05)
                if tracerendpos ~= Vector3.zero then runtracer(itemRoot.Position, tracerendpos) end
            end)
        end
        return 0.001, 0.001, muzzleDevice, recoil
    end
end

function updateselfpos()
    for i = 1000, 20, -10 do
        selftrack_data[i] = selftrack_data[i - 10] or Vector3.zero
    end
    selftrack_data[10] = LocalPlayer.Character and LocalPlayer.Character.HumanoidRootPart and LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, 1.3, 0) or Vector3.zero
end

function setupA1Table()
    local mod = require(ReplicatedStorage.Modules.FPS)
    local ogfunc = mod.updateClient
    mod.updateClient = function(a1, a2, a3)
        a1table = a1
        return ogfunc(a1, a2, a3)
    end
end
setupA1Table()

function updateFOVCircleVisibility()
    local visible = aimbool and fovcircle_enabled
    aimfovcircle.Visible = visible
    aimfovcircle_outer.Visible = visible
    aimfovcircle_inner.Visible = visible
    aimfovcircle_fill.Visible = visible and aimfovfill_enabled
end

RunService.RenderStepped:Connect(function(delta)
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") or not char:FindFirstChild("Humanoid") then
        if is_ui_visible then hideUI() end
        updateFOVCircleVisibility()
        return
    end
    local _, _, newglobalcurrentgun = getcurrentgun(LocalPlayer)
    globalcurrentgun = newglobalcurrentgun
    globalammo = getcurrentammo(globalcurrentgun)
    choosetarget()
    local fov_position = aimmousefov and UserInputService:GetMouseLocation() or Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    aimfovcircle.Radius = aimfov
    aimfovcircle_outer.Radius = aimfov + 1
    aimfovcircle_inner.Radius = aimfov - 1
    aimfovcircle_fill.Radius = aimfov
    aimfovcircle.Position = fov_position
    aimfovcircle_outer.Position = fov_position
    aimfovcircle_inner.Position = fov_position
    aimfovcircle_fill.Position = fov_position
    updateFOVCircleVisibility()
    if targetui_enabled and aimbool and aimtarget then
        if not is_ui_visible and not tweening then showUI() end
        if is_ui_visible then
            local humanoid, name
            if aimtarget:IsA("Player") then
                name = aimtarget.Name
                humanoid = aimtarget.Character and aimtarget.Character:FindFirstChild("Humanoid")
            else
                name = aimtarget.Name
                humanoid = aimtarget:FindFirstChild("Humanoid")
            end
            G2L.h.Text = name
            if humanoid then
                local health = math.floor(humanoid.Health)
                G2L.j.Text = tostring(health)
                if health <= 0 then
                    G2L.p.Visible = false
                    G2L.p.Size = UDim2.new(0, 0, 0, 11)
                    last_health = health
                else
                    G2L.p.Visible = true
                    local healthPercent = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
                    if math.abs(health - last_health) > 0.1 then
                        last_health = health
                        TweenService:Create(G2L.p, TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Size = UDim2.new(0, 190 * healthPercent, 0, 11)}):Play()
                    end
                end
            else
                G2L.j.Text = "0"
                G2L.p.Visible = false
                G2L.p.Size = UDim2.new(0, 0, 0, 11)
                last_health = 0
            end
            if aimtarget:IsA("Player") then
                local wipestats = replicatedPlayers[aimtarget.Name] and replicatedPlayers[aimtarget.Name].Status.Journey.WipeStatistics
                local kills = wipestats and wipestats:GetAttribute("Kills") or 0
                local deaths = wipestats and wipestats:GetAttribute("Deaths") or 0
                G2L.o.Text = kills == 0 and "0.00" or string.format("%.2f", deaths == 0 and kills or kills / deaths)
                if aimtarget ~= last_target then
                    updateInventoryText(aimtarget)
                    last_target = aimtarget
                end
            else
                G2L.o.Text = "0.00"
                updateInventoryText()
                last_target = nil
            end
        end
    elseif is_ui_visible and not tweening then
        hideUI()
    end
    if aimtarget ~= last_aimtarget then
        last_aimtarget = aimtarget
    end
    selftrack_update = selftrack_update + delta
    if selftrack_update >= 0.01 then
        updateselfpos()
        selftrack_update = 0
    end
end)

if aimbool then
    Bullet.CreateBullet = aimmodfunc
else
    Bullet.CreateBullet = aimogfunc
end

Enabled:Toggle({
    Name = "Silent Aim",
    Flag = "SilentAim",
    Callback = function(value)
        aimbool = value
        showToggleNotification("Silent Aim", value)
        playToggleSound(value)
        if aimbool then
            Bullet.CreateBullet = aimmodfunc
            updateFOVCircleVisibility()
            if targetui_enabled and aimtarget and not is_ui_visible and not tweening then
                showUI()
            end
        else
            Bullet.CreateBullet = aimogfunc
            updateFOVCircleVisibility()
            if is_ui_visible and not tweening then
                hideUI()
            end
            if targetui_enabled then
                targetui_enabled = false
                showToggleNotification("Target UI", false, "Target UI disabled as Silent Aim is turned off")
                playToggleSound(false)
            end
        end
    end
})


Enabled:Toggle({
    Name = "Target UI",
    Flag = "TargetUI",
    Callback = function(value)
        if value and not aimbool then
            showToggleNotification("Target UI", false, "Silent Aim must be enabled to use Target UI")
            playToggleSound(false)
            targetui_enabled = false
        else
            targetui_enabled = value
            showToggleNotification("Target UI", value)
            playToggleSound(value)
            if value and aimbool and aimtarget and not is_ui_visible and not tweening then
                showUI()
            elseif not value and is_ui_visible and not tweening then
                hideUI()
            end
        end
    end
})



Enabled:Toggle({
    Name = "Wall Check",
    Flag = "WallCheck",
    Callback = function(value)
        aimvischeck = value
        showToggleNotification("Wall Check", value)
        playToggleSound(value)   
    end
})

Enabled:Toggle({
    Name = "Target AI",
    Flag = "TargetAI",
    Callback = function(value)
        aimbots = value
        showToggleNotification("Target AI", value)
        playToggleSound(value)    
    end
})

Enabled:Toggle({
    Name = "Ignore Friends",
    Flag = "IgnoreFriends",
    Callback = function(value)
        aimfriendcheck = value
        showToggleNotification("Ignore Friends", value)
        playToggleSound(value)     
    end
})
Enabled:Slider({
    Name = "Hit Chance",
    Suffix = "%",
    Min = 0,
    Max = 100,
    Default = 100,
    Flag = "HitChance",
    Callback = function(value)
        aimchance = value
    end
})

Enabled:List({
    Name = "HitPart",
    Flag = "HitPart",
    Options = {"Head", "HumanoidRootPart"},
    Default = "Head",
    Callback = function(value)
        aimpart = value
    end
})
Fov = Pages["Aiming"]:Section({
    Name = "Silent Aim FOV", 
    Zindex = 2, 
    Side = "Right"
})

Fov:Toggle({
    Name = "Fov ",
    Flag = "FOVCircle",
    Callback = function(value)
        fovcircle_enabled = value
        showToggleNotification("FOV Circle", value)
        playToggleSound(value)
        updateFOVCircleVisibility()
    end
})


Fov:Toggle({
    Name = "Fov Fill",
    Flag = "FOVFill",
    Callback = function(value)
        aimfovfill_enabled = value
        showToggleNotification("FOV Fill", value)
        playToggleSound(value)
        aimfovcircle_fill.Visible = aimbool and fovcircle_enabled and value
    end
})
Fov:Colorpicker({
    Name = "Fov Color",
    Default = Color3.fromRGB(255, 255, 255),
    Transparency = 1,
    Flag = "FovColor",
    Callback = function(color)
        aimfovcircle.Color = color
        aimfovcircle_fill.Color = color
    end
})
Fov:List({
    Name = "Fov Variables",
    Flag = "fovvar",
    Options = {"Static", "Dynamic"},
    Default = "Static",
    Callback = function(value)
        aimmousefov = value == "Dynamic"
    end
})
Fov:Slider({
    Name = "FOV Size",
    Suffix = "px",
    Min = 50,
    Max = 500,
    Default = 150,
    Flag = "FOVSize",
    Callback = function(value)
        aimfov = value
    end
})

Fov:Slider({
    Name = "Fov Transparency",
    Suffix = "%",
    Min = 0,
    Max = 100,
    Default = 50,
    Flag = "FovTransparency",
    Callback = function(value)
        aimfovcircle.Transparency = value / 100
        aimfovcircle_outer.Transparency = value / 100
        aimfovcircle_inner.Transparency = value / 100
    end
})

Fov:Slider({
    Name = "Fov Fill Transparency",
    Suffix = "%",
    Min = 0,
    Max = 100,
    Default = 30,
    Flag = "FovFillTransparency",
    Callback = function(value)
        aimfovfill_transparency = value / 100
        aimfovcircle_fill.Transparency = aimfovfill_transparency
    end
})

Fov:Slider({
    Name = "Fov Sides",
    Suffix = "sides",
    Min = 6,
    Max = 60,
    Default = 32,
    Flag = "FovCircleSides",
    Callback = function(value)
        aimfovcircle_numsides = value
        aimfovcircle.NumSides = value
        aimfovcircle_outer.NumSides = value
        aimfovcircle_inner.NumSides = value
        aimfovcircle_fill.NumSides = value
    end
})

resolver = Pages["Aiming"]:Section({
    Name = "UnderGround Resolver/Upangle Resolver", 
    Zindex = 1, 
    Side = "Right"
})
local player = game.Players.LocalPlayer
local runService = game:GetService("RunService")
local inputService = game:GetService("UserInputService")
local isResolving = false
local resolveTimer = tick()
local playerPosition = player.Character and player.Character.HumanoidRootPart and player.Character.HumanoidRootPart.CFrame or CFrame.new()
local resolveTimeout = 0.7
local manipulateModels = true
local hiddenPlayers = {}
local resolverEnabled = false
local resolverHeight = -15

local hideAnimation = Instance.new("Animation")
hideAnimation.AnimationId = "rbxassetid://15609995579"
local hideAnimationTrack = nil
local desyncTable = {}

local function enableBypass()
    local metaTable = getrawmetatable(game)
    local originalNamecall = metaTable.__namecall
    setreadonly(metaTable, false)
    metaTable.__namecall = newcclosure(function(self, ...)
        local method = getnamecallmethod()
        local args = {...}
        if method == "FireServer" and self.Name == "ProjectileInflict" then
            if args[1] == game.Players.LocalPlayer.Character.PrimaryPart then
                return coroutine.yield()
            end
        end
        return originalNamecall(self, ...)
    end)
    setreadonly(metaTable, true)
end
enableBypass()

local function loadAnimations(character)
    if character and character:FindFirstChildOfClass("Humanoid") then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            hideAnimationTrack = humanoid.Animator:LoadAnimation(hideAnimation)
            hideAnimationTrack.Priority = Enum.AnimationPriority.Action
        end
    end
end

player.CharacterAdded:Connect(function(character)
    loadAnimations(character)
end)

if player.Character then
    loadAnimations(player.Character)
end

inputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.P then
        if resolverEnabled and tick() > resolveTimer then
            resolveTimer = tick() 
            if desyncTable[1] then
                player.Character.HumanoidRootPart.CFrame = desyncTable[1]
            end
            playerPosition = player.Character.HumanoidRootPart.CFrame
            isResolving = true
            task.wait(0.15)
            isResolving = false
            player.Character.HumanoidRootPart.Anchored = false
            player.Character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.zero
        end
    end
end)

local function updateHiddenPlayers()
    for i = #hiddenPlayers, 1, -1 do
        local character = hiddenPlayers[i]
        if not character or not character.Parent or not character:FindFirstChildOfClass("Humanoid") or character:FindFirstChildOfClass("Humanoid").Health <= 0 then
            table.remove(hiddenPlayers, i)
        end
    end

    for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChildOfClass("Humanoid") then
            local humanoid = otherPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid.Health > 0 then
                for _, track in ipairs(humanoid.Animator:GetPlayingAnimationTracks()) do
                    if track.Animation and track.Animation.AnimationId == hideAnimation.AnimationId then
                        if not table.find(hiddenPlayers, otherPlayer.Character) then
                            table.insert(hiddenPlayers, otherPlayer.Character)
                        end
                        break
                    end
                end
            end
        end
    end
end

task.spawn(function()
    while task.wait(0.2) do
        updateHiddenPlayers()
    end
end)

runService.RenderStepped:Connect(function(delta)
    if manipulateModels then
        for _, character in ipairs(hiddenPlayers) do
            if character and character:FindFirstChildOfClass("Humanoid") then
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                if humanoid.Health > 0 then
                    for _, track in ipairs(humanoid.Animator:GetPlayingAnimationTracks()) do
                        if track.Animation and track.Animation.AnimationId == hideAnimation.AnimationId then
                            track:Stop()
                            break
                        end
                    end
                end
            end
        end
    end
end)

runService.Heartbeat:Connect(function(dt)
    if isResolving and resolverEnabled and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local character = player.Character
        local rootPart = character.HumanoidRootPart
        local offset = CFrame.new(0, resolverHeight, 0)
        rootPart.AssemblyLinearVelocity = -offset.Position
        character.HumanoidRootPart.CanCollide = false
        if character:FindFirstChild("UpperTorso") then character.UpperTorso.CanCollide = false end
        if character:FindFirstChild("LowerTorso") then character.LowerTorso.CanCollide = false end
        character:PivotTo(playerPosition * offset)
    end
end)

resolver:Toggle({
    Name = "Resolver",
    Flag = "Resolver",
    Callback = function(value)
        resolverEnabled = value
        showToggleNotification("Resolver", value)
        playToggleSound(value)
    end
})

resolver:Slider({
    Name = "Resolver Height",
    Suffix = "studs",
    Min = -20,
    Max = -10,
    Default = -15,
    Flag = "ResolverHeight",
    Callback = function(value)
        resolverHeight = value
    end
})

resolver:Keybind({
    Name = "Resolver Keybind",
    Flag = "ResolverKeybind",
    Default = Enum.KeyCode.End,
    Callback = function()
        if resolverEnabled and tick() > resolveTimer then
            resolveTimer = tick() + 0.5 + resolveTimeout
            if desyncTable[1] then
                player.Character.HumanoidRootPart.CFrame = desyncTable[1]
            end
            playerPosition = player.Character.HumanoidRootPart.CFrame
            isResolving = true
            task.wait(0.5)
            isResolving = false
            player.Character.HumanoidRootPart.Anchored = false
            player.Character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.zero
        end
    end
})

local GunMods = Pages["Aiming"]:Section({
    Name = "Gun modules", 
    Zindex = 3, 
    Side = "Left"
})


local originalShoveFunctions = {}

GunMods:Toggle({
    Name = "No Recoil", 
    Flag = "NoRecoilToggle", 
    Default = false,
    Callback = function(value)
		showToggleNotification("No Recoil", value)
		playToggleSound(value)	 
        for i, gc in next, getgc(true) do
            if type(gc) == "table" and rawget(gc, "shove") then
                if value then
                    if not originalShoveFunctions[gc] then
                        originalShoveFunctions[gc] = gc.shove
                    end
                    gc.shove = function() return Vector3.zero end
                else
                    if originalShoveFunctions[gc] then
                        gc.shove = originalShoveFunctions[gc]
                        originalShoveFunctions[gc] = nil
                    end
                end
            end
        end
    end
})



local nogunanims = false


do
    local fpsModule = require(game.ReplicatedStorage.Modules.FPS)
    local originalUpdateClient = fpsModule.updateClient

    fpsModule.updateClient = function(playerData, param2, param3)
        local result1, result2, result3 = originalUpdateClient(playerData, param2, param3)
        
        local playerState = playerData
        
        if nogunanims then
            playerData.springs.sway.Position = Vector3.new(0, 0, 0)
            playerData.springs.walkCycle.Position = Vector3.new(0, 0, 0)
            playerData.springs.sprintCycle.Position = Vector3.new(0, 0, 0)
            playerData.springs.strafeTilt.Position = Vector3.new(0, 0, 0)
            playerData.springs.jumpTilt.Position = Vector3.new(0, 0, 0)
            playerData.springs.sway.Speed = 0
            playerData.springs.walkCycle.Speed = 0
            playerData.springs.sprintCycle.Speed = 0
            playerData.springs.strafeTilt.Speed = 0
            playerData.springs.jumpTilt.Speed = 0
        else
            playerData.springs.sway.Speed = 4
            playerData.springs.walkCycle.Speed = 4
            playerData.springs.sprintCycle.Speed = 4
            playerData.springs.strafeTilt.Speed = 4
            playerData.springs.jumpTilt.Speed = 4
        end

        return result1, result2, result3
    end
end


GunMods:Toggle({
    Name = "No Gun Animations",
    Flag = "NoGunAnims",
    Default = false,
    Callback = function(isEnabled)
		showToggleNotification("No Gun Animations", value)
		playToggleSound(value)	 
        nogunanims = isEnabled
    end
})

local originalAimFunctions = {}

GunMods:Toggle({
    Name = "Instant Aim", 
    Flag = "InstantAimToggle", 
    Default = false,
    Callback = function(value)
		showToggleNotification("Instant Aim", value)
		playToggleSound(value)	 
        for i, gc in next, getgc(true) do
            if type(gc) == "table" and rawget(gc, "updateClient") then
                if value then
                    
                    if not originalAimFunctions[gc] then
                        originalAimFunctions[gc] = gc.updateClient
                    end
                    
                    
                    gc.updateClient = function(self, ...)
                        self.AimInSpeed =0
                        self.AimOutSpeed =0
                        return originalAimFunctions[gc](self, ...)
                    end
                else
                    
                    if originalAimFunctions[gc] then
                        gc.updateClient = originalAimFunctions[gc]
                    end
                end
            end
        end
        
        
        if not value then
            originalAimFunctions = {}
        end
    end
})

instantniggaload = function(a1, a2)
    local function aaa(a1)
        local v27_2_ = a1.weapon
        local v27_1_ = v27_2_.Attachments
        local v27_3_ = "Magazine"
        v27_1_ = v27_1_:FindFirstChild(v27_3_)
        if v27_1_ then
            local v27_4_ = a1.weapon
            v27_3_ = v27_4_.Attachments
            v27_2_ = v27_3_.Magazine
            v27_2_ = v27_2_:GetChildren()
            v27_1_ = v27_2_[-1]
            if v27_1_ then
                v27_2_ = v27_1_.ItemProperties
                v27_4_ = "LoadedAmmo"
                v27_2_ = v27_2_:GetAttribute(v27_4_)
                a1.Bullets = v27_2_
                v27_2_ = {}
                a1.BulletsList = v27_2_
                v27_3_ = v27_1_.ItemProperties
                v27_2_ = v27_3_.LoadedAmmo
                v27_3_ = v27_2_:GetChildren()
                local v27_6_ = 1
                v27_4_ = #v27_3_
                local v27_5_ = 1
                for v27_6_ = v27_6_, v27_4_, v27_5_ do
                    local v27_7_ = a1.BulletsList
                    local v27_10_ = v27_3_[v27_6_]
                    local v27_9_ = v27_10_.Name
                    local v27_8_ = tonumber
                    v27_8_ = v27_8_(v27_9_)
                    v27_9_ = {}
                    v27_10_ = v27_3_[v27_6_]
                    local v27_12_ = "AmmoType"
                    v27_10_ = v27_10_:GetAttribute(v27_12_)
                    v27_9_.AmmoType = v27_10_
                    v27_10_ = v27_3_[v27_6_]
                    v27_12_ = "Amount"
                    v27_10_ = v27_10_:GetAttribute(v27_12_)
                    v27_9_.Amount = v27_10_
                    v27_7_[v27_8_] = v27_9_
                end
            end
            v27_2_ = 0
            a1.movementModifier = v27_2_
            v27_2_ = a1.weapon
            if v27_2_ then
                v27_2_ = a1.movementModifier
                local v27_6_ = a1.weapon
                local v27_5_ = v27_6_.ItemProperties
                v27_4_ = v27_5_.Tool
                v27_6_ = "MovementModifer"
                v27_4_ = v27_4_:GetAttribute(v27_6_)
                v27_3_ = v27_4_ or 0.000000
                v27_2_ = v27_3_
                a1.movementModifier = v27_2_
                v27_2_ = a1.weapon
                v27_4_ = "Attachments"
                v27_2_ = v27_2_:FindFirstChild(v27_4_)
                if v27_2_ then
                    v27_3_ = a1.weapon
                    v27_2_ = v27_3_.Attachments
                    v27_2_ = v27_2_:GetChildren()
                    v27_5_ = 1
                    v27_3_ = #v27_2_
                    v27_4_ = 1
                    for v27_5_ = v27_5_, v27_3_, v27_4_ do
                        v27_6_ = v27_2_[v27_5_]
                        local v27_8_ = "StringValue"
                        v27_6_ = v27_6_:FindFirstChildOfClass(v27_8_)
                        if v27_6_ then
                            local v27_7_ = v27_6_.ItemProperties
                            local v27_9_ = "Attachment"
                            v27_7_ = v27_7_:FindFirstChild(v27_9_)
                            if v27_7_ then
                                v27_7_ = a1.movementModifier
                                local v27_10_ = v27_6_.ItemProperties
                                v27_9_ = v27_10_.Attachment
                                local v27_11_ = "MovementModifer"
                                v27_9_ = v27_9_:GetAttribute(v27_11_)
                                v27_8_ = v27_9_ or 0.000000
                                v27_7_ = v27_8_
                                a1.movementModifier = v27_7_
                            end
                        end
                        return
                    end
                end
            end
        end
        v27_2_ = a1.weapon
        v27_1_ = v27_2_.ItemProperties
        v27_3_ = "LoadedAmmo"
        v27_1_ = v27_1_:GetAttribute(v27_3_)
        a1.Bullets = v27_1_
        v27_1_ = {}
        a1.BulletsList = v27_1_
        v27_3_ = a1.weapon
        v27_2_ = v27_3_.ItemProperties
        v27_1_ = v27_2_.LoadedAmmo
        v27_2_ = v27_1_:GetChildren()
        local v27_5_ = 1
        v27_3_ = #v27_2_
        local v27_4_ = 1
        for v27_5_ = v27_5_, v27_3_, v27_4_ do
            local v27_6_ = a1.BulletsList
            local v27_9_ = v27_2_[v27_5_]
            local v27_8_ = v27_9_.Name
            local v27_7_ = tonumber
            v27_7_ = v27_7_(v27_8_)
            v27_8_ = {}
            v27_9_ = v27_2_[v27_5_]
            local v27_11_ = "AmmoType"
            v27_9_ = v27_9_:GetAttribute(v27_11_)
            v27_8_.AmmoType = v27_9_
            v27_9_ = v27_2_[v27_5_]
            v27_11_ = "Amount"
            v27_9_ = v27_9_:GetAttribute(v27_11_)
            v27_8_.Amount = v27_9_
            v27_6_[v27_7_] = v27_8_
        end
    end
    local v103_2_ = a1.viewModel
    if v103_2_ then
        local v103_3_ = a1.viewModel
        v103_2_ = v103_3_.Item
        local v103_4_ = "AmmoTypes"
        v103_2_ = v103_2_:FindFirstChild(v103_4_)
        if v103_2_ then
            local v103_5_ = a1.weapon
            v103_4_ = v103_5_.ItemProperties
            v103_3_ = v103_4_.AmmoType
            v103_2_ = v103_3_.Value
            v103_5_ = a1.viewModel
            v103_4_ = v103_5_.Item
            v103_3_ = v103_4_.AmmoTypes
            v103_3_ = v103_3_:GetChildren()
            local v103_6_ = 1
            v103_4_ = #v103_3_
            v103_5_ = 1
            for v103_6_ = v103_6_, v103_4_, v103_5_ do
                local v103_7_ = v103_3_[v103_6_]
                local v103_8_ = 1
                v103_7_.Transparency = v103_8_
            end
            v103_6_ = a1.viewModel
            v103_5_ = v103_6_.Item
            v103_4_ = v103_5_.AmmoTypes
            v103_6_ = v103_2_
            v103_4_ = v103_4_:FindFirstChild(v103_6_)
            v103_5_ = 0
            v103_4_.Transparency = v103_5_
            v103_5_ = a1.viewModel
            v103_4_ = v103_5_.Item
            v103_6_ = "AmmoTypes2"
            v103_4_ = v103_4_:FindFirstChild(v103_6_)
            if v103_4_ then
                v103_6_ = a1.viewModel
                v103_5_ = v103_6_.Item
                v103_4_ = v103_5_.AmmoTypes2
                v103_4_ = v103_4_:GetChildren()
                local v103_7_ = 1
                v103_5_ = #v103_4_
                v103_6_ = 1
                for v103_7_ = v103_7_, v103_5_, v103_6_ do
                    local v103_8_ = v103_4_[v103_7_]
                    local v103_9_ = 1
                    v103_8_.Transparency = v103_9_
                end
                v103_7_ = a1.viewModel
                v103_6_ = v103_7_.Item
                v103_5_ = v103_6_.AmmoTypes2
                v103_7_ = v103_2_
                v103_5_ = v103_5_:FindFirstChild(v103_7_)
                v103_6_ = 0
                v103_5_.Transparency = v103_6_
            end
        end
        v103_2_ = a1.reloading
        if v103_2_ == false then
            v103_2_ = a1.cancellingReload
            if v103_2_ == false then
                v103_2_ = a1.MaxAmmo
                v103_3_ = 0
                if v103_3_ < v103_2_ then
                    v103_3_ = true
                    local v103_6_ = 1
                    local v103_7_ = a1.CancelTables
                    v103_4_ = #v103_7_
                    local v103_5_ = 1
                    for v103_6_ = v103_6_, v103_4_, v103_5_ do
                        local v103_9_ = a1.CancelTables
                        local v103_8_ = v103_9_[v103_6_]
                        v103_7_ = v103_8_.Visible
                        if v103_7_ == true then
                            v103_3_ = false
                        else
                        end
                    end
                    v103_2_ = v103_3_
                    if v103_2_ then
                        v103_3_ = a1.clientAnimationTracks
                        v103_2_ = v103_3_.Inspect
                        if v103_2_ then
                            v103_3_ = a1.clientAnimationTracks
                            v103_2_ = v103_3_.Inspect
                            v103_2_:Stop()
                            v103_3_ = a1.serverAnimationTracks
                            v103_2_ = v103_3_.Inspect
                            v103_2_:Stop()
                            v103_4_ = a1.WeldedTool
                            v103_3_ = v103_4_.ItemRoot
                            v103_2_ = v103_3_.Sounds.Inspect
                            v103_2_:Stop()
                        end
                        v103_3_ = a1.settings
                        v103_2_ = v103_3_.AimWhileActing
                        if not v103_2_ then
                            v103_2_ = a1.isAiming
                            if v103_2_ then
                                v103_4_ = false
                                a1:aim(v103_4_)
                            end
                        end
                        
                        if a1.reloadType == "loadByHand" then
                            local count = a1.Bullets
                            local maxcount = a1.MaxAmmo
                            for i=count, maxcount do 
                                game.ReplicatedStorage.Remotes.Reload:InvokeServer(nil, 0.001, nil)
                            end
                            aaa(a1)
                        else
                            game.ReplicatedStorage.Remotes.Reload:InvokeServer(nil, 0.001, nil)
                            require(game.ReplicatedStorage.Modules.FPS).equip(a1, a1.weapon, nil)
                            aaa(a1)
                        end      
                    end
                end
            end
        end
    end
end

GunMods:Toggle({
    Name = "Instant Reload",
    Flag = "InstantReload",
    Default = false,
    Callback = function(value)
		showToggleNotification("Instant Reload", value)
		playToggleSound(value)	 
        if value then 
            require(game.ReplicatedStorage.Modules.FPS).reload = instantniggaload
        else
            require(game.ReplicatedStorage.Modules.FPS).reload = instrelOGfunc
        end
    end
})

local instantEquipNIGGA = false

workspace.Camera.ChildAdded:Connect(function(ch)
    if instantEquipNIGGA and ch:IsA("Model") then
        task.wait(0.015)
        for i, v in pairs(ch.Humanoid.Animator:GetPlayingAnimationTracks()) do
            if v.Animation.Name == "Equip" then
                v.TimePosition = v.Length - 0.01
            end
        end
    end
end)

GunMods:Toggle({
    Name = "Instant Equip", 
    Flag = "InstantEquip", 
    Default = false,
    Callback = function(value)
        instantEquipNIGGA = value
		showToggleNotification("Instant Equip", value)
		playToggleSound(value)	 
    end
})

local gameInstance = game
local ReplicatedStorageService = gameInstance:GetService("ReplicatedStorage")
local PlayerService = gameInstance:GetService("Players")
local currentPlayer = PlayerService.LocalPlayer
local isAutoModeEnabled = false

local function retrieveActiveWeapon()
    local playerCharacter = currentPlayer.Character
    if not playerCharacter then return nil end
    for _, item in pairs(playerCharacter:GetChildren()) do
        if item:IsA("Tool") and item:FindFirstChild("SettingsModule") then
            return item
        end
    end
    return nil
end

local function configureFireSettings(weaponInstance)
    if weaponInstance and weaponInstance:FindFirstChild("SettingsModule") then
        local weaponConfig = require(weaponInstance.SettingsModule)
        weaponConfig.FireModes = {"Auto", "Semi"}
    end
end

local function reequipWeaponInstance(weaponInstance)
    if not weaponInstance or not currentPlayer.Character then return end
    local characterHumanoid = currentPlayer.Character:FindFirstChildOfClass("Humanoid")
    if not characterHumanoid then return end

    characterHumanoid:UnequipTools()
    wait(0.1)
    characterHumanoid:EquipTool(weaponInstance)
end

local function equipInitialWeapon()
    local playerInventory = ReplicatedStorageService.Players:FindFirstChild(currentPlayer.Name).Inventory
    if not playerInventory then return end

    local primaryWeapon = nil
    for _, weaponItem in pairs(playerInventory:GetChildren()) do
        if weaponItem:FindFirstChild("SettingsModule") then
            primaryWeapon = weaponItem
            break
        end
    end

    if primaryWeapon and currentPlayer.Backpack then
        local backpackWeaponInstance = currentPlayer.Backpack:FindFirstChild(primaryWeapon.Name)
        if backpackWeaponInstance then
            configureFireSettings(backpackWeaponInstance)
            reequipWeaponInstance(backpackWeaponInstance)
        end
    end
end

local function updateInventoryFireSettings()
    while isAutoModeEnabled do
        wait(1)
        local playerInventory = ReplicatedStorageService.Players:FindFirstChild(currentPlayer.Name).Inventory
        if not playerInventory then continue end

        for _, weaponItem in pairs(playerInventory:GetChildren()) do
            configureFireSettings(weaponItem)
        end
    end
end

local function manageEquippedWeapons()
    if not isAutoModeEnabled then return end

    local activeWeapon = retrieveActiveWeapon()
    if activeWeapon then
        configureFireSettings(activeWeapon)
        reequipWeaponInstance(activeWeapon)
    else
        equipInitialWeapon()
    end

    currentPlayer.CharacterAdded:Connect(function(newCharacter)
        if not isAutoModeEnabled then return end
        newCharacter.ChildAdded:Connect(function(childItem)
            if childItem:IsA("Tool") and childItem:FindFirstChild("SettingsModule") then
                configureFireSettings(childItem)
                reequipWeaponInstance(childItem)
            end
        end)
    end)

    if currentPlayer.Character then
        currentPlayer.Character.ChildAdded:Connect(function(childItem)
            if childItem:IsA("Tool") and childItem:FindFirstChild("SettingsModule") then
                configureFireSettings(childItem)
                reequipWeaponInstance(childItem)
            end
        end)
    end
end

GunMods:Toggle({
    Name = "Unlock Gun Modes",
    Flag = "UnlockAuto",
    Default = false,
    Callback = function(value)
        isAutoModeEnabled = value
		showToggleNotification("Unlock Gun Modes", value)
		playToggleSound(value)	 
        if isAutoModeEnabled then
            task.spawn(updateInventoryFireSettings)
            task.spawn(manageEquippedWeapons)
        end
    end
})
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local user = Players.LocalPlayer
local isRapidRape = false

local function AdjustWeaponFireSpeed()
    local gear = ReplicatedStorage.Players:FindFirstChild(user.Name).Inventory
    if not gear then return end
    for _, weapon in ipairs(gear:GetChildren()) do
        if weapon:FindFirstChild("SettingsModule") then
            local config = require(weapon.SettingsModule)
            if isRapidRape then
                config.FireRate = 0.001
            else
                local baseRate = 0.05
                local fireSpeedAttr = weapon.ItemProperties.Tool:GetAttribute("FireRate")
                if fireSpeedAttr then
                    baseRate = 60 / fireSpeedAttr
                end
                config.FireRate = baseRate
            end
        end
    end
end

GunMods:Toggle({
    Name = "Rapid Fire",
    Flag = "RapidRape",
    Default = false,
    Callback = function(value)
		showToggleNotification("Rapid Fire", value)
		playToggleSound(value)	 
        isRapidRape = value
        AdjustWeaponFireSpeed()
		
    end
})
GunMods:Toggle({
    Name = "Bullet Multiplier",
    Flag = "MultiBullet",
    Callback = function(value)
        multibullet = value
        showToggleNotification("Bullet Multiplier", value)
        playToggleSound(value)
    end
})

GunMods:Slider({
    Name = "Bullet Count",
    Suffix = " Bullets",
    Min = 1,
    Max = 10,
    Default = 1,
    Flag = "MultiBulletCount",
    Callback = function(value)
        multibullet_count = value
    end
})
ReplicatedStorage.Players:FindFirstChild(user.Name).Inventory.ChildAdded:Connect(AdjustWeaponFireSpeed)
ReplicatedStorage.Players:FindFirstChild(user.Name).Inventory.ChildRemoved:Connect(AdjustWeaponFireSpeed)



		end 
	end 	
end 
do
	do
		do
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
local Humanoid = Character:WaitForChild("Humanoid")
local Animator = Humanoid:WaitForChild("Animator")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local workspace = game:GetService("Workspace")

local RigModel
local Torso
local LeftArm
local RightArm
local LeftLeg
local RightLeg
local Head

local IsDesyncEnabled = false
local IsVisualizeEnabled = false
local IsDesyncActive = false
local DesyncConnection = nil
local OffsetX, OffsetY, OffsetZ = 0, -2, 0
local RandomRange = 0
local UseRelativeOffset = true
local RotationX, RotationY, RotationZ = 84, 0, 0
local FillTransparency = 0
local FillColor = Color3.fromRGB(255, 255, 255)

local animationParams = {
	id = "rbxassetid://15609995579",
	timePos = 2.35,
	speed = 0
}

local function ApplyColor(color)
	for _, part in pairs({Torso, LeftArm, RightArm, LeftLeg, RightLeg, Head}) do
		if part then
			part.BrickColor = BrickColor.new(color)
		end
	end
end

local function CreatePart(name, size, position)
	local part = Instance.new("Part")
	part.Name = name
	part.Size = size
	part.Position = position
	part.Anchored = true
	part.CanCollide = false
	part.CanTouch = false
	part.CanQuery = false
	part.Transparency = 1
	part.BrickColor = BrickColor.new(FillColor)
	part.Material = Enum.Material.ForceField
	part.Parent = RigModel
	part.CastShadow = false
	return part
end

local function CreateRigModel()
	if RigModel and RigModel.Parent then
		RigModel:Destroy()
	end
	RigModel = Instance.new("Model")
	RigModel.Name = "RigR6Model"
	RigModel.Parent = workspace
	Torso = CreatePart("Torso", Vector3.new(2, 2, 1), Vector3.new(0, 14, 1))
	LeftArm = CreatePart("LeftArm", Vector3.new(1, 2, 1), Vector3.new(-1.5, 14, 1))
	RightArm = CreatePart("RightArm", Vector3.new(1, 2, 1), Vector3.new(1.5, 14, 1))
	LeftLeg = CreatePart("LeftLeg", Vector3.new(1, 2, 1), Vector3.new(-0.5, 12, 1))
	RightLeg = CreatePart("RightLeg", Vector3.new(1, 2, 1), Vector3.new(0.5, 12, 1))
	Head = CreatePart("Head", Vector3.new(1, 2, 1), Vector3.new(0, 15, 1))
	ApplyColor(FillColor)
end

CreateRigModel()

local function handleAnimation()
	local shouldPlay = IsDesyncEnabled and IsDesyncActive and Humanoid.Health > 0
	for _, track in pairs(Animator:GetPlayingAnimationTracks()) do
		if track.Animation.AnimationId == animationParams.id then
			track:Stop()
			shouldPlay = IsDesyncEnabled and IsDesyncActive and Humanoid.Health > 0
			break
		end
	end
	if shouldPlay then
		local anim = Instance.new("Animation")
		anim.AnimationId = animationParams.id
		local track = Animator:LoadAnimation(anim)
		track:Play()
		track.TimePosition = animationParams.timePos
		track:AdjustSpeed(animationParams.speed)
	end
end

local function UpdateRig(desyncCFrame)
	if Character and HumanoidRootPart then
		if IsDesyncEnabled and IsVisualizeEnabled and desyncCFrame then
			Torso.CFrame = desyncCFrame
		else
			Torso.CFrame = HumanoidRootPart.CFrame
		end
	end
	local torsoCFrame = Torso.CFrame
	LeftArm.CFrame = torsoCFrame * CFrame.new(-1.5, 0, 0)
	RightArm.CFrame = torsoCFrame * CFrame.new(1.5, 0, 0)
	LeftLeg.CFrame = torsoCFrame * CFrame.new(-0.5, -2, 0)
	RightLeg.CFrame = torsoCFrame * CFrame.new(0.5, -2, 0)
	Head.CFrame = torsoCFrame * CFrame.new(0, 1, 0)
end

local function UpdateTransparency()
	local transparency = IsVisualizeEnabled and IsDesyncEnabled and (FillTransparency / 100) or 1
	for _, part in pairs({Torso, LeftArm, RightArm, LeftLeg, RightLeg, Head}) do
		if part then
			part.Transparency = transparency
		end
	end
end

local function ApplyDesync()
	if not HumanoidRootPart or Humanoid.Health <= 0 then return end
	local currentCFrame = HumanoidRootPart.CFrame
	local newCFrame
	local randomX = math.random(-RandomRange, RandomRange)
	local randomY = math.random(-RandomRange, RandomRange)
	local randomZ = math.random(-RandomRange, RandomRange)
	if UseRelativeOffset then
		local lookVector = currentCFrame.LookVector
		local rightVector = currentCFrame.RightVector
		newCFrame = CFrame.new(
			currentCFrame.Position + 
			(rightVector * (OffsetX + randomX)) + 
			(Vector3.new(0, OffsetY + randomY, 0)) + 
			(lookVector * (OffsetZ + randomZ))
		) * currentCFrame.Rotation * CFrame.fromOrientation(math.rad(RotationX), math.rad(RotationY), math.rad(RotationZ))
	else
		newCFrame = CFrame.new(
			currentCFrame.Position + Vector3.new(OffsetX + randomX, OffsetY + randomY, OffsetZ + randomZ)
		) * currentCFrame.Rotation * CFrame.fromOrientation(math.rad(RotationX), math.rad(RotationY), math.rad(RotationZ))
	end
	if newCFrame then
		HumanoidRootPart.CFrame = newCFrame
		RunService.RenderStepped:Wait()
		HumanoidRootPart.CFrame = currentCFrame
		UpdateRig(newCFrame)
	end
end

local function ApplyTransparency(newTransparency)
	FillTransparency = newTransparency
	UpdateTransparency()
end

LocalPlayer.CharacterAdded:Connect(function(newCharacter)
	Character = newCharacter
	HumanoidRootPart = newCharacter:WaitForChild("HumanoidRootPart")
	Humanoid = newCharacter:WaitForChild("Humanoid")
	Animator = newCharacter:WaitForChild("Animator")
	handleAnimation()
end)

Humanoid.HealthChanged:Connect(function(health)
	if health <= 0 then
		if DesyncConnection then
			DesyncConnection:Disconnect()
			DesyncConnection = nil
		end
		IsDesyncActive = false
		if RigModel then
			RigModel:Destroy()
		end
		UpdateRig(nil)
	else
		if IsDesyncEnabled and IsDesyncActive and not DesyncConnection then
			if not RigModel.Parent then
				CreateRigModel()
			end
			DesyncConnection = RunService.Heartbeat:Connect(ApplyDesync)
			handleAnimation()
		end
	end
end)

local underground = Pages["Antiaim"]:Section({Name = "Offset Desync", Side = "Left", Zindex = 5})
underground:Toggle({
	Name = "UnderGround Anti-Aim",
	Flag = "DesyncToggle",
	Callback = function(value)
		IsDesyncEnabled = value
		showToggleNotification("UnderGround Anti-Aim", value)
		playToggleSound(value)
		if not value then
			IsDesyncActive = false
			if RigModel then
				RigModel:Destroy()
			end
			if DesyncConnection then
				DesyncConnection:Disconnect()
				DesyncConnection = nil
			end
			UpdateRig(nil)
			handleAnimation()
		else
			if IsDesyncActive and not DesyncConnection and Humanoid.Health > 0 then
				if not RigModel.Parent then
					CreateRigModel()
				end
				DesyncConnection = RunService.Heartbeat:Connect(ApplyDesync)
				handleAnimation()
			end
			UpdateTransparency()
		end
	end
}):Keybind({
	Name = "UnderGround",
	Flag = "UnderGround",
	Mode = "Toggle",
	Callback = function()
		if IsDesyncEnabled and Humanoid.Health > 0 then
			IsDesyncActive = not IsDesyncActive
			handleAnimation()
			if IsDesyncActive then
				if not RigModel.Parent then
					CreateRigModel()
				end
				if not DesyncConnection then
					DesyncConnection = RunService.Heartbeat:Connect(ApplyDesync)
				end
			else
				if RigModel then
					RigModel:Destroy()
				end
				if DesyncConnection then
					DesyncConnection:Disconnect()
					DesyncConnection = nil
				end
				UpdateRig(nil)
			end
			UpdateTransparency()
		end
	end
})
underground:Toggle({
	Name = "Visualize Desync",
	Flag = "VisualizeDesync",
	Default = false,
	Callback = function(value)
		IsVisualizeEnabled = value
		showToggleNotification("Visualize Desync", value)
		playToggleSound(value)
		UpdateTransparency()
		if IsDesyncEnabled then
			UpdateRig(nil)
		end
	end
})
underground:Colorpicker({
	Name = "Fill Color",
	Flag = "Desyncfillcolor",
	Default = Color3.fromRGB(255, 255, 255),
	Callback = function(value)
		FillColor = value
		ApplyColor(value)
	end
})
underground:Slider({
	Name = "Fill Transparency",
	Suffix = "%",
	Min = 0,
	Max = 100,
	Default = 0,
	Increment = 1,
	Flag = "FillTransparencydesync",
	Callback = function(value)
		ApplyTransparency(value)
	end
})
local game = game
local upangleSettings = {}
upangleSettings.tiltEnabled = false
upangleSettings.tiltValue = 0
upangleSettings.mode = "Custom"

Upangle = Pages["Antiaim"]:Section({Name = "Upangle Edit", Side = "Right", Zindex = 5})

Upangle:Toggle({
	Name = "Upangle Editor",
	Flag = "VisualizeDesync",
	Default = false,
	Callback = function(value)
		upangleSettings.tiltEnabled = value
		showToggleNotification("Visualize Desync", value)
		playToggleSound(value)
	end
})

Upangle:Slider({
	Name = "Angle Count",
	Suffix = "%",
	Min = -70,
	Max = 70,
	Default = 0,
	Flag = "FillTransparencydesync",
	Callback = function(value)
		if upangleSettings.mode == "Custom" then
			upangleSettings.tiltValue = value / 100
		end
	end
})

Upangle:List({
    Name = "Upangle Variables",
    Flag = "Upanglevar",
    Options = {"Custom", "Jitter"},
    Default = "Custom",
    Callback = function(value)
        upangleSettings.mode = value
    end
})

local mt = getrawmetatable(game)
local oldNamecall = mt.__namecall
setreadonly(mt, false)

mt.__namecall = newcclosure(function(self, ...)
    local Method = getnamecallmethod()
    local Args = {...}
    if Method == "FireServer" and self.Name == "UpdateTilt" then
        if upangleSettings and upangleSettings.tiltEnabled then
            if upangleSettings.mode == "Jitter" then
                Args[1] = (math.random(-100, 100) / 100)
            else
                Args[1] = upangleSettings.tiltValue
            end
            return oldNamecall(self, table.unpack(Args))
        end
    end
    return oldNamecall(self, ...)
end)

game.Players.LocalPlayer.CharacterAdded:Connect(function()
    local mt = getrawmetatable(game)
    setreadonly(mt, false)
    mt.__namecall = newcclosure(function(self, ...)
        local Method = getnamecallmethod()
        local Args = {...}
        if Method == "FireServer" and self.Name == "UpdateTilt" then
            if upangleSettings and upangleSettings.tiltEnabled then
                if upangleSettings.mode == "Jitter" then
                    Args[1] = (math.random(-100, 100) / 100)
                else
                    Args[1] = upangleSettings.tiltValue
                end
                return oldNamecall(self, table.unpack(Args))
            end
        end
        return oldNamecall(self, ...)
    end)
    setreadonly(mt, true)
end)

setreadonly(mt, true)
		end
	end
end
do
	do
		do
local PlayerESP, BotESP = Pages["Renders"]:MultiSection({Sections = {"Player ESP", "Bot Esp"}, Side = "Left", Zindex = 7})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

local E = {
    On = false,
    Box = false,
    HBar = false,
    HText = false,
    Name = false,
    Weapon = false,
    MaxD = 2000,
    Color = Color3.fromRGB(115, 100, 215),
    HPos = "Left",
}

local BE = {
    On = false,
    Box = false,
    HBar = false,
    Name = false,
    MaxD = 2000,
    Color = Color3.fromRGB(255, 100, 100),
    HPos = "Left",
}

local T = {} 
local BT = {} 

local function isInFOV(position, maxAngle)
    local camPos = Camera.CFrame.Position
    local toEntity = (position - camPos).Unit
    local camForward = Camera.CFrame.LookVector
    return math.deg(math.acos(toEntity:Dot(camForward))) <= (maxAngle or 70)
end

local function getActiveWeapon(model)
    if not model then return "None" end
    for _, v in pairs(model:GetChildren()) do
        if v:FindFirstChild("ItemRoot") then return v.Name end
    end
    return "None"
end

local function detectBots()
    local bots = {}
    for _, botfold in ipairs(workspace.AiZones:GetChildren()) do
        for _, bot in ipairs(botfold:GetChildren()) do
            if bot:IsA("Model") and bot:FindFirstChild("Humanoid") and bot.Humanoid.Health > 0 then
                table.insert(bots, bot)
            end
        end
    end
    return bots
end

local function CR()
    local r = Drawing.new("Square")
    r.Visible = false
    r.Color = E.Color
    r.Thickness = 1
    r.Filled = false
    r.ZIndex = 1

    local o = Drawing.new("Square")
    o.Visible = false
    o.Color = Color3.new(0, 0, 0)
    o.Thickness = 1
    o.Filled = false
    o.ZIndex = 0

    local i = Drawing.new("Square")
    i.Visible = false
    i.Color = Color3.new(0, 0, 0)
    i.Thickness = 1
    i.Filled = false
    i.ZIndex = 2

    return r, o, i
end

local function BCR()
    local r = Drawing.new("Square")
    r.Visible = false
    r.Color = BE.Color
    r.Thickness = 1
    r.Filled = false
    r.ZIndex = 1

    local o = Drawing.new("Square")
    o.Visible = false
    o.Color = Color3.new(0, 0, 0)
    o.Thickness = 1
    o.Filled = false
    o.ZIndex = 0

    local i = Drawing.new("Square")
    i.Visible = false
    i.Color = Color3.new(0, 0, 0)
    i.Thickness = 1
    i.Filled = false
    i.ZIndex = 2

    return r, o, i
end

local function CH(p)
    local e = {}
    T[p] = e

    e.N = Drawing.new("Text")
    e.N.Visible = false
    e.N.Color = E.Color
    e.N.Size = 11
    e.N.Center = true
    e.N.Outline = true
    e.N.OutlineColor = Color3.new(0, 0, 0)
    e.N.ZIndex = 3

    e.W = Drawing.new("Text")
    e.W.Visible = false
    e.W.Color = Color3.new(1, 1, 1)
    e.W.Size = 11
    e.W.Center = true
    e.W.Outline = true
    e.W.OutlineColor = Color3.new(0, 0, 0)
    e.W.ZIndex = 3

    e.H = Drawing.new("Text")
    e.H.Visible = false
    e.H.Color = E.Color
    e.H.Size = 11
    e.H.Center = true
    e.H.Outline = true
    e.H.OutlineColor = Color3.new(0, 0, 0)
    e.H.ZIndex = 5

    e.S = Drawing.new("Square")
    e.S.Color = E.Color
    e.S.Thickness = 1
    e.S.Filled = true
    e.S.Visible = false
    e.S.ZIndex = 4

    e.SO = Drawing.new("Square")
    e.SO.Color = Color3.new(0, 0, 0)
    e.SO.Thickness = 1
    e.SO.Filled = false
    e.SO.Visible = false
    e.SO.ZIndex = 3
end

local function BCH(b)
    local e = {}
    BT[b] = e

    e.N = Drawing.new("Text")
    e.N.Visible = false
    e.N.Color = BE.Color
    e.N.Size = 11
    e.N.Center = true
    e.N.Outline = true
    e.N.OutlineColor = Color3.new(0, 0, 0)
    e.N.ZIndex = 3

    e.S = Drawing.new("Square")
    e.S.Color = BE.Color
    e.S.Thickness = 1
    e.S.Filled = true
    e.S.Visible = false
    e.S.ZIndex = 4

    e.SO = Drawing.new("Square")
    e.SO.Color = Color3.new(0, 0, 0)
    e.SO.Thickness = 1
    e.SO.Filled = false
    e.SO.Visible = false
    e.SO.ZIndex = 3
end

local function RH(p)
    local e = T[p]
    if not e then return end

    if e.N then e.N:Remove() end
    if e.W then e.W:Remove() end
    if e.H then e.H:Remove() end
    if e.S then e.S:Remove() end
    if e.SO then e.SO:Remove() end
    T[p] = nil
end

local function BRH(b)
    local e = BT[b]
    if not e then return end

    if e.N then e.N:Remove() end
    if e.S then e.S:Remove() end
    if e.SO then e.SO:Remove() end
    BT[b] = nil
end

local function UR(r, o, i, p, lp)
    if p == lp then return end

    local character = p.Character
    local humanoid = character and character:FindFirstChild("Humanoid")
    local rp = character and character:FindFirstChild("HumanoidRootPart")

    if not (character and rp and humanoid and E.On) then
        r.Visible = false
        o.Visible = false
        i.Visible = false
        local e = T[p]
        if e then
            e.N.Visible = false
            e.W.Visible = false
            e.H.Visible = false
            e.S.Visible = false
            e.SO.Visible = false
        end
        return
    end

    if not isInFOV(rp.Position) or (Camera.CFrame.Position - rp.Position).Magnitude > E.MaxD then
        r.Visible = false
        o.Visible = false
        i.Visible = false
        local e = T[p]
        if e then
            e.N.Visible = false
            e.W.Visible = false
            e.H.Visible = false
            e.S.Visible = false
            e.SO.Visible = false
        end
        return
    end

    local pos, onS = Camera:WorldToViewportPoint(rp.Position)
    if not onS then
        r.Visible = false
        o.Visible = false
        i.Visible = false
        local e = T[p]
        if e then
            e.N.Visible = false
            e.W.Visible = false
            e.H.Visible = false
            e.S.Visible = false
            e.SO.Visible = false
        end
        return
    end

    local d = (Camera.CFrame.Position - rp.Position).Magnitude
    local w = 200 / (d / 10)
    local h = 333 / (d / 10)

    r.Color = E.Color
    r.Size = Vector2.new(w, h)
    r.Position = Vector2.new(pos.X - w / 2, pos.Y - h / 2)
    r.Visible = E.Box

    o.Size = Vector2.new(w + 2, h + 2)
    o.Position = Vector2.new(pos.X - (w / 2 + 1), pos.Y - (h / 2 + 1))
    o.Visible = E.Box

    i.Size = Vector2.new(w - 2, h - 2)
    i.Position = Vector2.new(pos.X - (w / 2 - 1), pos.Y - (h / 2 - 1))
    i.Visible = E.Box

    local health = humanoid.Health
    local hr = math.clamp(health / humanoid.MaxHealth, 0, 1)
    local fh = health > 0 and h * hr or 0
    local sp = Vector2.new(pos.X - w / 2 + (E.HPos == "Left" and -6 or w + 6), pos.Y - h / 2)

    local e = T[p]
    if e then
        e.N.Text = p.Name
        e.N.Position = Vector2.new(pos.X, pos.Y - h / 2 - 12)
        e.N.Visible = E.Name

        e.W.Text = getActiveWeapon(character)
        e.W.Position = Vector2.new(pos.X, pos.Y + h / 2)
        e.W.Visible = E.Weapon

        e.S.Position = Vector2.new(sp.X, sp.Y + (h - fh))
        e.S.Size = Vector2.new(2, fh)
        e.S.Visible = E.HBar

        e.SO.Position = sp
        e.SO.Size = Vector2.new(2, h)
        e.SO.Visible = E.HBar

        e.H.Text = string.format("%d", math.floor(health))
        e.H.Position = Vector2.new(sp.X + (E.HPos == "Left" and -12 or 12), pos.Y - h / 2)
        e.H.Visible = E.HText
    end
end

local function BUR(r, o, i, b)
    local humanoid = b:FindFirstChild("Humanoid")
    local rp = b:FindFirstChild("HumanoidRootPart")

    if not (b and rp and humanoid and BE.On) then
        r.Visible = false
        o.Visible = false
        i.Visible = false
        local e = BT[b]
        if e then
            e.N.Visible = false
            e.S.Visible = false
            e.SO.Visible = false
        end
        return
    end

    if not isInFOV(rp.Position) or (Camera.CFrame.Position - rp.Position).Magnitude > BE.MaxD then
        r.Visible = false
        o.Visible = false
        i.Visible = false
        local e = BT[b]
        if e then
            e.N.Visible = false
            e.S.Visible = false
            e.SO.Visible = false
        end
        return
    end

    local pos, onS = Camera:WorldToViewportPoint(rp.Position)
    if not onS then
        r.Visible = false
        o.Visible = false
        i.Visible = false
        local e = BT[b]
        if e then
            e.N.Visible = false
            e.S.Visible = false
            e.SO.Visible = false
        end
        return
    end

    local d = (Camera.CFrame.Position - rp.Position).Magnitude
    local w = 200 / (d / 10)
    local h = 333 / (d / 10)

    r.Color = BE.Color
    r.Size = Vector2.new(w, h)
    r.Position = Vector2.new(pos.X - w / 2, pos.Y - h / 2)
    r.Visible = BE.Box

    o.Size = Vector2.new(w + 2, h + 2)
    o.Position = Vector2.new(pos.X - (w / 2 + 1), pos.Y - (h / 2 + 1))
    o.Visible = BE.Box

    i.Size = Vector2.new(w - 2, h - 2)
    i.Position = Vector2.new(pos.X - (w / 2 - 1), pos.Y - (h / 2 - 1))
    i.Visible = BE.Box

    local health = humanoid.Health
    local hr = math.clamp(health / humanoid.MaxHealth, 0, 1)
    local fh = health > 0 and h * hr or 0
    local sp = Vector2.new(pos.X - w / 2 + (BE.HPos == "Left" and -6 or w + 6), pos.Y - h / 2)

    local e = BT[b]
    if e then
        e.N.Text = b.Name
        e.N.Position = Vector2.new(pos.X, pos.Y - h / 2 - 12)
        e.N.Visible = BE.Name

        e.S.Position = Vector2.new(sp.X, sp.Y + (h - fh))
        e.S.Size = Vector2.new(2, fh)
        e.S.Visible = BE.HBar

        e.SO.Position = sp
        e.SO.Size = Vector2.new(2, h)
        e.SO.Visible = BE.HBar
    end
end

local function PA(p, lp)
    local r, o, i = CR()
    CH(p)
    RunService.RenderStepped:Connect(function()
        UR(r, o, i, p, lp)
    end)
end

local function BPA(b)
    local r, o, i = BCR()
    BCH(b)
    RunService.RenderStepped:Connect(function()
        BUR(r, o, i, b)
    end)
end

local function PR(p)
    RH(p)
end

local function BPR(b)
    BRH(b)
end

local lp = Players.LocalPlayer

Players.PlayerAdded:Connect(function(p)
    p.CharacterAdded:Wait()
    PA(p, lp)
end)

Players.PlayerRemoving:Connect(function(p)
    PR(p)
end)

for _, p in ipairs(Players:GetPlayers()) do
    if p ~= lp then
        if p.Character then
            PA(p, lp)
        else
            p.CharacterAdded:Connect(function()
                PA(p, lp)
            end)
        end
    end
end

local function registerBot(bot)
    if bot:IsA("Model") and bot:FindFirstChild("Humanoid") and bot:FindFirstChild("HumanoidRootPart") and bot.Humanoid.Health > 0 then
        if not BT[bot] then
            BPA(bot)
        end
    end
end

local function initBotESP()
    for _, b in ipairs(detectBots()) do
        registerBot(b)
    end
end

workspace.AiZones.DescendantAdded:Connect(function(descendant)
    task.wait(0.1)
    registerBot(descendant)
end)

workspace.AiZones.DescendantRemoving:Connect(function(descendant)
    if descendant:IsA("Model") and BT[descendant] then
        BPR(descendant)
    end
end)

local lastCheck = 0
RunService.Heartbeat:Connect(function(deltaTime)
    lastCheck = lastCheck + deltaTime
    if lastCheck >= 1 and BE.On then
        for _, b in ipairs(detectBots()) do
            registerBot(b)
        end
        lastCheck = 0
    end
end)

initBotESP()

local function TE(v)
    E.On = v
    if not v then
        for _, e in pairs(T) do
            e.N.Visible = false
            e.W.Visible = false
            e.H.Visible = false
            e.S.Visible = false
            e.SO.Visible = false
        end
    end
end

local function BTE(v)
    BE.On = v
    if not v then
        for _, e in pairs(BT) do
            e.N.Visible = false
            e.S.Visible = false
            e.SO.Visible = false
        end
    end
end

local function TB(v)
    E.Box = v
end

local function BTB(v)
    BE.Box = v
end

local function TN(v)
    E.Name = v
    for _, e in pairs(T) do
        e.N.Visible = v and E.On
    end
end

local function BTN(v)
    BE.Name = v
    for _, e in pairs(BT) do
        e.N.Visible = v and BE.On
    end
end

local function TW(v)
    E.Weapon = v
    for _, e in pairs(T) do
        e.W.Visible = v and E.On
    end
end

local function THB(v)
    E.HBar = v
    for _, e in pairs(T) do
        e.S.Visible = v and E.On
        e.SO.Visible = v and E.On
    end
end

local function BTHB(v)
    BE.HBar = v
    for _, e in pairs(BT) do
        e.S.Visible = v and BE.On
        e.SO.Visible = v and BE.On
    end
end

local function THT(v)
    E.HText = v
    for _, e in pairs(T) do
        e.H.Visible = v and E.On
    end
end

local function SHP(v)
    E.HPos = v
end

local function BSHP(v)
    BE.HPos = v
end

local function UpdateColors(color)
    E.Color = color
    for _, e in pairs(T) do
        e.N.Color = color
        e.H.Color = color
        e.S.Color = color
    end
end

local function BUpdateColors(color)
    BE.Color = color
    for _, e in pairs(BT) do
        e.N.Color = color
        e.S.Color = color
    end
end

PlayerESP:Toggle({
    Name = "Turn Esp", 
    Flag = "Main Enabled", 
    Default = false,
    Callback = function(value)
        TE(value)
        showToggleNotification("Turn Esp", value)
        playToggleSound(value)
    end
})

PlayerESP:Toggle({
    Name = "Show Boxes", 
    Flag = "Boxes Enabled", 
    Callback = function(value)
        TB(value)
        showToggleNotification("Show Boxes", value)
        playToggleSound(value)
    end
})

PlayerESP:Toggle({
    Name = "Show Names", 
    Flag = "Names Enabled", 
    Callback = function(value)
        TN(value)
        showToggleNotification("Show Names", value)
        playToggleSound(value)
    end
})

PlayerESP:Toggle({
    Name = "Show Weapon",
    Flag = "Weapon Enabled", 
    Callback = function(value)
        TW(value)
        showToggleNotification("Show Weapon", value)
        playToggleSound(value)
    end
})

PlayerESP:Toggle({
    Name = "Show Health Bar", 
    Flag = "Health Bar Enabled", 
    Callback = function(value)
        THB(value)
        showToggleNotification("Show Health Bar", value)
        playToggleSound(value)
    end
})

PlayerESP:Toggle({
    Name = "Show Health Text", 
    Flag = "Health Text Enabled", 
    Callback = function(value)
        THT(value)
        showToggleNotification("Show Health Text", value)
        playToggleSound(value)
    end, 
    Default = false
})

PlayerESP:List({
    Name = "Health Bar Position", 
    Flag = "Health Bar Position", 
    Options = {"Left", "Right"}, 
    Default = "Left", 
    Callback = SHP
})

PlayerESP:Colorpicker({
    Name = "ESP Color", 
    Flag = "ESP Color", 
    Default = E.Color, 
    Callback = UpdateColors
})

BotESP:Toggle({
    Name = "Turn Esp", 
    Flag = "Bot Main Enabled", 
    Default = false,
    Callback = function(value)
        BTE(value)
        showToggleNotification("Turn Esp", value)
        playToggleSound(value)
    end
})

BotESP:Toggle({
    Name = "Show Boxes", 
    Flag = "Bot Boxes Enabled", 
    Callback = function(value)
        BTB(value)
        showToggleNotification("Show Boxes", value)
        playToggleSound(value)
    end
})

BotESP:Toggle({
    Name = "Show Names", 
    Flag = "Bot Names Enabled", 
    Callback = function(value)
        BTN(value)
        showToggleNotification("Show Names", value)
        playToggleSound(value)
    end
})

BotESP:Toggle({
    Name = "Show Health Bar", 
    Flag = "Bot Health Bar Enabled", 
    Callback = function(value)
        BTHB(value)
        showToggleNotification("Show Health Bar", value)
        playToggleSound(value)
    end
})

BotESP:List({
    Name = "Health Bar Position", 
    Flag = "Bot Health Bar Position", 
    Options = {"Left", "Right"}, 
    Default = "Left", 
    Callback = BSHP
})

BotESP:Colorpicker({
    Name = "ESP Color", 
    Flag = "Bot ESP Color", 
    Default = BE.Color, 
    Callback = BUpdateColors
})
local Chams = Pages["Renders"]:Section({Name = "Chams", Zindex = 90, Side = "Right"})
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local localPlayer = Players.LocalPlayer

local enabledChams = false
local maxDistance = 2000
local fillTransparency = 0.5
local outlineColor = Color3.fromRGB(0, 255, 0)
local fillColor = Color3.fromRGB(0, 255, 0)

local playerHighlights = {}
local playerStates = {}

local function isInFOV(position, maxAngle)
    local camera = Workspace.CurrentCamera
    local camPos = camera.CFrame.Position
    local toEntity = (position - camPos).Unit
    local camForward = camera.CFrame.LookVector
    local angle = math.deg(math.acos(toEntity:Dot(camForward)))
    return angle <= (maxAngle or 70)
end

local function createHighlight(character)
    local highlight = Instance.new("Highlight")
    highlight.OutlineTransparency = 0
    highlight.FillTransparency = fillTransparency
    highlight.FillColor = fillColor
    highlight.OutlineColor = outlineColor
    highlight.Parent = character
    return highlight
end

local function removeHighlights()
    for player, highlight in pairs(playerHighlights) do
        if highlight then
            highlight:Destroy()
        end
        playerHighlights[player] = nil
        playerStates[player] = nil
    end
end

local function updateAllHighlights()
    if not enabledChams then return end
    
    for player, highlight in pairs(playerHighlights) do
        if highlight and player.Character then
            highlight.FillTransparency = fillTransparency
            highlight.OutlineColor = outlineColor
            highlight.FillColor = fillColor
        end
    end
end

local function updateHighlights()
    if not enabledChams or not localPlayer or not localPlayer.Character then
        removeHighlights()
        return
    end

    local camera = Workspace.CurrentCamera
    local localPos = localPlayer.Character:GetPivot().Position
    local currentTime = tick()

    for _, player in pairs(Players:GetPlayers()) do
        if player == localPlayer then continue end

        local character = player.Character
        local state = playerStates[player] or { lastUpdate = 0, lastPosition = Vector3.new() }
        local highlight = playerHighlights[player]

        if not character or not character:FindFirstChild("Humanoid") or character.Humanoid.Health <= 0 then
            if highlight then
                highlight:Destroy()
                playerHighlights[player] = nil
                playerStates[player] = nil
            end
            continue
        end

        local root = character:FindFirstChild("HumanoidRootPart")
        if not root then
            if highlight then
                highlight:Destroy()
                playerHighlights[player] = nil
                playerStates[player] = nil
            end
            continue
        end

        local position = root.Position
        local distance = (position - localPos).Magnitude
        if state.lastPosition and (position - state.lastPosition).Magnitude < 0.5 and currentTime - state.lastUpdate < 0.1 then
            continue
        end

        if distance > 1000 and currentTime - state.lastUpdate < 0.5 then
            continue
        end

        local inFOV = isInFOV(position)
        local inRange = distance <= maxDistance

        state.distance = distance
        state.inFOV = inFOV
        state.lastUpdate = currentTime
        state.lastPosition = position
        playerStates[player] = state

        if not inRange or not inFOV then
            if highlight then
                highlight:Destroy()
                playerHighlights[player] = nil
            end
            continue
        end

        if not highlight then
            playerHighlights[player] = createHighlight(character)
        end
    end
end

local function UpdateFillTransparency(value)
    fillTransparency = 1 - (value / 100)
    if enabledChams then
        updateAllHighlights()
    end
end

local function setOutlineColor(color)
    outlineColor = color
    if enabledChams then
        updateAllHighlights()
    end
end

local function setFillColor(color)
    fillColor = color
    if enabledChams then
        updateAllHighlights()
    end
end

local function onPlayerAdded(player)
    if player == localPlayer then return end
    player.CharacterAdded:Connect(function(character)
        if not enabledChams then return end
        task.wait(0.5)
        local root = character:FindFirstChild("HumanoidRootPart")
        local hum = character:FindFirstChild("Humanoid")
        if root and hum and hum.Health > 0 and (root.Position - localPlayer.Character:GetPivot().Position).Magnitude <= maxDistance and isInFOV(root.Position) then
            if not playerHighlights[player] then
                playerHighlights[player] = createHighlight(character)
                playerStates[player] = { lastUpdate = tick(), lastPosition = root.Position }
            end
        end
    end)
end

local function onPlayerRemoving(player)
    if playerHighlights[player] then
        playerHighlights[player]:Destroy()
        playerHighlights[player] = nil
        playerStates[player] = nil
    end
end

for _, player in pairs(Players:GetPlayers()) do
    onPlayerAdded(player)
end
Players.PlayerAdded:Connect(onPlayerAdded)
Players.PlayerRemoving:Connect(onPlayerRemoving)

RunService.RenderStepped:Connect(function()
    if enabledChams then
        updateHighlights()
    else
        removeHighlights()
    end
end)

local function toggleChams(state)
    enabledChams = state
    if not enabledChams then
        removeHighlights()
    else
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= localPlayer and player.Character then
                local root = player.Character:FindFirstChild("HumanoidRootPart")
                local hum = player.Character:FindFirstChild("Humanoid")
                if root and hum and hum.Health > 0 and (root.Position - localPlayer.Character:GetPivot().Position).Magnitude <= maxDistance and isInFOV(root.Position) then
                    if not playerHighlights[player] then
                        playerHighlights[player] = createHighlight(player.Character)
                        playerStates[player] = { lastUpdate = tick(), lastPosition = root.Position }
                    end
                end
            end
        end
    end
end

Chams:Toggle({
    Name = "Chams",
    Flag = "MainEnabled",
    Callback = function(value)
        toggleChams(value)
        showToggleNotification("Chams", value)
        playToggleSound(value)
    end
})

Chams:Slider({
    Name = "Fill Transparency",
    Suffix = "%",
    Min = 0,
    Max = 100,
    Default = 50,
    Flag = "BoxFillTransparency",
    Callback = UpdateFillTransparency
})

Chams:Colorpicker({
    Name = "Outline Color",
    Default = Color3.fromRGB(0, 255, 0),
    Flag = "OutlineColor",
    Callback = setOutlineColor
})

Chams:Colorpicker({
    Name = "Fill Color",
    Default = Color3.fromRGB(0, 255, 0),
    Flag = "FillColor",
    Callback = setFillColor
})

local Skeletons = Pages["Renders"]:Section({Name = "Skeletons", Zindex = 6, Side = "Right"})
getgenv().zov_esp = {
    AutoStep = true,
    SkeletonEnabled = false,
    SkeletonColor = Color3.fromRGB(255, 255, 255),
    SkeletonMaxDistance = 2000
}

local rs = game:GetService('RunService')
local cam = workspace.CurrentCamera
local wtv = cam.WorldToViewportPoint
local plrs = game:GetService("Players")
local lp = plrs.LocalPlayer

local zov_skel_conns = {
    {'UpperTorso', 'LowerTorso', Vector3.new(0,0.4,0)},
    {'UpperTorso', 'RightUpperArm', Vector3.new(0,0.4,0)},
    {'UpperTorso', 'LeftUpperArm', Vector3.new(0,0.4,0)},
    {'RightUpperArm', 'RightHand'},
    {'LeftUpperArm', 'LeftHand'},
    {'LowerTorso', 'LeftUpperLeg'},
    {'LeftUpperLeg', 'LeftFoot'},
    {'LowerTorso', 'RightUpperLeg'},
    {'RightUpperLeg', 'RightFoot'}
}

function zov_v2f(v2)
    return Vector2.new(math.floor(v2.X), math.floor(v2.Y))
end

function zov_cfv(cf, flr)
    local pos, vis = wtv(cam, cf * (cf - cf.p):ToObjectSpace(cam.CFrame - cam.CFrame.p).p)
    if flr then pos = zov_v2f(pos) end
    return pos, vis
end

getgenv().zov_plrs = {}
local zov_plr = {}
zov_plr.__index = zov_plr

function zov_plr:Check()
    if self.inst == lp then return false end
    local char = self.inst.Character
    local root = char and char:FindFirstChild('HumanoidRootPart')
    local torso = char and char:FindFirstChild('UpperTorso')
    local head = char and char:FindFirstChild('Head')
    local hum = root and char:FindFirstChild('Humanoid')
    if not hum or hum.Health <= 0 then return false end
    local scr_pos, scr_vis = zov_cfv(torso.CFrame, true)
    if not scr_vis or not isInFOV(root.Position) then return false end
    return true, {
        char = char,
        root = root,
        torso = torso,
        head = head,
        hum = hum,
        pos = scr_pos,
        cf = root.CFrame,
        dist = (root.CFrame.p - cam.CFrame.p).magnitude
    }
end

function zov_plr:Step(d)
    local pass, data = self:Check()
    self:SetVis(false)
    if not pass or data.dist > zov_esp.SkeletonMaxDistance then return else self.vis = true end

    if zov_esp.SkeletonEnabled then
        local cache = {}
        for i, conn in next, zov_skel_conns do
            local drw = self.drws.skel[i]
            local a = data.char:FindFirstChild(conn[1])
            local b = data.char:FindFirstChild(conn[2])
            if a and b then
                local pos_a = cache[a] or zov_cfv(a.CFrame + (conn[3] or Vector3.new()), true)
                local pos_b = cache[b] or zov_cfv(b.CFrame + (conn[4] or Vector3.new()), true)
                cache[a] = pos_a
                cache[b] = pos_b
                drw.Visible = true
                drw.Color = zov_esp.SkeletonColor
                drw.From = pos_a
                drw.To = pos_b
            end
        end
    end
end

function zov_plr:SetVis(b)
    if self.vis ~= b then
        self.vis = b
        for i, v in next, self.drws.skel do v.Visible = b end
    end
end

function zov_esp.NewPlr(inst)
    local p = setmetatable({}, zov_plr)
    p.inst = inst
    p.drws = { skel = {} }
    p.rmv = function() 
        for i, v in next, p.drws.skel do v:Remove() end
    end
    for i = 1, #zov_skel_conns do
        p.drws.skel[i] = Drawing.new('Line')
        p.drws.skel[i].Thickness = 1
    end
    table.insert(zov_plrs, p)
    return p
end

rs.PreRender:Connect(function(d)
    if zov_esp.AutoStep then
        for i, p in next, zov_plrs do
            p:Step(d)
        end
    end
end)

for i, v in next, plrs:GetPlayers() do
    zov_esp.NewPlr(v)
end

plrs.PlayerAdded:Connect(function(p)
    zov_esp.NewPlr(p)
end)

Skeletons:Toggle({
    Name = "Skeletons",
    Flag = "skelfy",
    Callback = function(value)
        zov_esp.SkeletonEnabled = value
        showToggleNotification("Skeletons", value)
        playToggleSound(value)    
    end
})

Skeletons:Colorpicker({
    Name = "Skeletons Color",
    Default = Color3.fromRGB(255, 255, 255),
    Flag = "skelfycolor",
    Callback = function(color)
        zov_esp.SkeletonColor = color
    end
})
do 

local BulletTracers, HitMarkers,HitSound = Pages["Misc"]:MultiSection({Sections = {"Bullet Tracers", "HitMarkers","HitSound"}, Side = "Left", Zindex = 7})


BulletTracers:Toggle({
    Name = "Bullet Tracers",
    Flag = "BulletTracers",
    Callback = function(value)
        tracbool = value
		showToggleNotification("Bullet Tracers", value)
		playToggleSound(value)	
    end
})
BulletTracers:List({
    Name = "Tracer Texture",
    Flag = "TracerTexture",
    Options = {"Glow", "Lighting"},
    Default = "Glow",
    Callback = function(value)
        tractexture = tractextures[value]
    end
})
BulletTracers:Colorpicker({
    Name = "Tracer Color",
    Default = Color3.fromRGB(255, 255, 255),
    Transparency = 1,
    Flag = "TracerColor",
    Callback = function(color)
        traccolor = color
    end
})
BulletTracers:Slider({
    Name = "Tracers Lifetime",
    Suffix = "sec",
    Min = 0,
    Max = 10,
    Default = 2,
    Flag = "TracersLifetime",
    Callback = function(value)
        tracwait = value
    end
})




HitMarkers:Toggle({
    Name = "Hitmarkers",
    Flag = "Hitmarkers",
    Callback = function(value)
        hitmarkbool = value
		showToggleNotification("Hitmarkers", value)
		playToggleSound(value)	
    end
})
HitMarkers:Slider({
    Name = "Hitmarkers Lifetime",
    Suffix = "sec",
    Min = 0,
    Max = 10,
    Default = 2,
    Flag = "HitMarkersLifetime",
    Callback = function(value)
        hitmarkfade = value 
    end
})

HitSound:Toggle({
    Name = "Hit Sound",
    Flag = "HeadshotHitSound",
    Callback = function(value)
        hitsoundbool = value
		showToggleNotification("Hit Sound", value)
		playToggleSound(value)	
    end
})
HitSound:Slider({
    Name = "HitSound Volume",
    Suffix = "%",
    Min = 0,
    Max = 200,
    Default = 50,
    Flag = "HitSoundVolume",
    Callback = function(value)
        hitsoundvolume = value / 100
    end
})
HitSound:List({
    Name = "Hit Sound",
    Flag = "HeadshotSound",
    Options = {"Gamesense", "Rust", "Neverlose", "Bubble","Fatality"},
    Default = "Gamesense",
    Callback = function(value)
        hitsoundhead = value
    end
})

HitSound:Button({
    Name = "Listen Sound",
    Callback = function()
        sound = Instance.new("Sound", workspace)
        sound.SoundId = hitsoundlib[hitsoundhead]
        sound.Volume = hitsoundvolume
        sound:Play()
        task.wait(1)
        sound:Destroy()
    end
})




local WorldTab, WorldMods = Pages["Misc"]:MultiSection({Sections = {"World", "World Modificators"}, Side = "Right", Zindex = 3})
local ContentProvider = game:GetService("ContentProvider")
local Lighting = game:GetService("Lighting")

local skySettings = {
    ["SpongeBob"] = {
        SkyboxBk = "http://www.roblox.com/asset/?id=15962101128",
        SkyboxDn = "http://www.roblox.com/asset/?id=15970246218",
        SkyboxFt = "http://www.roblox.com/asset/?id=15962101128",
        SkyboxLf = "http://www.roblox.com/asset/?id=15962101128",
        SkyboxRt = "http://www.roblox.com/asset/?id=15962101128",
        SkyboxUp = "http://www.roblox.com/asset/?id=15962901054"
    },
    ["Deep Space"] = {
        SkyboxBk = "http://www.roblox.com/asset/?id=159248188",
        SkyboxDn = "http://www.roblox.com/asset/?id=159248183",
        SkyboxFt = "http://www.roblox.com/asset/?id=159248187",
        SkyboxLf = "http://www.roblox.com/asset/?id=159248173",
        SkyboxRt = "http://www.roblox.com/asset/?id=159248192",
        SkyboxUp = "http://www.roblox.com/asset/?id=159248176"
    },
    ["Crazy Hello City"] = {
        SkyboxBk = "http://www.roblox.com/asset/?id=5487778646",
        SkyboxDn = "http://www.roblox.com/asset/?id=5487764867",
        SkyboxFt = "http://www.roblox.com/asset/?id=5487778646",
        SkyboxLf = "http://www.roblox.com/asset/?id=5487778646",
        SkyboxRt = "http://www.roblox.com/asset/?id=5487778646",
        SkyboxUp = "http://www.roblox.com/asset/?id=5487762943"
    },
    ["One Piece"] = {
        SkyboxBk = "http://www.roblox.com/asset/?id=158516797",
        SkyboxDn = "http://www.roblox.com/asset/?id=158516788",
        SkyboxFt = "http://www.roblox.com/asset/?id=158516797",
        SkyboxLf = "http://www.roblox.com/asset/?id=158516797",
        SkyboxRt = "http://www.roblox.com/asset/?id=158516797",
        SkyboxUp = "http://www.roblox.com/asset/?id=158516792"
    },
    ["Matcha"] = {
        SkyboxBk = "http://www.roblox.com/asset/?id=151165214",
        SkyboxDn = "http://www.roblox.com/asset/?id=151165197",
        SkyboxFt = "http://www.roblox.com/asset/?id=151165224",
        SkyboxLf = "http://www.roblox.com/asset/?id=151165191",
        SkyboxRt = "http://www.roblox.com/asset/?id=151165206",
        SkyboxUp = "http://www.roblox.com/asset/?id=151165227"
    },
    ["Abyssal Blues"] = {
        SkyboxBk = "http://www.roblox.com/asset/?id=16269815885",
        SkyboxDn = "http://www.roblox.com/asset/?id=16269839652",
        SkyboxFt = "http://www.roblox.com/asset/?id=16269898011",
        SkyboxLf = "http://www.roblox.com/asset/?id=16269813852",
        SkyboxRt = "http://www.roblox.com/asset/?id=16269814948",
        SkyboxUp = "http://www.roblox.com/asset/?id=16269829700"
    },
    ["Pink Sky"] = {
        SkyboxBk = "http://www.roblox.com/asset/?id=271042516",
        SkyboxDn = "http://www.roblox.com/asset/?id=271077243",
        SkyboxFt = "http://www.roblox.com/asset/?id=271042556",
        SkyboxLf = "http://www.roblox.com/asset/?id=271042310",
        SkyboxRt = "http://www.roblox.com/asset/?id=271042467",
        SkyboxUp = "http://www.roblox.com/asset/?id=271077958"
    },
    ["Green Sky"] = {
        SkyboxBk = "http://www.roblox.com/asset/?id=921882045",
        SkyboxDn = "http://www.roblox.com/asset/?id=921881907",
        SkyboxFt = "http://www.roblox.com/asset/?id=921882121",
        SkyboxLf = "http://www.roblox.com/asset/?id=921881811",
        SkyboxRt = "http://www.roblox.com/asset/?id=921881989",
        SkyboxUp = "http://www.roblox.com/asset/?id=921882259"
    },
    ["Cat"] = {
        SkyboxBk = "http://www.roblox.com/asset/?id=17296096003",
        SkyboxDn = "http://www.roblox.com/asset/?id=17296096003",
        SkyboxFt = "http://www.roblox.com/asset/?id=17296096003",
        SkyboxLf = "http://www.roblox.com/asset/?id=17296096003",
        SkyboxRt = "http://www.roblox.com/asset/?id=17296096003",
        SkyboxUp = "http://www.roblox.com/asset/?id=17296096003"
    }

}

local currentSky = nil
local flags = {}
local currentSkyName = nil
local toggleDebounce = false

local function preloadSkyboxAssets()
    local assets = {}
    for _, settings in pairs(skySettings) do
        table.insert(assets, settings.SkyboxBk)
        table.insert(assets, settings.SkyboxDn)
        table.insert(assets, settings.SkyboxFt)
        table.insert(assets, settings.SkyboxLf)
        table.insert(assets, settings.SkyboxRt)
        table.insert(assets, settings.SkyboxUp)
    end
    ContentProvider:PreloadAsync(assets)
end

local function clearAllSkyObjects()
    for _, obj in pairs(Lighting:GetChildren()) do
        if obj:IsA("Sky") then
            obj:Destroy()
        end
    end
    currentSky = nil
    currentSkyName = nil
end

local function setSky(skyName)
    if skyName == currentSkyName or not flags["CustomSky"] then
        return
    end

    clearAllSkyObjects()

    local settings = skySettings[skyName]
    if settings then
        local sky = Instance.new("Sky")
        sky.Name = "SKY"
        sky.SkyboxBk = settings.SkyboxBk
        sky.SkyboxDn = settings.SkyboxDn
        sky.SkyboxFt = settings.SkyboxFt
        sky.SkyboxLf = settings.SkyboxLf
        sky.SkyboxRt = settings.SkyboxRt
        sky.SkyboxUp = settings.SkyboxUp
        sky.Parent = Lighting
        currentSky = sky
        currentSkyName = skyName
    end
end

local function resetSky()
    clearAllSkyObjects()
end

spawn(function()
    preloadSkyboxAssets()
end)

WorldTab:Toggle({
    Name = "World Sky",
    Flag = "CustomSky",
    Callback = function(value)
        if toggleDebounce then return end
        toggleDebounce = true

        flags["CustomSky"] = value
        showToggleNotification("World Sky", value)
        playToggleSound(value)
        if value then
            local selectedSky = flags["SelectedSky"] or "SpongeBob"
            setSky(selectedSky)
        else
            resetSky()
        end

        task.delay(0.1, function()
            toggleDebounce = false
        end)
    end
})


local allvars = allvars or {}
allvars.worldclock = 12 
local clockbool = false
local runs = game:GetService("RunService")


WorldTab:Toggle({
    Name = "World Time",
    Flag = "CusthdertwsgomTime",
    Default = false,
    Callback = function(value)
        clockbool = value
        showToggleNotification("World Time", value) 
        playToggleSound(value) 
        if value and allvars.worldclock then
            game.Lighting.ClockTime = allvars.worldclock
        else
            
            game.Lighting.ClockTime = game.Lighting:GetMinutesAfterMidnight() / 60
        end
    end
})

WorldTab:Slider({
    Name = "Time",
    Suffix = "h",
    Min = 0,
    Max = 24,
    Default = 12,
    Flag = "Time",
    Callback = function(value)
        allvars.worldclock = value
        if clockbool and allvars.worldclock then
            game.Lighting.ClockTime = value
        end
    end
})

runs.Heartbeat:Connect(function(delta)
    if clockbool and allvars.worldclock then
        game.Lighting.ClockTime = allvars.worldclock
    else
        
        game.Lighting.ClockTime = game.Lighting:GetMinutesAfterMidnight() / 60
    end
end)

runs.Heartbeat:Connect(function(delta)
    if clockbool and allvars.worldclock then
        game.Lighting.ClockTime = allvars.worldclock
    end
end)
WorldTab:List({
    Name = "Select Sky",
    Flag = "SelectedSky",
    Options = {
        "SpongeBob",
        "Deep Space",
        "Crazy Hello City",
        "One Piece",
        "Matcha",
        "Abyssal Blues",
        "Pink Sky",
        "Green Sky",
        "Cat",

    },
    Callback = function(value)
        flags["SelectedSky"] = value
        if flags["CustomSky"] then
            setSky(value)
        end
    end
})


local function setNoGrass(value)
    sethiddenproperty(game:GetService("Workspace").Terrain, "Decoration", not value)
end

local function setNoFog(value)
    game:GetService("Lighting").FogEnd = value and 1000000 or 1000
end

local function setNoShadows(value)
    game:GetService("Lighting").GlobalShadows = not value
end


local ambientEnabled = false
local ambientColor1 = Color3.new(0.5, 0.5, 0.5)
local ambientColor2 = Color3.new(0.7, 0.7, 0.7)
local originalAmbient = game:GetService("Lighting").Ambient
local originalOutdoorAmbient = game:GetService("Lighting").OutdoorAmbient

local function updateAmbient()
    if ambientEnabled then
        game:GetService("Lighting").Ambient = ambientColor1
        game:GetService("Lighting").OutdoorAmbient = ambientColor2
    else
        game:GetService("Lighting").Ambient = originalAmbient
        game:GetService("Lighting").OutdoorAmbient = originalOutdoorAmbient
    end
end


local ambientConnection
game:GetService("RunService").Heartbeat:Connect(function()
    if ambientEnabled then
        game:GetService("Lighting").Ambient = ambientColor1
        game:GetService("Lighting").OutdoorAmbient = ambientColor2
    end
end)
local removeMines = false
local minesToDelete = {} 

WorldMods:Toggle({
    Name = "Remove Mines",
    Flag = "RemoveMines",
    Callback = function(value)
        removeMines = value
        showToggleNotification("Remove Mines", value)
        playToggleSound(value)
    end
})



task.spawn(function()
    while true do
        if removeMines then
            for _, v in ipairs(workspace:GetDescendants()) do
                if table.find(minesToDelete, v.Name) and v:IsA("Model") then
                    v:Destroy()
                end
            end
        end
        wait(1)
    end
end)
WorldMods:Toggle({
    Name = "Remove Grass",
    Flag = "WorldNoGrass",
    Callback = function(value)
        setNoGrass(value)
        showToggleNotification("Remove Grass", value)
        playToggleSound(value)
    end
})

WorldMods:Toggle({
    Name = "Remove Fog",
    Flag = "WorldNoFog",
    Callback = function(value)
        setNoFog(value)
        showToggleNotification("Remove Fog", value)
        playToggleSound(value)
    end
})

WorldMods:Toggle({
    Name = "Remove Clouds",
    Flag = "RemoveClouds",
    Callback = function(value)
        if workspace.Terrain:FindFirstChild("Clouds") then
            workspace.Terrain.Clouds.Enabled = not value
        end
        showToggleNotification("Remove Clouds", value)
        playToggleSound(value)
    end
})

WorldMods:Toggle({
    Name = "Remove Shadows",
    Flag = "WorldNoShadows",
    Callback = function(value)
        setNoShadows(value)
        showToggleNotification("Remove Shadows", value)
        playToggleSound(value)
    end
})
local hideFoliage = false
local foliageParts = {}
local connection

local function getFoliageContainer()
    return workspace:FindFirstChild("Foliage") or workspace:FindFirstChild("SpawnerZones")
end

local function handleFoliageVisibility(state)
    local container = getFoliageContainer()
    if not container then return end

    foliageParts = {} 
    for _, part in ipairs(container:GetDescendants()) do
        if part:IsA("BasePart") and part:FindFirstChildOfClass("SurfaceAppearance") then
            part.Transparency = state and 1 or 0
            if state then
                table.insert(foliageParts, part)
            end
        end
    end
end

local function toggleFoliage(state)
    hideFoliage = state
    handleFoliageVisibility(state)
    showToggleNotification("Remove Foliage", state)
    playToggleSound(state)
end


local function setupFoliageListener()
    local container = getFoliageContainer()
    if container then
        connection = container.DescendantAdded:Connect(function(part)
            if hideFoliage and part:IsA("BasePart") and part:FindFirstChildOfClass("SurfaceAppearance") then
                part.Transparency = 1
                table.insert(foliageParts, part)
            end
        end)
    end
end


local function init()
    setupFoliageListener()
    workspace.ChildAdded:Connect(function(child)
        if child.Name == "Foliage" or child.Name == "SpawnerZones" then
            if connection then
                connection:Disconnect()
            end
            setupFoliageListener()
        end
    end)
end

init()

WorldMods:Toggle({
    Name = "Remove Foliage",
    Flag = "HideFoliage",
    Callback = toggleFoliage
})
WorldMods:Toggle({
    Name = "Remove Visor",
    Flag = "VisorRemoved",
    Callback = function(v)
        antimaskbool = v
		showToggleNotification("Remove Visor", value)
		playToggleSound(value)	
        if v == true then
            game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.HelmetMask.TitanShield.Size = UDim2.new(0,0,1,0)
            game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.Mask.GP5.Size = UDim2.new(0,0,1,0)
            for i,v in ipairs(game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.Visor:GetChildren()) do
                v.Size = UDim2.new(0,0,1,0)
            end
        else
            game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.HelmetMask.TitanShield.Size = UDim2.new(1,0,1,0)
            game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.Mask.GP5.Size = UDim2.new(1,0,1,0)
            for i,v in ipairs(game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.Visor:GetChildren()) do
                v.Size = UDim2.new(1,0,1,0)
            end
        end
    end
})


local function handleAntiMask()
    if antimaskbool then
        game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.HelmetMask.TitanShield.Size = UDim2.new(0,0,1,0)
        game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.Mask.GP5.Size = UDim2.new(0,0,1,0)
        for i,v in ipairs(game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.Visor:GetChildren()) do
            v.Size = UDim2.new(0,0,1,0)
        end
    else
        game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.HelmetMask.TitanShield.Size = UDim2.new(1,0,1,0)
        game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.Mask.GP5.Size = UDim2.new(1,0,1,0)
        for i,v in ipairs(game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.Visor:GetChildren()) do
            v.Size = UDim2.new(1,0,1,0)
        end
    end
end
local workspace = game:GetService("Workspace")


local function checkForSupplyDrop()
    local supplyDrop = workspace:FindFirstChild("Containers") and
    workspace.Containers:FindFirstChild("SupplyDropEDF")
    if supplyDrop then
        Notifications:Notification("EDF drop incoming", 5, Library.Accent, false)
    end
end

local function checkForMilitaryDrop()
    local militaryDrop = workspace:FindFirstChild("Containers") and
    workspace.Containers:FindFirstChild("SupplyDropMilitary")
    if militaryDrop then
        Notifications:Notification("Soviet drop incoming!", 5, Library.Accent, false)
    end
end

checkForSupplyDrop()
checkForMilitaryDrop()

workspace.Containers.ChildAdded:Connect(function(child)
    if child.Name == "SupplyDropEDF" then
        showEDFNotification()
    elseif child.Name == "SupplyDropMilitary" then
        showSovietNotification()
    end
end)

WorldMods:Toggle({
    Name = "EDF Coming Message",
    Flag = "EdfComingMessage",
    Callback = function(value)
		showToggleNotification("EDF Coming Message", value)
		playToggleSound(value)	
        if value then
            checkForSupplyDrop()
        end
    end
})

WorldMods:Toggle({
    Name = "Soviet Coming Message",
    Flag = "SovietComingMessage",
    Callback = function(value)
		showToggleNotification("Soviet Coming Message", value)
		playToggleSound(value)	
        if value then
            checkForMilitaryDrop()
        end
    end
})
WorldMods:Toggle({
    Name = "Custom Ambient",
    Flag = "WorldCustomAmbient",
    Callback = function(value)
        ambientEnabled = value
		showToggleNotification("Custom Ambient", value)
		playToggleSound(value)	
        updateAmbient()
    end
})


WorldMods:Colorpicker({
    Name = "Ambient Color 1", 
    Default = ambientColor1,
    Flag = "WorldAmbientColor1",
    Callback = function(value)
        ambientColor1 = value
        if ambientEnabled then
            updateAmbient()
        end
    end
})

WorldMods:Colorpicker({
    Name = "Ambient Color 2",
    Default = ambientColor2,
    Flag = "WorldAmbientColor2",
    Callback = function(value)
        ambientColor2 = value
        if ambientEnabled then
            updateAmbient()
        end
    end
})
WorldMods:List({
    Name = "Mines to Delete",
    Flag = "MinesList",
    Options = {"PMN2", "MON50", "GrenadeTrap"},
    Default = {}, 
    Max = 3,
    Callback = function(selectedMines)
        minesToDelete = selectedMines
    end
})
local fovzoom = Pages["Misc"]:Section({Name = "Fov/Zoom", Zindex = 2, Side = "Left"})
fovzoom:Toggle({
    Name = "FOV Changer",
    Flag = "ModifyFOV",
    Default = false,
    Callback = function(value)
        allvars.fovchanger = value
		showToggleNotification("FOV Changer", value)
		playToggleSound(value)	
        if dop4 then
            if value and not allvars.zoomchanger and not instazoom then
                dop4.FieldOfView = allvars.basefov
            elseif not value then
                dop4.FieldOfView = 70
            end
        end
    end
})
fovzoom:Toggle({
    Name = "Zoom Changer",
    Flag = "ModifyZoom",
    Default = false,
    Callback = function(value)
        allvars.zoomchanger = value
        showToggleNotification("Zoom", value)
        playToggleSound(value)
        if not value then
            instazoom = false 
        end
        if dop4 then
            local targetfov = (allvars.zoomchanger and instazoom) and allvars.zoomfov or allvars.basefov
            dop4.FieldOfView = targetfov
        end
    end
}):Keybind({
    Name = "Zoom",
    Flag = "Zoom",
    Mode = "Toggle",
    Callback = function(value)
        if not allvars.zoomchanger then return end 
        instazoom = value
        showToggleNotification("Zoom", value)
        playToggleSound(value)
        if dop4 then
            local targetfov = value and allvars.zoomfov or allvars.basefov
            dop4.FieldOfView = targetfov
        end
    end
})

fovzoom:Slider({
    Name = "Base FOV",
    Suffix = "",
    Min = 10,
    Max = 120,
    Default = 100,
    Rounding = 0,
    Flag = "BaseFOV",
    Callback = function(value)
        allvars.basefov = value
        if allvars.fovchanger and not instazoom and dop4 then
            dop4.FieldOfView = value
        end
    end
})

fovzoom:Slider({
    Name = "Zoom FOV",
    Suffix = "",
    Min = 0,
    Max = 50,
    Default = 15,
    Rounding = 0,
    Flag = "ZoomFOV",
    Callback = function(value)
        allvars.zoomfov = value
        if allvars.zoomchanger and instazoom and dop4 then
            dop4.FieldOfView = value
        end
    end
})

do
    csys = require(game.ReplicatedStorage.Modules.CameraSystem)
    dop2 = require(game.ReplicatedStorage.Modules.spring).new(Vector3.new(), Vector3.new(), Vector3.new(), 15, 0.5)
    dop3 = game:GetService("TweenService")
    dop4 = nil
    dop5 = false
    dop6 = 1
    dop7 = false
    dop8 = 1
    dop9 = 1
    dop10 = nil
    allvars = {
        fovchanger = false,
        zoomchanger = false,
        basefov = 70,
        zoomfov = 15
    }
    instazoom = false

    repeat
        dop4 = workspace.CurrentCamera
        task.wait()
    until dop4

    if dop4 then
        dop4.FieldOfView = 70
    end

    function FieldOfViewUpdate(p11, p12, p13)
        if not dop4 or (not allvars.fovchanger and not allvars.zoomchanger) then return end

        local targetfov

        if allvars.zoomchanger and instazoom then
            targetfov = allvars.zoomfov
        elseif allvars.fovchanger then
            targetfov = allvars.basefov
        else
            targetfov = allvars.basefov
        end

        local v16 = dop9 ~= 1 and dop9 or dop5 and dop6 or targetfov

        dop4.FieldOfView = v16

        if dop10 then
            local v_u_17 = dop10
            task.spawn(function()
                local v_u_18 = v_u_17:FindFirstChild("Head") or v_u_17.PrimaryPart
                if v_u_18 then
                    dop2.p = v_u_18.Position
                    local v_u_19 = game:GetService("RunService").RenderStepped:Connect(function(p20)
                        dop4.CFrame = CFrame.lookAt(dop4.CFrame.Position, dop2.p)
                        dop2.target = v_u_18.Position
                        dop2:update(p20)
                        if dop10 ~= v_u_17 then
                            v_u_19:Disconnect()
                        end
                    end)
                end
            end)
        end
    end

    camzoomfunction = function(_, p21, p22, p23, p24, p25)
        dop7 = p22
        dop8 = p21
        if allvars.fovchanger or allvars.zoomchanger then
            FieldOfViewUpdate(p23, p24, p25)
        end
    end
    camzoomfunctionOG = csys.SetZoomTarget

    csys.SetZoomTarget = camzoomfunctionOG

    game:GetService("RunService").Heartbeat:Connect(function()
        if allvars.fovchanger or allvars.zoomchanger then
            csys.SetZoomTarget = camzoomfunction
        else
            csys.SetZoomTarget = camzoomfunctionOG
        end
    end)
end
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")

local localplayer = Players.LocalPlayer
local camthirdp = false
local camthirdpX = 12
local camthirdpY = 2
local camthirdpZ = 5


local function thirdpersongfixed(v)
    camthirdp = v
    if localplayer.Character then
        if camthirdp then
            localplayer.Character.Humanoid.CameraOffset = Vector3.new(camthirdpX, camthirdpY, camthirdpZ)
            localplayer.CameraMaxZoomDistance = 5
            localplayer.CameraMinZoomDistance = 5
        else
            localplayer.Character.Humanoid.CameraOffset = Vector3.new(0, 0, 0)
            localplayer.CameraMaxZoomDistance = 0.5
            localplayer.CameraMinZoomDistance = 0.5
        end
    end
end


local function ThirdPersonFix()
    local mt = getrawmetatable(game)
    local oldIndex = mt.__newindex
    setreadonly(mt, false)
    mt.__newindex = newcclosure(function(self, index, value)
        if tostring(self) == "Humanoid" and index == "CameraOffset" and camthirdp then
            return oldIndex(self, index, Vector3.new(camthirdpX, camthirdpY, camthirdpZ))
        end
        return oldIndex(self, index, value)
    end)
    setreadonly(mt, true)
end

local function SetupTransparencyController()
    local TransparencyController = require(localplayer.PlayerScripts.PlayerModule.CameraModule.TransparencyController)
    TransparencyController.Update = function(a1, a2)
        local setto = camthirdp and 0 or 1
        for _, part in pairs(localplayer.Character:GetDescendants()) do
            if part:IsA("BasePart") and part ~= localplayer.Character.PrimaryPart then
                part.LocalTransparencyModifier = setto
            end
        end
    end
end

localplayer.CharacterAdded:Connect(function(character)
    if camthirdp then
        character:WaitForChild("Humanoid").CameraOffset = Vector3.new(camthirdpX, camthirdpY, camthirdpZ)
        localplayer.CameraMaxZoomDistance = 5
        localplayer.CameraMinZoomDistance = 5
    end
    if selfChams then
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") or part:IsA("MeshPart") then
                part.Material = Enum.Material.ForceField
                part.BrickColor = BrickColor.new(selfChamsColor)
            end
        end
    end
end)

thirdperson = Pages["Misc"]:Section({Name = "Third Person", Zindex = 1, Side = "Right"})
thirdperson:Toggle({
    Name = "Third Person",
    Flag = "AutoFire",
    Callback = function(value)
        thirdpersongfixed(value)
        showToggleNotification("Third Person", value)
        playToggleSound(value)
    end
}):Keybind({
    Name = "Third Person",
    Flag = "thirdpersonkey",
    Mode = "Toggle",
    Callback = function(value)
        thirdpersongfixed(value)
        showToggleNotification("Third Person", value)
        playToggleSound(value)
    end
})
thirdperson:Slider({
    Name = "X offset",
    Suffix = "",
    Min = 0,
    Max = 30,
    Default = 0,
    Flag = "Xthirdpersonoffset",
    Callback = function(value)
        camthirdpX = value

        if camthirdp and localplayer.Character then
            localplayer.Character.Humanoid.CameraOffset = Vector3.new(camthirdpX, camthirdpY, camthirdpZ)
        end
    end
})
thirdperson:Slider({
    Name = "Y offset",
    Suffix = "",
    Min = 0,
    Max = 30,
    Default = 0,
    Flag = "Ythirdpersonoffset",
    Callback = function(value)
        camthirdpY = value
        if camthirdp and localplayer.Character then
            localplayer.Character.Humanoid.CameraOffset = Vector3.new(camthirdpX, camthirdpY, camthirdpZ)
        end
    end
})
thirdperson:Slider({
    Name = "Z offset",
    Suffix = "",
    Min = -30,
    Max = 30,
    Default = 0,
    Flag = "Zthirdpersonoffset",
    Callback = function(value)
        camthirdpZ = value
        if camthirdp and localplayer.Character then
            localplayer.Character.Humanoid.CameraOffset = Vector3.new(camthirdpX, camthirdpY, camthirdpZ)
        end
    end
})


ThirdPersonFix()
if localplayer.Character then
    SetupTransparencyController()
end
local Camera = game:GetService("Workspace").CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local Toggles = {
    ArmsM = { Value = false },
    GunM = { Value = false },
    HideArms = { Value = false }
}
local Options = {
    ArmsFillColor = { Value = Color3.fromRGB(150, 150, 150) },
    ArmsOutlineColor = { Value = Color3.fromRGB(255, 255, 255) },
    GunFillColor = { Value = Color3.fromRGB(150, 150, 150) },
    GunOutlineColor = { Value = Color3.fromRGB(255, 255, 255) },
    ArmsFillTransparency = { Value = 0 },
    GunFillTransparency = { Value = 0 }
}
local originalTransparencies = {}

local function applyHighlight(parent, fillColor, outlineColor, fillTransparency, enabled)
    local hl = parent:FindFirstChildOfClass("Highlight")
    if not hl then
        hl = Instance.new("Highlight")
        hl.Adornee = parent
        hl.Parent = parent
    end
    hl.FillColor = fillColor
    hl.OutlineColor = outlineColor
    hl.FillTransparency = fillTransparency / 100
    hl.OutlineTransparency = enabled and 0 or 1
    hl.Enabled = enabled
end

local function applyChams()
    local vm = Camera:FindFirstChildOfClass("Model")
    if not vm then return end

    local timeout = 5
    local startTime = tick()
    repeat
        task.wait()
        if tick() - startTime > timeout then
            return
        end
    until vm.Name == "ViewModel"

    local armFillColor = Options.ArmsFillColor.Value
    local armOutlineColor = Options.ArmsOutlineColor.Value
    local gunFillColor = Options.GunFillColor.Value
    local gunOutlineColor = Options.GunOutlineColor.Value
    local armFillTransparency = Options.ArmsFillTransparency.Value
    local gunFillTransparency = Options.GunFillTransparency.Value

    for _, v in pairs(vm:GetDescendants()) do
        if v:IsA("Highlight") then
            v:Destroy()
        end
    end

    local ItemView = vm:FindFirstChild("Item")
    if ItemView and Toggles.GunM.Value then
        applyHighlight(ItemView, gunFillColor, gunOutlineColor, gunFillTransparency, true)
        for _, v in pairs(ItemView:GetDescendants()) do
            if (v.ClassName == "MeshPart" or v.ClassName == "Part") and v:FindFirstChildOfClass("SurfaceAppearance") then
                if not v:IsA("BasePart") then
                    v:FindFirstChildOfClass("SurfaceAppearance"):Destroy()
                end
            end
        end
    end

    if Toggles.ArmsM.Value or Toggles.HideArms.Value then
        for _, vm_item in pairs(vm:GetChildren()) do
            if vm_item.ClassName == "MeshPart" and (vm_item.Name:find("Hand") or vm_item.Name:find("Arm")) then
                if Toggles.ArmsM.Value then
                    applyHighlight(vm_item, armFillColor, armOutlineColor, armFillTransparency, not Toggles.HideArms.Value)
                end
                if not originalTransparencies[vm_item] then
                    originalTransparencies[vm_item] = vm_item.Transparency
                end
                vm_item.Transparency = Toggles.HideArms.Value and 1 or originalTransparencies[vm_item]
            elseif vm_item.ClassName == "Model" and (vm_item:FindFirstChild("LL") or vm_item:FindFirstChild("LH")) then
                if Toggles.ArmsM.Value then
                    applyHighlight(vm_item, armFillColor, armOutlineColor, armFillTransparency, not Toggles.HideArms.Value)
                end
                for _, shirt_item in pairs(vm_item:GetChildren()) do
                    if shirt_item:IsA("BasePart") then
                        if not originalTransparencies[shirt_item] then
                            originalTransparencies[shirt_item] = shirt_item.Transparency
                        end
                        shirt_item.Transparency = Toggles.HideArms.Value and 1 or originalTransparencies[shirt_item]
                    end
                    if shirt_item:FindFirstChildOfClass("SurfaceAppearance") and not shirt_item:IsA("BasePart") then
                        shirt_item:FindFirstChildOfClass("SurfaceAppearance"):Destroy()
                    end
                end
            end
        end
    end
end

local function enforceArmTransparency()
    if not Toggles.HideArms.Value then return end
    local vm = Camera:FindFirstChildOfClass("Model")
    if not vm or vm.Name ~= "ViewModel" then return end

    for _, vm_item in pairs(vm:GetChildren()) do
        if vm_item.ClassName == "MeshPart" and (vm_item.Name:find("Hand") or vm_item.Name:find("Arm")) then
            vm_item.Transparency = 1
        elseif vm_item.ClassName == "Model" and (vm_item:FindFirstChild("LL") or vm_item:FindFirstChild("LH")) then
            for _, shirt_item in pairs(vm_item:GetChildren()) do
                if shirt_item:IsA("BasePart") then
                    shirt_item.Transparency = 1
                end
            end
        end
    end
end

Camera.ChildAdded:Connect(function(child)
    if child:IsA("Model") and child.Name == "ViewModel" then
        applyChams()
    end
end)

RunService.RenderStepped:Connect(enforceArmTransparency)

local ArmsMods, GunPosMods = Pages["Misc"]:MultiSection({Sections = {"Arms Modificators", "Gun Position"}, Side = "Left", Zindex = 4})

ArmsMods:Toggle({
    Name = "Arms Highlight",
    Flag = "ArmsM",
    Callback = function(value)
        Toggles.ArmsM.Value = value
        applyChams()
        showToggleNotification("Arms Highlight", value)
        playToggleSound(value)
    end
})

ArmsMods:Toggle({
    Name = "Gun Highlight",
    Flag = "GunM",
    Callback = function(value)
        Toggles.GunM.Value = value
        applyChams()
        showToggleNotification("Gun Highlight", value)
        playToggleSound(value)
    end
})

ArmsMods:Toggle({
    Name = "Hide Arms",
    Flag = "HideArms",
    Callback = function(value)
        Toggles.HideArms.Value = value
        applyChams()
        showToggleNotification("Hide Arms", value)
        playToggleSound(value)
    end
})

ArmsMods:Colorpicker({
    Name = "Arms Fill Color",
    Default = Options.ArmsFillColor.Value,
    Flag = "ArmsFillColor",
    Callback = function(value)
        Options.ArmsFillColor.Value = value
        applyChams()
    end
})

ArmsMods:Colorpicker({
    Name = "Arms Outline Color",
    Default = Options.ArmsOutlineColor.Value,
    Flag = "ArmsOutlineColor",
    Callback = function(value)
        Options.ArmsOutlineColor.Value = value
        applyChams()
    end
})

ArmsMods:Colorpicker({
    Name = "Gun Fill Color",
    Default = Options.GunFillColor.Value,
    Flag = "GunFillColor",
    Callback = function(value)
        Options.GunFillColor.Value = value
        applyChams()
    end
})

ArmsMods:Colorpicker({
    Name = "Gun Outline Color",
    Default = Options.GunOutlineColor.Value,
    Flag = "GunOutlineColor",
    Callback = function(value)
        Options.GunOutlineColor.Value = value
        applyChams()
    end
})

ArmsMods:Slider({
    Name = "Arms Fill Transparency",
    Suffix = "%",
    Min = 0,
    Max = 100,
    Default = 0,
    Flag = "ArmsFillTransparency",
    Callback = function(value)
        Options.ArmsFillTransparency.Value = value
        applyChams()
    end
})

ArmsMods:Slider({
    Name = "Gun Fill Transparency",
    Suffix = "%",
    Min = 0,
    Max = 100,
    Default = 0,
    Flag = "GunFillTransparency",
    Callback = function(value)
        Options.GunFillTransparency.Value = value
        applyChams()
    end
})

local viewmodoffset = false
local viewmodX = 0
local viewmodY = 0
local viewmodZ = 0

GunPosMods:Toggle({
    Name = "Gun Offset",
    Flag = "Gunoffset",
    Callback = function(value)
        viewmodoffset = value
        showToggleNotification("Gun Offset", value)
        playToggleSound(value)
    end
})

GunPosMods:Slider({
    Name = "X offset",
    Min = -5,
    Max = 5,
    Default = 0,
    Flag = "x_offset",
    Callback = function(value)
        viewmodX = value
    end
})

GunPosMods:Slider({
    Name = "Y offset",
    Min = -5,
    Max = 5,
    Default = 0,
    Callback = function(value)
        viewmodY = value
    end
})

GunPosMods:Slider({
    Name = "Z offset",
    Min = -5,
    Max = 5,
    Default = 0,
    Callback = function(value)
        viewmodZ = value
    end
})

local mod = require(game.ReplicatedStorage.Modules.FPS)
local ogfunc = mod.updateClient

mod.updateClient = function(a1, a2, a3)
    local success, arg1, arg2, arg3 = pcall(ogfunc, a1, a2, a3)
    if not success then
        return a1, a2, a3
    end
    
    if viewmodoffset then
        a1.sprintIdleOffset = CFrame.new(Vector3.new(viewmodX, viewmodY, viewmodZ))
        a1.weaponOffset = CFrame.new(Vector3.new(viewmodX, viewmodY, viewmodZ))
    end
    
    return arg1, arg2, arg3
end

Misc = Pages["Misc"]:Section({Name = "Misc", Zindex = 1, Side = "Right"})
Misc:Button({
    Name = "Explode Outpost Mines",
    Callback = function()
        for _, landmine in ipairs(workspace.AiZones.OutpostLandmines:GetChildren()) do
		if landmine.Name == "PMN2" then
			landmine:PivotTo(CFrame.new(game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position - Vector3.new(0, game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Size.Y / 2 + 1, 0)))
		end
	end
    end
})

Misc:Button({
    Name = "Rejoin Server",
    Callback = function()
		game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId,game.JobId) 
	end
})
do
local Movement = Pages["Movement"]:Section({Name = "Main Movement", Zindex = 5, Side = "Left"})
local PlayersService = game:GetService("Players")
local LocalPlayer = PlayersService.LocalPlayer
local SpeedEnhancerConfig = {
    Boost = {IsActive = false, RequiresMotion = true, Intensity = 0.1},
}

local function onFrameUpdate()
    if SpeedEnhancerConfig.Boost.IsActive then
        local character = LocalPlayer.Character
        if character and character:FindFirstChild("Humanoid") then
            local humanoid = character.Humanoid
            if humanoid.MoveDirection.Magnitude > 0 and SpeedEnhancerConfig.Boost.RequiresMotion then
                character:TranslateBy(humanoid.MoveDirection * SpeedEnhancerConfig.Boost.Intensity / 1.5)
            end
        end
    end
end

game:GetService("RunService").RenderStepped:Connect(onFrameUpdate)


Movement:Toggle({
    Name = "Speed Booster",
    Flag = "SpeedBooster",
    Callback = function(value)
        SpeedEnhancerConfig.Boost.IsActive = value
		showToggleNotification("Speed Booster", value)
		playToggleSound(value)		
    end
})

local defaultGravity = 69
local isGravityEnabled = false
local currentGravityValue = 69
local function updateGravity()
    if isGravityEnabled then
        workspace.Gravity = currentGravityValue
    else
        workspace.Gravity = defaultGravity
    end
end
Movement:Toggle({
    Name = "Gravity",
    Flag = "Gravity",
    Default = false,
    Callback = function(value)
        isGravityEnabled = value
        showToggleNotification("Gravity", value)
        playToggleSound(value)
        updateGravity()
    end
})

Movement:Slider({
    Name = "Speed Value",
    Suffix = "",
    Min = 0,
    Max = 10,
    Default = 1,
    Flag = "SBv",
    Callback = function(value)
        SpeedEnhancerConfig.Boost.Intensity = value / 50
    end
})
Movement:Slider({
    Name = "Gravity",
    Suffix = "",
    Min = 0,
    Max = 200,
    Default = 69,
    Flag = "SBv",
    Callback = function(value)
        currentGravityValue = value

        updateGravity()
    end
})
local MovementMods = Pages["Movement"]:Section({Name = "Movement Modificators", Zindex = 5, Side = "Right"})

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")


local Player = Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local Root = Character:WaitForChild("HumanoidRootPart")


local GameFramework = {}
GameFramework.WaterPart = nil
local waterWalkingEnabled = false 


if not Workspace:FindFirstChild("NoCollision") then
    local NoCollisionFolder = Instance.new("Folder")
    NoCollisionFolder.Name = "NoCollision"
    NoCollisionFolder.Parent = Workspace
end


local function CheckWaterAndCreatePlatform()
    if not waterWalkingEnabled then
        
        if GameFramework.WaterPart then
            GameFramework.WaterPart:Destroy()
            GameFramework.WaterPart = nil
        end
        return
    end

    if not Root or not Root.Parent then return end 

    
    local rayOrigin = Root.Position
    local rayDirection = Vector3.new(0, -10, 0)
    local ray = Ray.new(rayOrigin, rayDirection)

    
    local hitPart, hitPosition, _, material = Workspace:FindPartOnRayWithWhitelist(ray, {Workspace.Terrain})

    if material and material == Enum.Material.Water then
        
        if not GameFramework.WaterPart then
            local WaterPart = Instance.new("Part")
            WaterPart.Name = "WaterPlatform"
            WaterPart.Transparency = 1 
            WaterPart.Size = Vector3.new(10, 1, 10)
            WaterPart.CanCollide = true
            WaterPart.Anchored = true
            WaterPart.Parent = Workspace.NoCollision
            GameFramework.WaterPart = WaterPart
        end

        
        if GameFramework.WaterPart then
            GameFramework.WaterPart.Position = Vector3.new(Root.Position.X, hitPosition.Y + 0.5, Root.Position.Z)
        end
    else
        
        if GameFramework.WaterPart then
            GameFramework.WaterPart:Destroy()
            GameFramework.WaterPart = nil
        end
    end
end


local function toggleWaterWalking(value)
    waterWalkingEnabled = value
    if not value and GameFramework.WaterPart then
        GameFramework.WaterPart:Destroy()
        GameFramework.WaterPart = nil
    end
end


RunService.RenderStepped:Connect(CheckWaterAndCreatePlatform)


Player.CharacterAdded:Connect(function(newCharacter)
    Character = newCharacter
    Root = newCharacter:WaitForChild("HumanoidRootPart")
    if GameFramework.WaterPart then
        GameFramework.WaterPart:Destroy()
        GameFramework.WaterPart = nil
    end
end)


    
    MovementMods:Toggle({
        Name = "Walk on Water", 
        Flag = "Wateronwater",
        Callback = function(value)
            toggleWaterWalking(value)
			showToggleNotification("Walk on Water", value)
			playToggleSound(value)		
        end
    })

	local nojumpcd = false

	function startnojumpcd()
		while nojumpcd do
			task.wait(0.01)
			if game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
				game.Players.LocalPlayer.Character.Humanoid:SetAttribute("JumpCooldown", tick())
			else
				wait(1)
			end
		end
	end
	
	
	MovementMods:Toggle({
		Name = "Remove Jump Cooldown",
		Flag = "nojumpcd_toggle",
		Callback = function(value)
			nojumpcd = value
			showToggleNotification("Remove Jump Cooldown", value)
			playToggleSound(value)		
			if value then
				coroutine.wrap(startnojumpcd)()
			end
		end
	})
	

	local disableFallDamage = false
	local instantLand = false
	
	MovementMods:Toggle({
		Name = "Remove Fall Damage",
		Flag = "RemoveFallDamage",
		Callback = function(value)
			disableFallDamage = value
			showToggleNotification("Remove Fall Damage", value)
			playToggleSound(value)
		end
	})
	
	MovementMods:Toggle({
		Name = "Instant Fall",
		Flag = "InstantFall",
		Callback = function(value)
			instantLand = value
			showToggleNotification("Instant Fall", value)
			playToggleSound(value)
		end
	})
	
	game:GetService("RunService").RenderStepped:Connect(function(delta)
		local localplayer = game.Players.LocalPlayer
		if not localplayer.Character or not localplayer.Character:FindFirstChild("HumanoidRootPart") or not localplayer.Character:FindFirstChild("Humanoid") then
			return
		end
	
		local humstate = localplayer.Character.Humanoid:GetState()
		if disableFallDamage and (humstate == Enum.HumanoidStateType.FallingDown or humstate == Enum.HumanoidStateType.Freefall) and localplayer.Character.HumanoidRootPart.AssemblyLinearVelocity.Y < -30 then 
			localplayer.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Landed)
	
			if instantLand and disableFallDamage then 
				local rparams = RaycastParams.new()
				rparams.FilterDescendantsInstances = {
					localplayer.Character:GetDescendants()
				}
				local fray = workspace:Raycast(localplayer.Character.HumanoidRootPart.Position, Vector3.new(0, -400, 0), rparams)
				if fray then
					localplayer.Character.HumanoidRootPart.CFrame = CFrame.new(fray.Position + Vector3.new(0, 3, 0))
				end
			end
		end
	end)

	local istantLeanchik = false

	
	do
		local fpsModule = require(game.ReplicatedStorage.Modules.FPS)
		local originalUpdateClient = fpsModule.updateClient
	
		fpsModule.updateClient = function(playerData, param2, param3)
			local result1, result2, result3 = originalUpdateClient(playerData, param2, param3)
			
			if istantLeanchik then
				playerData.springs.leanAlpha.Speed = 15
			else
				playerData.springs.leanAlpha.Speed = 5
			end
	
			return result1, result2, result3
		end
	end
	
	
	MovementMods:Toggle({
		Name = "Instant Lean",
		Flag = "InstantLeanToggle",
		Default = false,
		Callback = function(isEnabled)
			istantLeanchik = isEnabled
			showToggleNotification("Instant Lean", value)
        	playToggleSound(value)
		end
	})

end
end
	do
local MoreSettings = Pages["Settings"]:Section({Name = "Other Settings", Side = "Right", Zindex = 3})
local Players = game:GetService("Players")

local playerTrackingEnabled = false

local function sendNotification(message)
    Notifications:Notification(message, 5, Library.Accent, false)
end

local function onPlayerAdded(player)
    if playerTrackingEnabled then
        sendNotification("✅ " .. player.Name .. " joined the game")
    end
end

local function onPlayerRemoving(player)
    if playerTrackingEnabled then
        sendNotification("❌ " .. player.Name .. " left the game")
    end
end

for _, player in ipairs(Players:GetPlayers()) do
    player:GetPropertyChangedSignal("Parent"):Connect(function()
        if not player.Parent then
            onPlayerRemoving(player)
        end
    end)
end

Players.PlayerAdded:Connect(onPlayerAdded)



MoreSettings:Toggle({
    Name = "Show Join/Left players",
    Flag = "leftjoinplayers",
    Callback = function(value)
        playerTrackingEnabled = value
        showToggleNotification("Show Join/Left players", value)
        playToggleSound(value)
    end
})

MoreSettings:Toggle({
    Name = "UI Notifications",
    Flag = "notifications",
    Callback = function(value)
        notificationEnabled = value
        showToggleNotification("Notifications", value)
        playToggleSound(value)
    end
})
MoreSettings:Toggle({
    Name = "UI Sounds",
    Flag = "toggleSounds",
    Callback = function(value)
        soundEnabled = value
        showToggleNotification("Toggle Sounds", value)
        playToggleSound(value)
    end
})
MoreSettings:Toggle({
    Name = "Keybind List",
    Callback = function(state)
        Library.KeyList:SetVisible(state)
        showToggleNotification("Keybind List", state)
        playToggleSound(state)
    end
})
MoreSettings:Slider({
    Name = "UI Sound Volume",
    Suffix = "%",
    Min = 0,
    Max = 200,
    Default = 50, 
    Flag = "SoundVolume",
    Callback = function(value)
		soundVolume = value / 100
    end
})
MoreSettings:Keybind({
    Name = "UI Toggle Key",
    Flag = "UIToggleKey",
    Default = Enum.KeyCode.E,
    Callback = function(newkey)
        if not game:GetService("UserInputService"):GetFocusedTextBox() then
            Library:Toggle(not Library.Open)
        end
    end
})



local Config = Pages["Settings"]:Section({Name = "Config"})
local configNameTextBox = Config:Textbox({
    Flag = "SettingsConfigurationName",
    Name = "Config Name",
    Callback = function(newValue)
        _G.configName = newValue:match("^%s*(.-)%s*$") 
    end
})

local ConfigList = Config:List({
    Name = "Config",
    Flag = "SettingConfigurationList",
    Options = {},
    Callback = function(newValue)
        _G.selectedConfigName = newValue
    end
})

_G.configName = ""
_G.selectedConfigName = ""

local function getConfigList()
    local configNames = {}
    local folderPath = "ExlareRecode"
    if not isfolder(folderPath) then
        makefolder(folderPath)
    end
    local files = listfiles(folderPath)
    for _, file in ipairs(files) do
        if file:match("%.txt$") and not file:match("autoload%.txt$") then
            local fileName = file:match("[^/\\]+$"):sub(1, -5) 
            table.insert(configNames, fileName)
        end
    end
    return configNames
end

local function updateConfigList()
    local configNames = getConfigList()
    ConfigList:Refresh(configNames)
    if not table.find(configNames, _G.selectedConfigName) then
        _G.selectedConfigName = "" 
    end
end

local function saveConfig()
    if not _G.configName or _G.configName == "" then
        Notifications:Notification("Config name cannot be empty", 5, Color3.fromRGB(255, 0, 0), false)
        return
    end

    
    local cleanConfigName = _G.configName:gsub("[^%w_]", "")
    if cleanConfigName == "" then
        Notifications:Notification("Invalid config name. Use letters, numbers, or underscores.", 5, Color3.fromRGB(255, 0, 0), false)
        return
    end

    local folderPath = "ExlareRecode"
    if not isfolder(folderPath) then
        makefolder(folderPath)
    end

    local configFileName = folderPath .. "/" .. cleanConfigName .. ".txt"
    
    local configString = Library:GetConfig()
    if not configString or configString == "" then
        Notifications:Notification("Failed to get config data", 5, Color3.fromRGB(255, 0, 0), false)
        return
    end

    local accentColor = Library.Accent
    configString = configString .. "\nAccent Color: " .. accentColor.R .. "," .. accentColor.G .. "," .. accentColor.B
    configString = configString .. "\nModule Status Messages: " .. tostring(sendModuleStatusMessagesEnabled)

    local success, err = pcall(function()
        writefile(configFileName, configString)
    end)
    if success then
        Notifications:Notification("Config saved: " .. cleanConfigName, 5, Library.Accent, false)
        updateConfigList()
    else
        Notifications:Notification("Failed to save config: " .. tostring(err), 5, Color3.fromRGB(255, 0, 0), false)
    end
end

local function loadConfig()
    if not _G.selectedConfigName or _G.selectedConfigName == "" then
        Notifications:Notification("No config selected", 5, Color3.fromRGB(255, 0, 0), false)
        return
    end

    local folderPath = "ExlareRecode"
    local configFileName = folderPath .. "/" .. _G.selectedConfigName .. ".txt"
    if isfile(configFileName) then
        local success, configString = pcall(readfile, configFileName)
        if success and configString then
            Library:LoadConfig(configString)
            for line in configString:gmatch("[^\r\n]+") do
                if line:find("Accent Color: ") then
                    local colorValues = line:match("Accent Color: (.+)")
                    local r, g, b = colorValues:match("([^,]+),([^,]+),([^,]+)")
                    Library:ChangeAccent(Color3.new(tonumber(r), tonumber(g), tonumber(b)))
                end
            end
            Notifications:Notification("Config loaded: " .. _G.selectedConfigName, 5, Library.Accent, false)
        else
            Notifications:Notification("Failed to read config: " .. tostring(configString), 5, Color3.fromRGB(255, 0, 0), false)
        end
    else
        Notifications:Notification("Config not found: " .. _G.selectedConfigName, 5, Color3.fromRGB(255, 0, 0), false)
    end
end

local function deleteConfig()
    if not _G.selectedConfigName or _G.selectedConfigName == "" then
        Notifications:Notification("No config selected", 5, Color3.fromRGB(255, 0, 0), false)
        return
    end

    local folderPath = "ExlareRecode"
    local configFileName = folderPath .. "/" .. _G.selectedConfigName .. ".txt"
    if isfile(configFileName) then
        local success, err = pcall(delfile, configFileName)
        if success then
            Notifications:Notification("Config deleted: " .. _G.selectedConfigName, 5, Library.Accent, false)
            local autoLoadConfigFile = folderPath .. "/autoload.txt"
            if isfile(autoLoadConfigFile) then
                local autoLoadConfigName = readfile(autoLoadConfigFile)
                if autoLoadConfigName == _G.selectedConfigName then
                    delfile(autoLoadConfigFile)
                    Notifications:Notification("Auto-load config removed: " .. _G.selectedConfigName, 5, Library.Accent, false)
                end
            end
            updateConfigList()
        else
            Notifications:Notification("Failed to delete config: " .. tostring(err), 5, Color3.fromRGB(255, 0, 0), false)
        end
    else
        Notifications:Notification("Config not found: " .. _G.selectedConfigName, 5, Color3.fromRGB(255, 0, 0), false)
    end
end

local function setAutoLoadConfig()
    if not _G.selectedConfigName or _G.selectedConfigName == "" then
        Notifications:Notification("No config selected", 5, Color3.fromRGB(255, 0, 0), false)
        return
    end

    local folderPath = "ExlareRecode"
    local autoLoadConfigFile = folderPath .. "/autoload.txt"
    local configFileName = folderPath .. "/" .. _G.selectedConfigName .. ".txt"
    if not isfile(configFileName) then
        Notifications:Notification("Config not found: " .. _G.selectedConfigName, 5, Color3.fromRGB(255, 0, 0), false)
        return
    end

    local success, err = pcall(function()
        writefile(autoLoadConfigFile, _G.selectedConfigName)
    end)
    if success then
        Notifications:Notification("Auto-load config set to: " .. _G.selectedConfigName, 5, Library.Accent, false)
    else
        Notifications:Notification("Failed to set auto-load: " .. tostring(err), 5, Color3.fromRGB(255, 0, 0), false)
    end
end

local function checkAndLoadAutoConfig()
    local folderPath = "ExlareRecode"
    local autoLoadConfigFile = folderPath .. "/autoload.txt"
    if isfile(autoLoadConfigFile) then
        local success, configName = pcall(readfile, autoLoadConfigFile)
        if success and configName and configName ~= "" then
            local configFileName = folderPath .. "/" .. configName .. ".txt"
            if isfile(configFileName) then
                local success, configString = pcall(readfile, configFileName)
                if success and configString then
                    Library:LoadConfig(configString)
                    for line in configString:gmatch("[^\r\n]+") do
                        if line:find("Accent Color: ") then
                            local colorValues = line:match("Accent Color: (.+)")
                            local r, g, b = colorValues:match("([^,]+),([^,]+),([^,]+)")
                            Library:ChangeAccent(Color3.new(tonumber(r), tonumber(g), tonumber(b)))
                        end

                    end
                    Notifications:Notification("Auto-loaded config: " .. configName, 5, Library.Accent, false)
                else
                    Notifications:Notification("Failed to read auto-load config: " .. tostring(configString), 5, Color3.fromRGB(255, 0, 0), false)
                end
            else
                Notifications:Notification("Auto-load config not found: " .. configName, 5, Color3.fromRGB(255, 0, 0), false)
            end
        end
    end
end

Config:Button({
    Name = "Save",
    Callback = function()
        saveConfig()
    end
})

Config:Button({
    Name = "Load",
    Callback = function()
        loadConfig()
    end
})

Config:Button({
    Name = "Delete",
    Callback = function()
        deleteConfig()
    end
})

Config:Button({
    Name = "Set Auto-Load",
    Callback = function()
        setAutoLoadConfig()
    end
})

Config:Button({
    Name = "Delete All Configs",
    Callback = function()
        local folderPath = "ExlareRecode"
        local files = listfiles(folderPath)
        for _, file in ipairs(files) do
            if file:match("%.txt$") then
                local success, err = pcall(delfile, file)
                if not success then
                    Notifications:Notification("Failed to delete " .. file .. ": " .. tostring(err), 5, Color3.fromRGB(255, 0, 0), false)
                end
            end
        end
        Notifications:Notification("All configs deleted", 5, Library.Accent, false)
        updateConfigList()
    end
})

updateConfigList()
checkAndLoadAutoConfig()


end
end
end
end
end




